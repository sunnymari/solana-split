import {
  CaipNetworksUtil,
  ConstantsUtil as ConstantsUtil3,
  ErrorUtil,
  HelpersUtil,
  LoggerUtil,
  PresetsUtil,
  ProviderUtil,
  WalletUtil
} from "./chunk-MGQQTB2Z.js";
import {
  A,
  AccountController,
  AccountNotFoundError,
  AlertController,
  AssetUtil,
  BlockchainApiController,
  C,
  ChainController,
  ConnectionController,
  ConnectorController,
  ConstantsUtil,
  ConstantsUtil2,
  CoreHelperUtil,
  E,
  EnsController,
  EventsController,
  I,
  IEvents,
  J,
  M,
  ModalController,
  NetworkUtil,
  O,
  OptionsController,
  P,
  ParseUtil,
  Po,
  PublicStateController,
  Qe,
  Qo,
  R,
  RouterController,
  S,
  SIWXUtil,
  SnackController,
  StorageUtil,
  ThemeController,
  V,
  clear,
  concat,
  createStore,
  d,
  defineBlock,
  defineChain,
  defineTransaction,
  defineTransactionReceipt,
  del,
  destr,
  detect,
  esm_exports,
  f,
  f2,
  f3,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  formatLog,
  formatTransaction,
  fromString,
  get,
  getBigIntRpcId,
  h,
  i,
  import_pino,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  k,
  keys,
  m,
  o,
  payloadId,
  r,
  require_cjs,
  require_cjs2,
  require_cjs3,
  safeJsonParse,
  safeJsonStringify,
  serializeAccessList,
  serializeTransaction,
  set,
  setColorTheme,
  setThemeVariables,
  sha256,
  sn,
  toRlp,
  toString,
  toYParitySignatureArray,
  y,
  y2
} from "./chunk-CM2OBTX5.js";
import "./chunk-7WLUAVPG.js";
import "./chunk-YTFVHL6R.js";
import "./chunk-LL5RAPH7.js";
import "./chunk-632RNAPF.js";
import "./chunk-2XUWKOBG.js";
import {
  BaseError,
  FeeCapTooHighError,
  InvalidAddressError,
  InvalidChainIdError,
  TipAboveFeeCapError,
  assertRequest,
  concatHex,
  defineTransactionRequest,
  extract,
  formatTransactionRequest,
  getCallError,
  hexToBigInt as hexToBigInt2,
  hexToBytes,
  hexToNumber as hexToNumber2,
  isAddress,
  maxUint16,
  maxUint256,
  numberToHex as numberToHex2,
  pad,
  parseAccount,
  toBytes,
  toHex as toHex2,
  trim
} from "./chunk-JZPKEIXQ.js";
import "./chunk-XAY6XJAF.js";
import {
  HashMD as HashMD2
} from "./chunk-2SCJTQJB.js";
import {
  LruMap as LruMap2,
  checksumAddress as checksumAddress2,
  defineFormatter as defineFormatter2,
  hexToBigInt as hexToBigInt3,
  hexToNumber as hexToNumber3,
  isHex as isHex2,
  keccak256 as keccak2562,
  keccak_256 as keccak_2562,
  numberToHex as numberToHex3,
  toHex as toHex3
} from "./chunk-56GQADGD.js";
import {
  rotl as rotl2,
  wrapConstructor as wrapConstructor2
} from "./chunk-AKZ6HF36.js";
import {
  require_elliptic
} from "./chunk-FZHNEN4Y.js";
import {
  HashMD
} from "./chunk-FQAAY64Z.js";
import {
  LruMap,
  checksumAddress,
  defineFormatter,
  hexToBigInt,
  hexToNumber,
  isHex,
  keccak256,
  keccak_256,
  numberToHex,
  toHex
} from "./chunk-YO5Y37GQ.js";
import "./chunk-POJ7OFP2.js";
import {
  rotl,
  wrapConstructor
} from "./chunk-FUPOJN5U.js";
import {
  StatusCodes,
  TransportStatusError
} from "./chunk-CWPRFQXL.js";
import "./chunk-PVOWFSIG.js";
import {
  require_events
} from "./chunk-XAZ6AATU.js";
import {
  SOLANA_DEVNET_CHAIN,
  SOLANA_MAINNET_CHAIN,
  SOLANA_TESTNET_CHAIN,
  createSignInMessage,
  registerWallet
} from "./chunk-B24OQGBE.js";
import {
  BaseMessageSignerWalletAdapter,
  BaseSignInMessageSignerWalletAdapter,
  BaseSignerWalletAdapter,
  StandardConnect,
  StandardDisconnect,
  StandardEvents,
  WalletAccountError,
  WalletAdapterNetwork,
  WalletConfigError,
  WalletConnectionError,
  WalletDisconnectedError,
  WalletDisconnectionError,
  WalletError,
  WalletLoadError,
  WalletNotConnectedError,
  WalletNotReadyError,
  WalletPublicKeyError,
  WalletReadyState,
  WalletSendTransactionError,
  WalletSignMessageError,
  WalletSignTransactionError,
  WalletWindowClosedError,
  isIosAndRedirectable,
  isVersionedTransaction,
  scopePollingDetectionStrategy
} from "./chunk-EIKUUROK.js";
import {
  SolanaSignAndSendTransaction,
  SolanaSignMessage,
  SolanaSignTransaction
} from "./chunk-42XXHGZT.js";
import "./chunk-YR6NA55Z.js";
import {
  Keypair,
  PublicKey,
  Transaction,
  VersionedTransaction,
  ed25519,
  init_ed25519,
  init_index_browser_esm,
  require_buffer
} from "./chunk-Y2BXG54Q.js";
import "./chunk-CYECUZGJ.js";
import "./chunk-7NCMP2CM.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-MVEJMUOB.js";

// node_modules/lodash.isequal/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.isequal/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n3, iteratee) {
      var index = -1, result = Array(n3);
      while (++index < n3) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root2["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid3 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid3 ? "Symbol(src)_1." + uid3 : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer6 = moduleExports ? root2.Buffer : void 0;
    var Symbol2 = root2.Symbol;
    var Uint8Array2 = root2.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer6 ? Buffer6.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root2, "DataView");
    var Map2 = getNative(root2, "Map");
    var Promise2 = getNative(root2, "Promise");
    var Set2 = getNative(root2, "Set");
    var WeakMap2 = getNative(root2, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size7 = data.size;
      data.set(key, value);
      this.size += data.size == size7 ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys2, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys2(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual;
  }
});

// node_modules/@solana/wallet-adapter-alpha/lib/esm/adapter.js
init_index_browser_esm();
var AlphaWalletName = "Alpha";
var AlphaWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = AlphaWalletName;
    this.url = "https://github.com/alphabatem/alpha-wallet";
    this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZpZXdCb3g9IjAgMCAxMDgwIDEwODAiPjxkZWZzPjxzdHlsZT4ua3tmaWxsOiNmZmY7fS5se2ZpbGw6dXJsKCNjKTt9Lm17aXNvbGF0aW9uOmlzb2xhdGU7fS5ue2ZpbGw6dXJsKCNqKTtvcGFjaXR5Oi42Nzt9Lm4sLm97bWl4LWJsZW5kLW1vZGU6bXVsdGlwbHk7fS5ve2ZpbGw6dXJsKCNpKTtvcGFjaXR5Oi40MTt9LnB7ZmlsbDp1cmwoI2YpO30ucXtmaWxsOiMwMGNlN2M7fS5ye2ZpbGw6IzJhN2RlMTt9LnN7ZmlsbDp1cmwoI2cpO30udHtmaWxsOnVybCgjYik7fS51e2ZpbGw6dXJsKCNoKTt9LnZ7ZmlsbDp1cmwoI2QpO30ud3tmaWxsOnVybCgjZSk7fTwvc3R5bGU+PGxpbmVhckdyYWRpZW50IGlkPSJiIiB4MT0iNjYzLjIyIiB5MT0iMTAuNTIyIiB4Mj0iMzIzLjIwMiIgeTI9IjM1OS4zNzIiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMSwgMCwgMCwgMSwgMCwgMCkiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiMyNGNlN2IiLz48c3RvcCBvZmZzZXQ9Ii44MjgiIHN0b3AtY29sb3I9IiMyNTdjZTEiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYyIgeDE9IjMzNi4zNjgiIHkxPSItOTguMjg5IiB4Mj0iODQzLjk1OSIgeTI9IjI4MC41OCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iLjQ3NiIgc3RvcC1jb2xvcj0iIzI0Y2U3YiIvPjxzdG9wIG9mZnNldD0iLjgyOCIgc3RvcC1jb2xvcj0iIzI1N2NlMSIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPSJkIiB4MT0iMTk2LjU2NCIgeTE9IjIzMS44OTQiIHgyPSI5MzIuODIyIiB5Mj0iMjMxLjg5NCIgeGxpbms6aHJlZj0iI2MiLz48bGluZWFyR3JhZGllbnQgaWQ9ImUiIHgxPSIyMTQuODczIiB5MT0iMjk5LjIwNyIgeDI9IjgwMy44OCIgeTI9IjI5OS4yMDciIHhsaW5rOmhyZWY9IiNjIi8+PGxpbmVhckdyYWRpZW50IGlkPSJmIiB4MT0iMjA2LjM4NiIgeTE9IjkzNi4yMDIiIHgyPSI3ODUuNjY0IiB5Mj0iNjMzLjA3IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEsIDAsIDAsIDEsIDAsIDApIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIuMzY3IiBzdG9wLWNvbG9yPSIjMjU3Y2UxIi8+PHN0b3Agb2Zmc2V0PSIuODUiIHN0b3AtY29sb3I9IiMyNGNlN2IiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iZyIgeDE9IjIwNC42MTEiIHkxPSI5NTcuMDQzIiB4Mj0iODEyLjQzNiIgeTI9IjYzOC45NzMiIHhsaW5rOmhyZWY9IiNjIi8+PGxpbmVhckdyYWRpZW50IGlkPSJoIiB4MT0iNTc0LjY4NCIgeTE9IjY3NS43MjMiIHgyPSI1NzkuMDU1IiB5Mj0iNjczLjQzNSIgeGxpbms6aHJlZj0iI2MiLz48bGluZWFyR3JhZGllbnQgaWQ9ImkiIHgxPSIxMDQyLjA3IiB5MT0iMTMwOC4zMyIgeDI9IjgzOC43NzciIHkyPSIxNzQ1LjYzIiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKC01NDAuMTUxIC02MzEuNDg1KSByb3RhdGUoLjM5KSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iI2ZmZiIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzAwMCIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPSJqIiB4MT0iMjEzOTcuNjU1IiB5MT0iMTE2MC4zOTIiIHgyPSIyMTE5MS4xNjMiIHkyPSIxNjA0LjU3MyIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSgyMTk3My43NjggLTYzMS40ODUpIHJvdGF0ZSgxNzkuNjEpIHNjYWxlKDEgLTEpIiB4bGluazpocmVmPSIjaSIvPjwvZGVmcz48ZyBjbGFzcz0ibSI+PGcgaWQ9ImEiPjxnPjxnPjxwYXRoIGNsYXNzPSJxIiBkPSJNNTY5LjYyMSw1NDAuMTMxYzQ3LjkzNiwxMDQuNTE0LDk1Ljg3MywyMDkuMDI4LDE0My44MDksMzEzLjU0M2wtMjAyLjcxOSwuMjU4YzE1LjExNCwzNC4xNzUsMzAuMjI5LDY4LjM1LDQ1LjM0MywxMDIuNTI0bDMxNS4zNzIsLjM5OWMtNjYuNDg4LTE0Ni40NTMtMTMyLjk3NS0yOTIuOTA2LTE5OS40NjMtNDM5LjM2LS4wMjEtNjUuOTI5LS4wNDMtMTMxLjg1Ny0uMDY0LTE5Ny43ODYtMzQuMTM2LDE0LjQ0NS02OC4yNzIsMjguODkxLTEwMi40MDgsNDMuMzM2LC4wNDMsNTkuMDI4LC4wODYsMTE4LjA1NywuMTI5LDE3Ny4wODVaIi8+PHBhdGggY2xhc3M9ImsiIGQ9Ik0zNTQuODc0LDg1My41NDVjNDIuMTMyLTEwNC44NTgsODQuMjY1LTIwOS43MTYsMTI2LjM5Ny0zMTQuNTc0LS4wODYtNTguNjQyLS4xNzItMTE3LjI4My0uMjU4LTE3NS45MjQtMzQuMTc5LTE0LjY4Mi02OC4zNTgtMjkuMzY0LTEwMi41MzctNDQuMDQ2LC40Myw2Ni4wNTgsLjg2LDEzMi4xMTUsMS4yOSwxOTguMTczbC0xNzkuNDA3LDQzOS42ODJjMTE4LjU3My0uMTI5LDIzNy4xNDUtLjI1OCwzNTUuNzE4LS4zODctMTUuMDQ3LTM0LjE3OS0zMC4wOTUtNjguMzU4LTQ1LjE0Mi0xMDIuNTM3LTUyLjAyMS0uMTI5LTEwNC4wNDEtLjI1OC0xNTYuMDYyLS4zODdaIi8+PGNpcmNsZSBjbGFzcz0idCIgY3g9IjUyMS40NTgiIGN5PSIxNTUuOTY2IiByPSIzOC43NzIiLz48Y2lyY2xlIGNsYXNzPSJsIiBjeD0iNjU1LjM2NCIgY3k9IjEzOS44MTEiIHI9IjYxLjkyNyIvPjxjaXJjbGUgY2xhc3M9InYiIGN4PSI1ODEuNTkiIGN5PSIyMzEuODk0IiByPSIyOS42MTciLz48Y2lyY2xlIGNsYXNzPSJ3IiBjeD0iNTIyLjg5NCIgY3k9IjI5OS4yMDciIHI9IjIzLjY5NCIvPjxwYXRoIGNsYXNzPSJwIiBkPSJNNTc2LjYxOSw3MzcuNzgxYy0uMzM2LS41OTktMy4zNTctNi4wOS04LjEyNy0xMy4yMTQtMS40MzEtMi4xMzctMy4wNDktNC40NDItNC45MjEtNi45NTItOC43OC0xMS43NjgtNDAuOTY4LTU0LjkxNC02OS45ODctNTEuMDA3LTIuNzY2LC4zNzItNC43MjksLjk3LTYuMzMzLDEuNDgxLTIzLjc1MSw3LjU3Mi0zNC4yNCwzNC41MTUtNDEuMDYsNTEuNTc0LTExLjg0MSwyOS42MTYtMjUuNTM5LDYxLjczMy00Mi4xMzYsMTAwLjMwNSw4NS4zMjcsLjIyOCwxNzAuNjUzLC40NTYsMjU1Ljk4LC42ODQtNTkuOTkzLTU1Ljk4MS04MC4xNTktNzcuMDY1LTgzLjQxNS04Mi44NzFaIi8+PHBhdGggY2xhc3M9InMiIGQ9Ik01MDUuNzc3LDcxNC4zNzljLTEzLjc0Nyw3Ljk5Mi0yNi44OTEsMTEuODU4LTMzLjcwMiwxMy42ODktMTIuNDM0LDMuMzQyLTIzLjIzNCw0LjQ5NC0zMS4wNDUsNC44ODRsLTM2Ljc5Niw4Ny4yNTJjODUuMjY2LC4wNjUsMTcwLjUzMiwuMTI5LDI1NS43OTksLjE5NC0xNC42Ni0zNS45ODQtMjkuMzIxLTcxLjk2OS00My45ODEtMTA3Ljk1NC0xMC41OTgtMjAuNzAyLTIwLjE4NC0zMi4zMTgtMjguNDg4LTM4LjU4NS02LjI4MS00Ljc0LTExLjgyOC02LjQyLTE2LjUyNi02LjY1Ni0uMzQ4LS4wMTgtLjY5Mi0uMDI3LTEuMDMtLjAzLTIwLjc4MS0uMTQ1LTI5LjUwNiwyNy4wMTgtNjQuMjMsNDcuMjA1WiIvPjxwYXRoIGNsYXNzPSJyIiBkPSJNNTM4LjkyNCw5NjguMTgxYzEuNDYzLDAsMS40NjUtMi4yNzMsMC0yLjI3M3MtMS40NjUsMi4yNzMsMCwyLjI3M2gwWiIvPjxsaW5lIGNsYXNzPSJ1IiB4MT0iNTc4LjAwNCIgeTE9IjY3NC42NTQiIHgyPSI1NzUuOTQxIiB5Mj0iNjc0LjM5NiIvPjwvZz48cGF0aCBjbGFzcz0ibyIgZD0iTTM3OS44MzEsNTE3LjEwOWMzMy44MzUsNy4yODcsNjcuNjcsMTQuNTc0LDEwMS41MDUsMjEuODYybC0xMjYuNDUsMzE0LjU2MiwxNTYuMDY2LC4zOTljMTUuMDQ2LDM0LjE3OSwzMC4wOTIsNjguMzU4LDQ1LjEzOCwxMDIuNTM3LTExOC41NzcsLjE1LTIzNy4xNTMsLjMwMS0zNTUuNzMsLjQ1MSw1OS44MjQtMTQ2LjYwNCwxMTkuNjQ4LTI5My4yMDcsMTc5LjQ3MS00MzkuODExWiIvPjxwYXRoIGNsYXNzPSJuIiBkPSJNNjcxLjkyOCw1MTcuNTMyYy0zNC4xMTQsNy41MjktNjguMjI5LDE1LjA1OC0xMDIuMzQzLDIyLjU4Nyw0Ny45NDcsMTA0LjUxNiw5NS44OTQsMjA5LjAzMSwxNDMuODQxLDMxMy41NDctNjcuNDk2LC4wODktMTM0Ljk5MSwuMTc3LTIwMi40ODcsLjI2NiwxNS4wNDksMzQuMTgzLDMwLjA5OSw2OC4zNjcsNDUuMTQ4LDEwMi41NSwxMDUuMTE1LC4xMjYsMjEwLjIzLC4yNTMsMzE1LjM0NSwuMzc5LTY2LjUwMi0xNDYuNDQzLTEzMy4wMDMtMjkyLjg4Ni0xOTkuNTA1LTQzOS4zMjlaIi8+PC9nPjwvZz48L2c+PC9zdmc+";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2;
        if ((_a2 = window.alpha) == null ? void 0 : _a2.isAlpha) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    var _a2;
    return !!((_a2 = this._wallet) == null ? void 0 : _a2.isConnected);
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.alpha;
      if (!wallet.isConnected) {
        try {
          await wallet.connect();
        } catch (error) {
          throw new WalletConnectionError(error == null ? void 0 : error.message, error);
        }
      }
      if (!wallet.publicKey)
        throw new WalletAccountError();
      let publicKey;
      try {
        publicKey = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      wallet.on("disconnect", this._disconnected);
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.off("disconnect", this._disconnected);
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async sendTransaction(transaction, connection, options = {}) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signers, ...sendOptions } = options;
        transaction = await this.prepareTransaction(transaction, connection, sendOptions);
        (signers == null ? void 0 : signers.length) && transaction.partialSign(...signers);
        sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
        const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);
        return signature;
      } catch (error) {
        if (error instanceof WalletError)
          throw error;
        throw new WalletSendTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signature } = await wallet.signMessage(message);
        return signature;
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-avana/lib/esm/adapter.js
init_index_browser_esm();
var AvanaWalletName = "Avana";
var AvanaWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = AvanaWalletName;
    this.url = "https://www.avanawallet.com";
    this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyNi4yLjEsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiDQoJIHZpZXdCb3g9IjAgMCAyODkuNzg3ODEgMjg5Ljc4NzgxIiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCAyODkuNzg3ODEgMjg5Ljc4NzgxIiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxwYXRoIGZpbGw9IiMxQzFDMUMiIGQ9Ik0yMTguNDM5MDEsMjg5Ljc4NzgxSDcxLjM0ODhDMzEuOTQzOTUsMjg5Ljc4NzgxLDAsMjU3Ljg0Mzg3LDAsMjE4LjQzOTAxVjcxLjM0ODgNCglDMCwzMS45NDM5NSwzMS45NDM5NSwwLDcxLjM0ODgsMGgxNDcuMDkwMjFjMzkuNDA0ODYsMCw3MS4zNDg4LDMxLjk0Mzk1LDcxLjM0ODgsNzEuMzQ4OHYxNDcuMDkwMjENCglDMjg5Ljc4NzgxLDI1Ny44NDM4NywyNTcuODQzODcsMjg5Ljc4NzgxLDIxOC40MzkwMSwyODkuNzg3ODF6Ii8+DQo8bGluZWFyR3JhZGllbnQgaWQ9IlNWR0lEXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjczLjU4NTUzIiB5MT0iMjE3Ljk4MDgzIiB4Mj0iMjA4LjY0NzQ5IiB5Mj0iLTY0LjU5NzU2IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMjkwLjc5MzAzKSI+DQoJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzE2RkVBOCIvPg0KCTxzdG9wICBvZmZzZXQ9IjAuNCIgc3R5bGU9InN0b3AtY29sb3I6IzAwREFGRiIvPg0KCTxzdG9wICBvZmZzZXQ9IjAuOTIiIHN0eWxlPSJzdG9wLWNvbG9yOiNEQzFGRkYiLz4NCgk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojREMxRkZGIi8+DQo8L2xpbmVhckdyYWRpZW50Pg0KPHBhdGggZmlsbD0idXJsKCNTVkdJRF8xXykiIGQ9Ik0yMzUuNzgxMjIsMjE3LjA0NTMzTDE1Ny43MjQ0Myw0OC40NTUyMmMtNS4wMzU4MS0xMC45MjA1NC0yMC41Mzk3Ni0xMC45MjA1NC0yNS41NzU1OSwwDQoJbC0zOS4xODM4OSw4NC41OTIxNGMtMS4xMDM0MiwyLjQwNDcyLTEuNjQwOTcsNC45NzkzNy0xLjY0MDk3LDcuNDY5MDZjMCw3LjEwMTA3LDQuMjQzNzUsMTMuODkxMTMsMTEuNDAxNDQsMTYuNjYzNjQNCgljOC44ODM2NCwzLjQ1MTY4LDE4LjkyNzEzLTEuMTAzMjMsMjIuOTQ0NjYtOS43NjA0OGw5Ljc4ODgyLTIxLjEzMzk2YzMuNzM0NTEtOC4wOTEzOCwxNS4yMjA5Mi04LjA5MTM4LDE4Ljk1NTQ2LDANCglsMTYuNDQ4MiwzNS41NTM0M2MyLjQxMjAyLDUuMjEzNjctMS43MDg5MiwxMS4wMjA4My03LjQzNzA5LDEwLjU4NzAxYy02Ny42NzI1LTUuMTI0OTQtMTA1LjA3MzAzLDM4LjcwMzA5LTEwNi4xNjQ3Niw0MC4wMDc3NA0KCWMtMC4wMjgxNCwwLjAyODMxLTAuMDI4MTQsMC4wMjgzMS0wLjAyODE0LDAuMDI4MzFjLTMuMDI3MjMsMy4xOTY5OS00Ljg5NDU4LDcuNDY5MDYtNC44OTQ1OCwxMi4yNTAxOA0KCWMwLDkuODE3MzEsNy45NDk5NCwxNy43NjcyNiwxNy43Mzg5MywxNy43NjcyNmM1LjE3NzQzLDAsOS44NDU0NS0yLjIzNDk5LDEzLjA5OTA1LTUuNzcxNDRjMCwwLDAuMDg0NzktMC4xMTMzLDAuMjU0NTMtMC4zMTEzNg0KCWMwLjExMzI4LTAuMTEzMTEsMC4yNTQ3MS0wLjI1NDUzLDAuMzk2MTMtMC40MjQyNmM0Ljk0NjEtNS4zMDEyNSwzNy42MTI0LTM3LjM5MDI3LDkyLjA2NjE1LTI2LjM1OTA3DQoJYzEyLjAxNzc4LDIuNDM0NTQsMjIuMDQ5NjgsMTAuNjgxNywyNy4yMTE2MiwyMS44MDQxNGwwLDBjMy4wMjcyMiw2LjUzNTM3LDkuNTA1OTcsMTEuMDYxOTgsMTYuNzIwMjksMTAuOTc3MDENCglDMjMyLjcyNTY2LDI0Mi4yMjQ4MiwyNDEuMjEzMTcsMjI4Ljc4NjI1LDIzNS43ODEyMiwyMTcuMDQ1MzN6Ii8+DQo8L3N2Zz4NCg==";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2, _b;
        if ((_b = (_a2 = window.avana) == null ? void 0 : _a2.solana) == null ? void 0 : _b.isAvana) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    var _a2;
    return !!((_a2 = this._wallet) == null ? void 0 : _a2.isConnected);
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.avana.solana;
      if (!wallet.isConnected) {
        try {
          await wallet.connect();
        } catch (error) {
          throw new WalletConnectionError(error == null ? void 0 : error.message, error);
        }
      }
      if (!wallet.publicKey)
        throw new WalletAccountError();
      let publicKey;
      try {
        publicKey = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      wallet.on("disconnect", this._disconnected);
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.off("disconnect", this._disconnected);
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async sendTransaction(transaction, connection, options = {}) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signers, ...sendOptions } = options;
        transaction = await this.prepareTransaction(transaction, connection, sendOptions);
        (signers == null ? void 0 : signers.length) && transaction.partialSign(...signers);
        sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
        const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);
        return signature;
      } catch (error) {
        if (error instanceof WalletError)
          throw error;
        throw new WalletSendTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signature } = await wallet.signMessage(message);
        return signature;
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-bitkeep/lib/esm/adapter.js
init_index_browser_esm();
var BitgetWalletName = "Bitget";
var BitgetWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = BitgetWalletName;
    this.url = "https://web3.bitget.com";
    this.icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI1NiIgdmlld0JveD0iMCAwIDI1NiAyNTYiIHdpZHRoPSIyNTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxmaWx0ZXIgaWQ9ImEiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiIgZmlsdGVyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiBoZWlnaHQ9IjQ1MS40MzEiIHdpZHRoPSI1NjkuNTU4IiB4PSItOTAuMjQxMSIgeT0iLTY5LjczNjkiPjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+PGZlQmxlbmQgaW49IlNvdXJjZUdyYXBoaWMiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiBtb2RlPSJub3JtYWwiIHJlc3VsdD0ic2hhcGUiLz48ZmVHYXVzc2lhbkJsdXIgcmVzdWx0PSJlZmZlY3QxX2ZvcmVncm91bmRCbHVyXzIwMzVfMTEwNiIgc3RkRGV2aWF0aW9uPSI0OS4yMzA4Ii8+PC9maWx0ZXI+PGZpbHRlciBpZD0iYiIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGhlaWdodD0iMzcxLjUwNyIgd2lkdGg9IjM1MS41OTYiIHg9Ii0xNjAuNTExIiB5PSItMTY1Ljk4NyI+PGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz48ZmVCbGVuZCBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIG1vZGU9Im5vcm1hbCIgcmVzdWx0PSJzaGFwZSIvPjxmZUdhdXNzaWFuQmx1ciByZXN1bHQ9ImVmZmVjdDFfZm9yZWdyb3VuZEJsdXJfMjAzNV8xMTA2IiBzdGREZXZpYXRpb249IjQ5LjIzMDgiLz48L2ZpbHRlcj48ZmlsdGVyIGlkPSJjIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgaGVpZ2h0PSI0MjQuNDUyIiB3aWR0aD0iNDQ0Ljg1MSIgeD0iLTI0MS4wNzgiIHk9IjY3LjY0MiI+PGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz48ZmVCbGVuZCBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIG1vZGU9Im5vcm1hbCIgcmVzdWx0PSJzaGFwZSIvPjxmZUdhdXNzaWFuQmx1ciByZXN1bHQ9ImVmZmVjdDFfZm9yZWdyb3VuZEJsdXJfMjAzNV8xMTA2IiBzdGREZXZpYXRpb249IjQ5LjIzMDgiLz48L2ZpbHRlcj48ZmlsdGVyIGlkPSJkIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgaGVpZ2h0PSIzODUuMTA1IiB3aWR0aD0iNDMwLjE5MSIgeD0iLTIwLjM5NjgiIHk9Ii0yNDIuNzU4Ij48ZmVGbG9vZCBmbG9vZC1vcGFjaXR5PSIwIiByZXN1bHQ9IkJhY2tncm91bmRJbWFnZUZpeCIvPjxmZUJsZW5kIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9IkJhY2tncm91bmRJbWFnZUZpeCIgbW9kZT0ibm9ybWFsIiByZXN1bHQ9InNoYXBlIi8+PGZlR2F1c3NpYW5CbHVyIHJlc3VsdD0iZWZmZWN0MV9mb3JlZ3JvdW5kQmx1cl8yMDM1XzExMDYiIHN0ZERldmlhdGlvbj0iNDkuMjMwOCIvPjwvZmlsdGVyPjxjbGlwUGF0aCBpZD0iZSI+PHBhdGggZD0ibTAgMGgyNTZ2MjU2aC0yNTZ6Ii8+PC9jbGlwUGF0aD48ZyBjbGlwLXBhdGg9InVybCgjZSkiPjxwYXRoIGQ9Im0wIDBoMjU2djI1NmgtMjU2eiIgZmlsbD0iIzU0ZmZmNSIvPjxnIGZpbHRlcj0idXJsKCNhKSI+PHBhdGggZD0ibTEzLjQ4MDYgMTk4LjYwNWMtNDIuODA4MiAxMjAuNDM4IDE4Ni4xODA0IDg2LjQyMiAzMDYuMDI2NCA1NC4zNTkgMTIyLjY1OC00MC43MDUgMzcuODc5LTIyMC4xMzcxLTUwLjA5Mi0yMjQuMTA4Mi04Ny45NzItMy45NzExIDEwLjkwNyA4Mi45NjgyLTYzLjgyIDEwNy44MDAyLTc0LjcyNyAyNC44MzEtMTM4LjYwNDMtODguNTk3Ny0xOTIuMTE0NCA2MS45NDl6IiBmaWxsPSIjZmZmIi8+PC9nPjxnIGZpbHRlcj0idXJsKCNiKSI+PHBhdGggZD0ibTg1LjUxMTgtNDUuODIyNWMtMjIuNDU1Ni02MS4zNTM1LTEwMi40MzA3IDIxLjgyNzItMTM5LjYxMTMgNzEuMDg2OC0zNS40NjU3IDUzLjU4MzYgNTcuMTA4ODcgOTkuODg3NyA5My40MjAzIDc0Ljc3MjcgMzYuMzExNS0yNS4xMTQzLTMxLjU0NjMyLTMwLjAwMDctOS45NS02Mi42NTg1IDIxLjU5NjMtMzIuNjU3NzQgODQuMjEwMi02LjUwOSA1Ni4xNDEtODMuMjAxeiIgZmlsbD0iIzAwZmZmMCIgZmlsbC1vcGFjaXR5PSIuNjciLz48L2c+PGcgZmlsdGVyPSJ1cmwoI2MpIj48cGF0aCBkPSJtOTYuNDc5NiAyMjUuNDI0Yy0zMC42Mjk0LTEwMy4wNjEtMTYyLjU2MTQtNDguNzg3LTIyNC42OTg2LTguNzY3LTU5Ljc3MSA0Ny4zODUgODIuMTQ3OSAxODMuNjkxIDE0MS4wOTE1IDE3Ni43MTkgNTguOTQzNi02Ljk3My00Ny4yODQzLTY2LjMxMS0xMC44ODU0OC05NS4yMDYgMzYuMzk4NzgtMjguODk0IDEzMi43Nzg5OCA1Ni4wNzkgOTQuNDkyNTgtNzIuNzQ2eiIgZmlsbD0iIzlkODFmZiIvPjwvZz48ZyBmaWx0ZXI9InVybCgjZCkiPjxwYXRoIGQ9Im0yODIuMTItMTA3LjM1M2MtNjYuMDczLTc4LjY3OC0xNjAuNjU3LTEzLjYxNy0xOTkuNjkwNCAyOC43NDgzLTM0LjE1NTcgNDcuOTYwMSAxNDEuODQ1NCAxMzUuODM1OSAxOTAuNjkxNCAxMjAuNzc2MSA0OC44NDctMTUuMDU5OS02Ni42MDktNDYuMjIxNzgtNDUuODI0LTc1LjQ1OTMgMjAuNzg1LTI5LjIzNzYgMTM3LjQxNSAyNC4yODIyNCA1NC44MjMtNzQuMDY1MXoiIGZpbGw9IiM0ZDk0ZmYiLz48L2c+PHBhdGggY2xpcC1ydWxlPSJldmVub2RkIiBkPSJtOTMuMTg5IDE1Mi44MzZoNDMuNDg1bC00OS40NjU0LTQ5Ljc4NSA1MC4xMDE0LTQ5Ljc4NDcgMTMuNjQ1LTEzLjI2NjNoLTQ1LjEzNmwtNTcuNDgzMSA1Ny43NzczYy0yLjkwMSAyLjkxMTctMi44ODYxIDcuNjI0Ny4wMjk3IDEwLjUyMTd6bTI2LjE0MS00OS42NjhoLS4zMzVsLjMzMS0uMDA0em0wIDAgNDkuNDYxIDQ5Ljc4MS01MC4xMDEgNDkuNzg1LTEzLjY0NSAxMy4yNjZoNDUuMTM1bDU3LjQ4NC01Ny43NzRjMi45MDEtMi45MTIgMi44ODYtNy42MjQtLjAzLTEwLjUyMWwtNDQuODIzLTQ0LjUzN3oiIGZpbGw9IiMwMDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvZz48L3N2Zz4=";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2, _b;
        if ((_b = (_a2 = window.bitkeep) == null ? void 0 : _a2.solana) == null ? void 0 : _b.isBitKeep) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.bitkeep.solana;
      let account;
      try {
        account = await wallet.getAccount();
      } catch (error) {
        throw new WalletAccountError(error == null ? void 0 : error.message, error);
      }
      let publicKey;
      try {
        publicKey = new PublicKey(account);
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signature } = await wallet.signMessage(message);
        return signature;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};
var BitKeepWalletName = BitgetWalletName;
var BitKeepWalletAdapter = BitgetWalletAdapter;

// node_modules/@solana/wallet-adapter-bitpie/lib/esm/adapter.js
init_index_browser_esm();
var BitpieWalletName = "Bitpie";
var BitpieWalletAdapter = class extends BaseSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = BitpieWalletName;
    this.url = "https://bitpiecn.com";
    this.icon = `data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjY0IiB2aWV3Qm94PSIwIDAgNjQgNjQiIHdpZHRoPSI2NCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiMxZTNkYTAiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMzNzUwZGUiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgeDE9IjUyLjU0NTc1JSIgeDI9IjUyLjU0NTc1JSIgeGxpbms6aHJlZj0iI2EiIHkxPSIxMDAlIiB5Mj0iMCUiLz48bGluZWFyR3JhZGllbnQgaWQ9ImMiIHgxPSI1MCUiIHgyPSI1MCUiIHkxPSIwJSIgeTI9IjEwMCUiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzFkM2JhMyIgc3RvcC1vcGFjaXR5PSIwIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMTczNzkzIiBzdG9wLW9wYWNpdHk9Ii42NTI5MzgiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iZCIgeDE9IjUwJSIgeDI9IjUwJSIgeGxpbms6aHJlZj0iI2EiIHkxPSIxMDAlIiB5Mj0iMCUiLz48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjxwYXRoIGQ9Im0xOCAwaDI4YzkuOTQxMTI1NSAwIDE4IDguMDU4ODc0NSAxOCAxOHYyOGMwIDkuOTQxMTI1NS04LjA1ODg3NDUgMTgtMTggMThoLTI4Yy05Ljk0MTEyNTUgMC0xOC04LjA1ODg3NDUtMTgtMTh2LTI4YzAtOS45NDExMjU1IDguMDU4ODc0NS0xOCAxOC0xOHoiIGZpbGw9InVybCgjYikiLz48Y2lyY2xlIGN4PSIzMi4yODU3MTQiIGN5PSIzMi4yODU3MTQiIGZpbGw9IiNmZmYiIHI9IjI0LjI4NTcxNCIvPjxwYXRoIGQ9Im0zMiAwYzE3LjY3MzExMiAwIDMyIDE0LjMyNjg4OCAzMiAzMnMtMTQuMzI2ODg4IDMyLTMyIDMyLTMyLTE0LjMyNjg4OC0zMi0zMiAxNC4zMjY4ODgtMzIgMzItMzJ6bS0uMTQzNDk3OCA3LjYwNTM4MTE3Yy0xMy40NzI3NzU5IDAtMjQuMzk0NjE4NzkgMTAuOTIxODQyODMtMjQuMzk0NjE4NzkgMjQuMzk0NjE4ODNzMTAuOTIxODQyODkgMjQuMzk0NjE4OCAyNC4zOTQ2MTg3OSAyNC4zOTQ2MTg4YzEzLjQ3Mjc3NiAwIDI0LjM5NDYxODktMTAuOTIxODQyOCAyNC4zOTQ2MTg5LTI0LjM5NDYxODhzLTEwLjkyMTg0MjktMjQuMzk0NjE4ODMtMjQuMzk0NjE4OS0yNC4zOTQ2MTg4M3oiIGZpbGw9InVybCgjYykiLz48cGF0aCBkPSJtMjkuMDkwOTA5MSA0NC4zNjM2MzY0YzAgMi4wMDgzMDgxLTEuNjI4MDU1NSAzLjYzNjM2MzYtMy42MzYzNjM2IDMuNjM2MzYzNi0yLjAwODMwODIgMC0zLjYzNjM2MzctMS42MjgwNTU1LTMuNjM2MzYzNy0zLjYzNjM2MzZsLS4wMDAxODE4LTIuMTgyNjM2NC0yLjE4MTYzNjQuMDAwODE4MmMtMi4wMDgzMDgxIDAtMy42MzYzNjM2LTEuNjI4MDU1NS0zLjYzNjM2MzYtMy42MzYzNjM3IDAtMi4wMDgzMDgxIDEuNjI4MDU1NS0zLjYzNjM2MzYgMy42MzYzNjM2LTMuNjM2MzYzNmwyLjE4MTYzNjQtLjAwMDA5MDl2LTUuODE5bC0yLjE4MTYzNjQuMDAwOTA5MWMtMi4wMDgzMDgxIDAtMy42MzYzNjM2LTEuNjI4MDU1NS0zLjYzNjM2MzYtMy42MzYzNjM2IDAtMi4wMDgzMDgyIDEuNjI4MDU1NS0zLjYzNjM2MzcgMy42MzYzNjM2LTMuNjM2MzYzN2wyLjE4MTYzNjQtLjAwMDE4MTguMDAwMTgxOC0yLjE4MTYzNjRjMC0yLjAwODMwODEgMS42MjgwNTU1LTMuNjM2MzYzNiAzLjYzNjM2MzctMy42MzYzNjM2IDIuMDA4MzA4MSAwIDMuNjM2MzYzNiAxLjYyODA1NTUgMy42MzYzNjM2IDMuNjM2MzYzNmwtLjAwMDkwOTEgMi4xODE2MzY0aDUuODE5bC4wMDAwOTA5LTIuMTgxNjM2NGMwLTIuMDA4MzA4MSAxLjYyODA1NTUtMy42MzYzNjM2IDMuNjM2MzYzNi0zLjYzNjM2MzYgMi4wMDgzMDgyIDAgMy42MzYzNjM3IDEuNjI4MDU1NSAzLjYzNjM2MzcgMy42MzYzNjM2bC0uMDAwODE4MiAyLjE4MTYzNjQgMi4xODI2MzY0LjAwMDE4MThjMi4wMDgzMDgxIDAgMy42MzYzNjM2IDEuNjI4MDU1NSAzLjYzNjM2MzYgMy42MzYzNjM3IDAgMi4wMDgzMDgxLTEuNjI4MDU1NSAzLjYzNjM2MzYtMy42MzYzNjM2IDMuNjM2MzYzNmwtMi4xODI2MzY0LS4wMDA5MDkxdjUuODE5bDIuMTgyNjM2NC4wMDAwOTA5YzIuMDA4MzA4MSAwIDMuNjM2MzYzNiAxLjYyODA1NTUgMy42MzYzNjM2IDMuNjM2MzYzNiAwIDIuMDA4MzA4Mi0xLjYyODA1NTUgMy42MzYzNjM3LTMuNjM2MzYzNiAzLjYzNjM2MzdsLTIuMTgyNjM2NC0uMDAwODE4Mi4wMDA4MTgyIDIuMTgyNjM2NGMwIDIuMDA4MzA4MS0xLjYyODA1NTUgMy42MzYzNjM2LTMuNjM2MzYzNyAzLjYzNjM2MzYtMi4wMDgzMDgxIDAtMy42MzYzNjM2LTEuNjI4MDU1NS0zLjYzNjM2MzYtMy42MzYzNjM2bC0uMDAwMDkwOS0yLjE4MjYzNjRoLTUuODE5em0tLjAwMDkwOTEtOS40NTQ2MzY0aDUuODE5di01LjgxOWgtNS44MTl6IiBmaWxsPSJ1cmwoI2QpIiB0cmFuc2Zvcm09Im1hdHJpeCguODY2MDI1NCAtLjUgLjUgLjg2NjAyNTQgLTExLjcxMjgxMyAyMC4yODcxODcpIi8+PC9nPjwvc3ZnPg==`;
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        if (window.bitpie) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.bitpie;
      let account;
      try {
        account = await wallet.getAccount();
      } catch (error) {
        throw new WalletAccountError(error == null ? void 0 : error.message, error);
      }
      let publicKey;
      try {
        publicKey = new PublicKey(account);
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    if (this._wallet) {
      this._wallet = null;
      this._publicKey = null;
    }
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-clover/lib/esm/adapter.js
init_index_browser_esm();
var CloverWalletName = "Clover";
var CloverWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = CloverWalletName;
    this.url = "https://clv.org";
    this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIHZpZXdCb3g9IjAgMCA0OCA0OCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTM2LjQ4IDBIMTEuNTJDNS4xNTc2OCAwIDAgNS4xNTc2OCAwIDExLjUyVjM2LjQ4QzAgNDIuODQyMyA1LjE1NzY4IDQ4IDExLjUyIDQ4SDM2LjQ4QzQyLjg0MjMgNDggNDggNDIuODQyMyA0OCAzNi40OFYxMS41MkM0OCA1LjE1NzY4IDQyLjg0MjMgMCAzNi40OCAwWiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzc5MTBfMTYzMzUxKSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTI0LjAwMDYgMzkuMzYwNkMzMi40ODM3IDM5LjM2MDYgMzkuMzYwNiAzMi40ODM3IDM5LjM2MDYgMjQuMDAwNkMzOS4zNjA2IDE1LjUxNzUgMzIuNDgzNyA4LjY0MDYyIDI0LjAwMDYgOC42NDA2MkMxNS41MTc1IDguNjQwNjIgOC42NDA2MiAxNS41MTc1IDguNjQwNjIgMjQuMDAwNkM4LjY0MDYyIDMyLjQ4MzcgMTUuNTE3NSAzOS4zNjA2IDI0LjAwMDYgMzkuMzYwNlpNMjEuMjg5OSAxNS44Njg4SDI2LjcxMVYyMS4zNDdIMjEuMjkwNFYyNi42NTRIMjYuNzExVjMyLjEzMjJIMjEuMjg5OVYyNi44MjUySDE1Ljg2OTNWMjEuMzQ3SDIxLjI4OTlWMTUuODY4OFpNMjYuNzEyIDIxLjM0N0gzMi4xMzMxVjI2LjgyNTJIMjYuNzEyVjIxLjM0N1oiIGZpbGw9ImJsYWNrIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfNzkxMF8xNjMzNTEiIHgxPSI0OCIgeTE9Ii0xLjQzMDUxZS0wNiIgeDI9IjEuNDMwNTFlLTA2IiB5Mj0iNDgiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0E5RkZFMCIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM4NkQ1RkYiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4=";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2;
        if ((_a2 = window.clover_solana) == null ? void 0 : _a2.isCloverWallet) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.clover_solana;
      let account;
      try {
        account = await wallet.getAccount();
      } catch (error) {
        throw new WalletAccountError(error == null ? void 0 : error.message, error);
      }
      let publicKey;
      try {
        publicKey = new PublicKey(account);
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    if (this._wallet) {
      this._wallet = null;
      this._publicKey = null;
    }
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signature } = await wallet.signMessage(message);
        return Uint8Array.from(signature);
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-coin98/lib/esm/adapter.js
init_index_browser_esm();

// node_modules/@solana/wallet-adapter-coin98/node_modules/base-x/src/esm/index.js
function base(ALPHABET4) {
  if (ALPHABET4.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j5 = 0; j5 < BASE_MAP.length; j5++) {
    BASE_MAP[j5] = 255;
  }
  for (let i3 = 0; i3 < ALPHABET4.length; i3++) {
    const x9 = ALPHABET4.charAt(i3);
    const xc2 = x9.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x9 + " is ambiguous");
    }
    BASE_MAP[xc2] = i3;
  }
  const BASE = ALPHABET4.length;
  const LEADER = ALPHABET4.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE);
  function encode7(source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size7 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size7);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i3 = 0;
      for (let it1 = size7 - 1; (carry !== 0 || i3 < length) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i3;
      pbegin++;
    }
    let it22 = size7 - length;
    while (it22 !== size7 && b58[it22] === 0) {
      it22++;
    }
    let str = LEADER.repeat(zeroes);
    for (; it22 < size7; ++it22) {
      str += ALPHABET4.charAt(b58[it22]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size7 = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size7);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i3 = 0;
      for (let it32 = size7 - 1; (carry !== 0 || i3 < length) && it32 !== -1; it32--, i3++) {
        carry += BASE * b256[it32] >>> 0;
        b256[it32] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i3;
      psz++;
    }
    let it42 = size7 - length;
    while (it42 !== size7 && b256[it42] === 0) {
      it42++;
    }
    const vch = new Uint8Array(zeroes + (size7 - it42));
    let j5 = zeroes;
    while (it42 !== size7) {
      vch[j5++] = b256[it42++];
    }
    return vch;
  }
  function decode3(string) {
    const buffer = decodeUnsafe(string);
    if (buffer) {
      return buffer;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode7,
    decodeUnsafe,
    decode: decode3
  };
}
var esm_default = base;

// node_modules/@solana/wallet-adapter-coin98/node_modules/bs58/src/esm/index.js
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default2 = esm_default(ALPHABET);

// node_modules/@solana/wallet-adapter-coin98/lib/esm/polyfills/Buffer.js
var import_buffer = __toESM(require_buffer(), 1);
if (typeof window !== "undefined" && window.Buffer === void 0) {
  window.Buffer = import_buffer.Buffer;
}

// node_modules/@solana/wallet-adapter-coin98/lib/esm/adapter.js
var Coin98WalletName = "Coin98";
var Coin98WalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = Coin98WalletName;
    this.url = "https://coin98.com";
    this.icon = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA3NiA3NSI+CiAgPGRlZnM+CiAgICA8bGluZWFyR3JhZGllbnQgaWQ9ImEiIHgxPSIxMDEuNjgxJSIgeDI9Ii0xLjU1NyUiIHkxPSIxNS4yNjglIiB5Mj0iODQuOTE3JSI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0b3AtY29sb3I9IiNGMUQ5NjEiLz4KICAgICAgPHN0b3Agb2Zmc2V0PSIxMDAlIiBzdG9wLWNvbG9yPSIjQ0RBMTQ2Ii8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogIDwvZGVmcz4KICA8ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgPHJlY3Qgd2lkdGg9Ijc1IiBoZWlnaHQ9Ijc1IiBmaWxsPSIjMDAwIiByeD0iMTYiLz4KICAgIDxwYXRoIGZpbGw9InVybCgjYSkiIGZpbGwtcnVsZT0ibm9uemVybyIgZD0iTTYxLjQ0IDBhMTMuNzE0IDEzLjcxNCAwIDAgMSA5LjY4IDQuMDEgMTMuNjYxIDEzLjY2MSAwIDAgMSA0LjAwOCA5LjY2OHY0Ny42NDZhMTMuNjYgMTMuNjYgMCAwIDEtNC4wMDcgOS42NjZBMTMuNzEzIDEzLjcxMyAwIDAgMSA2MS40NCA3NUgxMy42ODZhMTMuNzEzIDEzLjcxMyAwIDAgMS05LjY4LTQuMDFBMTMuNjYgMTMuNjYgMCAwIDEgMCA2MS4zMjRWMTMuNjc4YzAtMy42MjUgMS40NC03LjEwMiA0LjAwNy05LjY2N0ExMy43MTQgMTMuNzE0IDAgMCAxIDEzLjY4NyAwWk0yMC4wNjMgNDYuMjMxaC00LjgyNWExMC4wMzIgMTAuMDMyIDAgMCAwIDIuOTQ2IDcuMDg2IDEwLjA3IDEwLjA3IDAgMCAwIDcuMSAyLjk0MiAxMC4wNjUgMTAuMDY1IDAgMCAwIDcuMTA4LTIuOTM1IDEwLjAzIDEwLjAzIDAgMCAwIDIuOTQ2LTcuMDkzaC00LjgyNGE1LjIwNyA1LjIwNyAwIDAgMS0xLjUzIDMuNjg4IDUuMjI1IDUuMjI1IDAgMCAxLTMuNjk2IDEuNTI4IDUuMjM0IDUuMjM0IDAgMCAxLTMuNjk1LTEuNTI4IDUuMjEzIDUuMjEzIDAgMCAxLTEuNTMtMy42ODhaTTU0LjMzIDMzLjcxNmExMS43NjMgMTEuNzYzIDAgMCAwLTEyLjc5OSAyLjUzOEExMS42OTcgMTEuNjk3IDAgMCAwIDM4Ljk5IDQ5LjAzYTExLjcyMyAxMS43MjMgMCAwIDAgNC4zMjggNS4yNTkgMTEuNzU3IDExLjc1NyAwIDAgMCA2LjUyNiAxLjk3IDExLjc2NiAxMS43NjYgMCAwIDAgOC4yOS0zLjQzNSAxMS43MiAxMS43MiAwIDAgMCAzLjQ0Mi04LjI3NCAxMS43MDIgMTEuNzAyIDAgMCAwLTEuOTc1LTYuNTE0IDExLjczNiAxMS43MzYgMCAwIDAtNS4yNjktNC4zMlptLTQuNDg4IDMuOTJhNi45MzcgNi45MzcgMCAwIDEgNC45IDIuMDI1IDYuOTEgNi45MSAwIDAgMSAyLjAyOCA0Ljg5MiA2Ljg5NyA2Ljg5NyAwIDAgMS0xLjE3IDMuODM0IDYuOTMyIDYuOTMyIDAgMCAxLTEwLjY0MyAxLjA0MiA2LjkwMiA2LjkwMiAwIDAgMS0xLjUtNy41MjIgNi45MDkgNi45MDkgMCAwIDEgMi41NDQtMy4xIDYuOTI4IDYuOTI4IDAgMCAxIDMuODQxLTEuMTY3Wm0uMTcgNC41NTJhMi40MzEgMi40MzEgMCAwIDAtMi4yNDEgMS4xNTQgMi40MTggMi40MTggMCAwIDAtLjM1NiAxLjI1NyAyLjM5NSAyLjM5NSAwIDAgMCAxLjYxOSAyLjI5djEuNzUzaDEuNjE4di0xLjc1NGEyLjQyNyAyLjQyNyAwIDAgMCAxLjU5NC0xLjk1IDIuNDE4IDIuNDE4IDAgMCAwLTEtMi4zMSAyLjQzMSAyLjQzMSAwIDAgMC0xLjIzNC0uNDRabS0yMC4yMi0yMi41NTJhMTEuNzYyIDExLjc2MiAwIDAgMC0xMi43OTYgMi41MzEgMTEuNjk3IDExLjY5NyAwIDAgMC0yLjU1NCAxMi43NjkgMTEuNzIzIDExLjcyMyAwIDAgMCA0LjMyIDUuMjYyIDExLjc1NyAxMS43NTcgMCAwIDAgMTQuODI1LTEuNDQ2IDExLjcxNyAxMS43MTcgMCAwIDAgMy40NDUtOC4yODQgMTEuNzAzIDExLjcwMyAwIDAgMC0xLjk3NC02LjUxMiAxMS43MzYgMTEuNzM2IDAgMCAwLTUuMjY2LTQuMzJabS00LjUxIDMuOTE3YTYuOTQ1IDYuOTQ1IDAgMCAxIDQuODk3IDIuMDI5IDYuOTE4IDYuOTE4IDAgMCAxIDIuMDMyIDQuODg2IDYuOTA2IDYuOTA2IDAgMCAxLTEuMTY4IDMuODQyIDYuOTQgNi45NCAwIDAgMS0xMC42NiAxLjA0OCA2LjkxMSA2LjkxMSAwIDAgMS0xLjUtNy41MzYgNi45MTggNi45MTggMCAwIDEgMi41NS0zLjEwMyA2LjkzNyA2LjkzNyAwIDAgMSAzLjg1LTEuMTY2Wm0yNC41Ni00LjgxYTEwLjA1OSAxMC4wNTkgMCAwIDAtNy4xMDMgMi45NCAxMC4wMiAxMC4wMiAwIDAgMC0yLjk0IDcuMDkgOS45IDkuOSAwIDAgMCAxLjIzIDQuNzk1IDEzLjU3NSAxMy41NzUgMCAwIDEgNC4yMTQtMi4zMjIgNS4wODIgNS4wODIgMCAwIDEtLjYyNS0yLjQ3NyA1LjIwNiA1LjIwNiAwIDAgMSAxLjUwMy0zLjczNiA1LjIyMyA1LjIyMyAwIDAgMSAzLjcyMi0xLjU1NCA1LjIzNCA1LjIzNCAwIDAgMSAzLjcyIDEuNTU0IDUuMjEzIDUuMjEzIDAgMCAxIDEuNTA1IDMuNzM2IDUuMjc5IDUuMjc5IDAgMCAxLS42MjMgMi40NzMgMTMuNTc0IDEzLjU3NCAwIDAgMSA0LjIxMyAyLjMyMiA5LjkwMyA5LjkwMyAwIDAgMCAxLjIzLTQuNzk1IDEwLjAzMiAxMC4wMzIgMCAwIDAtMi45NDYtNy4wODYgMTAuMDcgMTAuMDcgMCAwIDAtNy4xLTIuOTRabS0yMy43NSA3Ljk5aC0xLjYxN3YxLjc1YTIuNDE5IDIuNDE5IDAgMCAwLTEuNTgyIDIuNjg3IDIuNDE0IDIuNDE0IDAgMCAwIDIuMzkgMi4wMDYgMi40NSAyLjQ1IDAgMCAwIDEuNTU1LS41NzQgMi40MTQgMi40MTQgMCAwIDAtLjc0Ni00LjExOXYtMS43NVoiLz4KICA8L2c+Cjwvc3ZnPgo=";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2;
        if ((_a2 = window.coin98) == null ? void 0 : _a2.sol) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    var _a2;
    return !!((_a2 = this._wallet) == null ? void 0 : _a2.isConnected());
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.coin98.sol;
      let account;
      try {
        account = (await wallet.connect())[0];
      } catch (error) {
        throw new WalletAccountError(error == null ? void 0 : error.message, error);
      }
      let publicKey;
      try {
        publicKey = new PublicKey(account);
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const response = await wallet.request({ method: "sol_sign", params: [transaction] });
        const publicKey = new PublicKey(response.publicKey);
        const signature = esm_default2.decode(response.signature);
        transaction.addSignature(publicKey, Buffer.from(signature));
        return transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const response = await wallet.request({ method: "sol_signAllTransactions", params: [transactions] });
        const publicKey = new PublicKey(response.publicKey);
        const signatures = response.signatures;
        return transactions.map((transaction, index) => {
          const signature = esm_default2.decode(signatures[index]);
          transaction.addSignature(publicKey, Buffer.from(signature));
          return transaction;
        });
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const response = await wallet.request({ method: "sol_signMessage", params: [message] });
        return esm_default2.decode(response.signature);
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-coinbase/lib/esm/adapter.js
init_index_browser_esm();
var CoinbaseWalletName = "Coinbase Wallet";
var CoinbaseWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = CoinbaseWalletName;
    this.url = "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad";
    this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8Y2lyY2xlIGN4PSI1MTIiIGN5PSI1MTIiIHI9IjUxMiIgZmlsbD0iIzAwNTJGRiIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1MiA1MTJDMTUyIDcxMC44MjMgMzEzLjE3NyA4NzIgNTEyIDg3MkM3MTAuODIzIDg3MiA4NzIgNzEwLjgyMyA4NzIgNTEyQzg3MiAzMTMuMTc3IDcxMC44MjMgMTUyIDUxMiAxNTJDMzEzLjE3NyAxNTIgMTUyIDMxMy4xNzcgMTUyIDUxMlpNNDIwIDM5NkM0MDYuNzQ1IDM5NiAzOTYgNDA2Ljc0NSAzOTYgNDIwVjYwNEMzOTYgNjE3LjI1NSA0MDYuNzQ1IDYyOCA0MjAgNjI4SDYwNEM2MTcuMjU1IDYyOCA2MjggNjE3LjI1NSA2MjggNjA0VjQyMEM2MjggNDA2Ljc0NSA2MTcuMjU1IDM5NiA2MDQgMzk2SDQyMFoiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=";
    this.supportedTransactionVersions = /* @__PURE__ */ new Set(["legacy", 0]);
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        if (window == null ? void 0 : window.coinbaseSolana) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.coinbaseSolana;
      try {
        await wallet.connect();
      } catch (error) {
        throw new WalletConnectionError(error == null ? void 0 : error.message, error);
      }
      if (!wallet.publicKey)
        throw new WalletAccountError();
      let publicKey;
      try {
        publicKey = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      wallet.on("disconnect", this._disconnected);
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.off("disconnect", this._disconnected);
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async sendTransaction(transaction, connection, options = {}) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signers, ...sendOptions } = options;
        if (isVersionedTransaction(transaction)) {
          (signers == null ? void 0 : signers.length) && transaction.sign(signers);
        } else {
          transaction = await this.prepareTransaction(transaction, connection, sendOptions);
          (signers == null ? void 0 : signers.length) && transaction.partialSign(...signers);
        }
        sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
        const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);
        return signature;
      } catch (error) {
        if (error instanceof WalletError)
          throw error;
        throw new WalletSendTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signature } = await wallet.signMessage(message);
        return signature;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-coinhub/lib/esm/adapter.js
init_index_browser_esm();
var CoinhubWalletName = "Coinhub";
var CoinhubWalletAdapter = class extends BaseSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = CoinhubWalletName;
    this.url = "https://coinhub.org";
    this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTAwcHgiIGhlaWdodD0iMTAwcHgiIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPHRpdGxlPuefqeW9ojwvdGl0bGU+CiAgICA8ZyBpZD0i6aG16Z2iLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSLkuIvovb3pobVpb3MiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMzguMDAwMDAwLCAtOTQuMDAwMDAwKSI+CiAgICAgICAgICAgIDxnIGlkPSJDb2luaHViLSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM4LjAwMDAwMCwgOTQuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8cmVjdCBpZD0i55+p5b2iIiB4PSIwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgICAgICAgICAgPGcgaWQ9Iue8lue7hCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMy4zMzMzMzMsIDMuMzMzMzMzKSIgZmlsbC1ydWxlPSJub256ZXJvIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNTcuOTU2MzU0Miw0MC43MDQ2MzE2IEM1Ny45NTYzNTQyLDQwLjcwNDYzMTYgNjIuNzc2ODc1LDU2LjM0NTIxMDUgODEuNjE1OTg5Niw1OC41MTY2ODQyIEM4NC43MzEzNTQyLDU4Ljg3NTUyNjMgODguMjYwNTIwOCw1OS4yNjM4NDIxIDkxLjg2ODQzNzUsNTguMTg4MDUyNiBDOTIuMDIyMjkxNyw1OC4xOTc2MzE2IDkyLjE3MjUsNTguMjQwNzM2OCA5Mi4zMDgxMjUsNTguMzE0MDUyNiBDOTIuNDQ0MTE0Niw1OC4zODczNjg0IDkyLjU2Mjk2ODgsNTguNDg5MDUyNiA5Mi42NTY2NjY3LDU4LjYxMjg0MjEgQzkyLjc1LDU4LjczNjYzMTYgOTIuODE1OTg5Niw1OC44Nzk1Nzg5IDkyLjg1MDI2MDQsNTkuMDMxMzY4NCBDOTIuODg0NTMxMyw1OS4xODMxNTc5IDkyLjg4NTYyNSw1OS4zNDA0NzM3IDkyLjg1NDI3MDgsNTkuNDkzIEM5Mi4zMjM4MDIxLDYzLjE1MTc4OTUgOTEuMTIzNTkzNyw2Ni42Nzg2ODQyIDg5LjMxNTI2MDQsNjkuODkzNTI2MyBDODQuNzQxMTk3OSw3OC4xMTE4OTQ3IDc0LjY5NTQ2ODgsODguOTgwNjg0MiA1Mi4wMTE4MjI5LDkyLjgwNiBDNTAuODA5MDYyNSw5Mi44MDYgNDguNDMzMDcyOSw5MS43NDAxNTc5IDQ3LjMyOTExNDYsOTEuOTI5NTI2MyBDNDcuMzI5MTE0Niw5MS45MDkyNjMyIDE5Ljk3MjUzMTIsNjcuNjUyMDUyNiA1Ny45NTYzNTQyLDQwLjcwNDYzMTYgWiIgaWQ9Iui3r+W+hCIgZmlsbD0iI0NGQkZBMyI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik01Mi4wMTE0NTgzLDkyLjgwNiBDNTIuMDExNDU4Myw5Mi44MDYgMzIuMTk2NSw2NC4xNzUyNjMyIDYzLjMwOTE2NjcsNDkuNTExIEw1OS40MzQ3Mzk2LDQ0LjQxMDU3ODkgQzU5LjQzNDczOTYsNDQuNDEwNTc4OSAxOS4xNDQxOTc5LDY1LjE5MTM2ODQgNTIuMDExNDU4Myw5Mi44MDYgWiIgaWQ9Iui3r+W+hCIgZmlsbD0iI0I5QTc5OCI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik05Mi44NTQ2MzU0LDU5LjUzMzE1NzkgQzkyLjIzOTU4MzMsNjMuMzYxMDUyNiA5MC45NDAyMDgzLDY3LjA0Mzc4OTUgODkuMDE5OTQ3OSw3MC40MDE1Nzg5IEw4My4yNjI0NDc5LDU4LjY5NjEwNTMgQzg1LjkzMDEwNDIsNTkuMDU0OTQ3NCA4OC42Mzk2ODc1LDU4LjkxNjQyMTEgOTEuMjU3NzYwNCw1OC4yODc4OTQ3IEM5Mi41MDk3Mzk2LDU3Ljk5OTA1MjYgOTMuMDUxODc1LDU4LjQxNzIxMDUgOTIuODU0NjM1NCw1OS41MzMxNTc5IFoiIGlkPSLot6/lvoQiIGZpbGw9IiM4QzY3NDIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNTkuNzk5Njg3NSw2Ny41MzIzMTU4IEM2Mi4wMTU2MjUsNjcuNTMyMzE1OCA2My44MTE5MjcxLDY1LjcxNzEwNTMgNjMuODExOTI3MSw2My40Nzc4NDIxIEM2My44MTE5MjcxLDYxLjIzODU3ODkgNjIuMDE1NjI1LDU5LjQyMzM2ODQgNTkuNzk5Njg3NSw1OS40MjMzNjg0IEM1Ny41ODM3NSw1OS40MjMzNjg0IDU1Ljc4NzQ0NzksNjEuMjM4NTc4OSA1NS43ODc0NDc5LDYzLjQ3Nzg0MjEgQzU1Ljc4NzQ0NzksNjUuNzE3MTA1MyA1Ny41ODM3NSw2Ny41MzIzMTU4IDU5Ljc5OTY4NzUsNjcuNTMyMzE1OCBaIiBpZD0i6Lev5b6EIiBmaWxsPSIjMjIyMjIyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTYwLjU1OTExNDYsNi44MTQwMjEwNSBMNjMuODkxMDQxNywxLjI3NTEzNDc0IEM1OC4yNzI4MTI1LDIuMjE4NjEzMTYgNTIuNzc3MDgzMywzLjc5NTg0MjExIDQ3LjUwNjY2NjcsNS45NzcxODk0NyBDNDYuMTIzODAyMSw2LjEwODQ5NDc0IDQ0Ljc0ODU5MzcsNi4zMTEzMTA1MyA0My4zODYxNDU4LDYuNTg0ODYzMTYgTDUwLjA2MDIwODMsMy40NjI0NjIyOWUtMTMgQzQzLjQ2MzA3MjksMS42MzEzMDk0NyAzNy40ODkzNzUsNS4xOTM3NDIxMSAzMi44ODcwNTczLDEwLjI0MDkyNjMgQzMyLjIwNjgxNzcsMTAuNTc5NjUyNiAzMS41MzY0NTgzLDEwLjk0ODI1NzkgMzAuOTE1MzkwNiwxMS4zMzY3NTc5IEwzNi4xNTAxMTQ2LDEuNTkzOTI1NzkgQzI5LjA0OTE5NzksNS40NjMyNDIxMSAyMy40ODAzMzMzLDExLjY4MTYzNjggMjAuMzc2OTYzNSwxOS4yMDY3NDc0IEwyMy42MTA0NTMxLDcuODUwMDU3ODkgQzIzLjYxMDQ1MzEsNy44NTAwNTc4OSAxNS40Mzc5ODk2LDE0LjEwNjIxNTggMTMuOTg4ODQzNywyOS41MzczNDc0IEMxMy44MDE1MjA4LDI5LjkxNTkgMTMuNjE0MTk3OSwzMC4yOTQ0NTI2IDEzLjQzNjc1NTIsMzAuNjgyOTUyNiBMMTIuNTQ5NTQxNywxNi44NTU3MDUzIEMxMi41NDk1NDE3LDE2Ljg1NTcwNTMgNC42MDM4MTI1LDI5LjY1Njg2MzIgOS43MTAzNDg5Niw0NC4xMzE2ODQyIEw0LjE2MDE4NzUsMzAuMTg0ODQ3NCBDNC4xNjAxODc1LDMwLjE4NDg0NzQgMC43MTk2NTEwNDIsNDEuMTQzMDUyNiA5LjA4OTI4MTI1LDU1LjM0OSBMLTIuNzYzMjIxNzVlLTE0LDQ0LjcwOTM2ODQgQy0yLjc2MzIyMTc1ZS0xNCw0NC43MDkzNjg0IDAuODc3MzgwNzI5LDYzLjA2OTI2MzIgMTEuMjY3OTU4Myw3My4wMDE1MjYzIEMxMS4yNjc5NTgzLDczLjAwMTUyNjMgMTUuMDA0MjA4Myw3MS44NzYgMTcuMzAxMTkyNyw3NC41NDU1Nzg5IEMyMC45NjAyMjQsNzkuOTIzNDIxMSAyNS44MDI5NDc5LDg0LjM3MSAzMS40NDkxNzcxLDg3LjUzOTQyMTEgQzM3LjA5NTI2MDQsOTAuNzA3NDczNyA0My4zOTE2MTQ2LDkyLjUxMDUyNjMgNDkuODQzMjgxMiw5Mi44MDYgQzUwLjM4NTQxNjcsOTIuODA2IDUxLjQ2OTY4NzUsOTIuODA2IDUxLjQ2OTY4NzUsOTIuODA2IEM1MS40Njk2ODc1LDkyLjgwNiAzMi4xODcwOTM3LDc1Ljk4MDIxMDUgNTAuNzY5Njg3NSw1MS45NjE3MzY4IEM2OS4zNjIzNDM3LDI5Ljg1NjEwNTMgOTMuMzg2OTI3MSw0NS4yMjczNjg0IDkzLjE2MDE1NjIsNDMuMjQ0ODk0NyBDOTIuMDM3NjA0MiwzNC41NDI2Nzg5IDg4LjMxNTU3MjksMjYuMzkzMjA1MyA4Mi40OTA2MjUsMTkuODgzOTc4OSBDNzYuNjY1Njc3MSwxMy4zNzQ3NTI2IDY5LjAxNDg5NTgsOC44MTUzMjEwNSA2MC41NTkxMTQ2LDYuODE0MDIxMDUgTDYwLjU1OTExNDYsNi44MTQwMjEwNSBaIiBpZD0i6Lev5b6EIiBmaWxsPSIjMjJBMDc5Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTQzLjM0NjQwNjMsNzguNTgwMTU3OSBDNDMuMzQ2NDA2Myw3OC41ODAxNTc5IDIyLjA2MjQzMjMsODYuMDgxNTc4OSAyLjI4NjgzNDM4LDU3LjAzMjMxNTggQzQuNDA4MTc3MDgsNjQuNjU0MjEwNSA4LjIwNjE1MTA0LDcxLjY5MzI2MzIgMTMuMzk3MDUyMSw3Ny42MjM3MzY4IEMyMC42MjMxMzAyLDg2LjAyMTg5NDcgMzQuOTc2NzM5Niw5My4zMTQwNTI2IDUyLjAxMTgyMjksOTIuNzg2MTA1MyBDNDkuOTUzNzUsOTEuMTc5NDIxMSA0OC4yMzcyOTE3LDg5LjE3MDQyMTEgNDYuOTY0MTY2Nyw4Ni44Nzg0NzM3IEM0NS40OTM4MDIxLDg0LjIzOCA0NC4yODE5MjcxLDgxLjQ1OSA0My4zNDY0MDYzLDc4LjU4MDE1NzkgTDQzLjM0NjQwNjMsNzguNTgwMTU3OSBaIiBpZD0i6Lev5b6EIiBmaWxsPSIjMUI4MDYxIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2;
        if ((_a2 = window.coinhub) == null ? void 0 : _a2.isCoinhubWallet) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.coinhub;
      let account;
      try {
        account = await wallet.getAccount();
      } catch (error) {
        throw new WalletAccountError(error == null ? void 0 : error.message, error);
      }
      let publicKey;
      try {
        publicKey = new PublicKey(account);
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    if (this._wallet) {
      this._wallet = null;
      this._publicKey = null;
    }
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction);
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions);
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-fractal/lib/esm/adapter.js
init_index_browser_esm();
var FractalWalletName = "Fractal";
var FractalWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = FractalWalletName;
    this.url = "https://developers.fractal.is/wallet-adapters/solana";
    this.icon = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAwIDEwMDAiPjxwYXRoIGQ9Ik0zNDIuMjQgNzYzLjkzVjI0My44Mkg3MTV2MTEyLjY5SDQ4MXYxMTUuNThoMTgydjExMi42OUg0ODF2MTc5LjE1WiIgc3R5bGU9ImZpbGw6I2RlMzU5YyIvPjwvc3ZnPg==";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Loadable)
        throw new WalletNotReadyError();
      this._connecting = true;
      let FractalWalletClass;
      try {
        FractalWalletClass = (await import("./esm-X5VXUOMB.js")).FractalWalletAdapterImpl;
      } catch (error) {
        throw new WalletLoadError(error == null ? void 0 : error.message, error);
      }
      let wallet;
      try {
        wallet = new FractalWalletClass();
      } catch (error) {
        throw new WalletConfigError(error == null ? void 0 : error.message, error);
      }
      const account = wallet.getPublicKey();
      if (!account) {
        try {
          await wallet.connect();
        } catch (error) {
          throw new WalletConnectionError(error == null ? void 0 : error.message, error);
        }
      }
      let publicKey;
      try {
        publicKey = new PublicKey(wallet.getPublicKey().toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return wallet.signTransaction(transaction);
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return wallet.signAllTransactions(transactions);
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return wallet.signMessage(message);
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-huobi/lib/esm/adapter.js
init_index_browser_esm();
var HuobiWalletName = "HuobiWallet";
var HuobiWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = HuobiWalletName;
    this.url = "https://www.huobiwallet.io";
    this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjI0IiBoZWlnaHQ9IjIyNCIgdmlld0JveD0iMCAwIDIyNCAyMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMCAwTDIyNCAwVjIyNEgwTDAgMFoiIGZpbGw9IiMyMTU3RTIiLz4KPHBhdGggZD0iTTEzMS4wNTkgODEuMTc3MUMxMzEuMDU5IDU3Ljc1MzEgMTE5LjQ1OCAzNy42MzE1IDExMC42MjUgMzEuMDcyOEMxMTAuNjI1IDMxLjA3MjggMTA5Ljk1MyAzMC43MDQyIDExMCAzMS42MjU4VjMxLjYyNThDMTA5LjI2NSA3Ni44MzAzIDg1Ljc2NzIgODkuMDg3NSA3Mi44MzggMTA1LjU4NEM0My4wMjQxIDE0My42NzcgNzAuNzU4NyAxODUuNDU2IDk4Ljk5MzUgMTkzLjEzNkMxMTQuNzk5IDE5Ny40NTIgOTUuMzUwOCAxODUuNDU2IDkyLjg0OTQgMTYwLjIzNUM4OS44MDA3IDEyOS43NDUgMTMxLjA1OSAxMDYuNDQ0IDEzMS4wNTkgODEuMTc3MVoiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8xMTAxXzEyNSkiLz4KPHBhdGggZD0iTTE0My41OTcgOTYuMzE3NEMxNDMuNDA5IDk2LjE5NDMgMTQzLjE1OCA5Ni4xMDIgMTQyLjk4NiA5Ni4zOTQzQzE0Mi40ODQgMTAyLjEwMiAxMzYuNTYgMTE0LjI4NiAxMjkuMDM3IDEyNS40ODZDMTAzLjU1MiAxNjMuNDU1IDExOC4wNjUgMTgxLjc2MiAxMjYuMjQ3IDE5MS42MzlDMTMwLjk0OSAxOTcuMzQ3IDEyNi4yNDcgMTkxLjYzOSAxMzguMDk2IDE4NS44MDhDMTUyLjczNSAxNzcuMDkyIDE2Mi4yMzQgMTYyLjAyIDE2My42NDMgMTQ1LjI3QzE2NS4yMzMgMTI2Ljc1OCAxNTcuNzk4IDEwOC42IDE0My41OTcgOTYuMzE3NFoiIGZpbGw9InVybCgjcGFpbnQxX2xpbmVhcl8xMTAxXzEyNSkiLz4KPGRlZnM+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl8xMTAxXzEyNSIgeDE9IjEyMi40MDEiIHkxPSIyMDkuMjk1IiB4Mj0iMTc4LjY2MiIgeTI9IjExMC40NDciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y3RjZGRiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IndoaXRlIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQxX2xpbmVhcl8xMTAxXzEyNSIgeDE9IjE1Ny44NjEiIHkxPSIyMDMuMTc3IiB4Mj0iMTg5LjAxNCIgeTI9IjE0MC4wMjIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y3RjZGRiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IndoaXRlIi8+CjwvbGluZWFyR3JhZGllbnQ+CjwvZGVmcz4KPC9zdmc+Cg==";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2;
        if ((_a2 = window.huobiWallet) == null ? void 0 : _a2.isHuobiWallet) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    var _a2;
    return !!((_a2 = this._wallet) == null ? void 0 : _a2.isConnected);
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.huobiWallet;
      try {
        await wallet.connect();
      } catch (error) {
        throw new WalletConnectionError(error == null ? void 0 : error.message, error);
      }
      if (!wallet.publicKey)
        throw new WalletAccountError();
      let publicKey;
      try {
        publicKey = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      wallet.on("disconnect", this._disconnected);
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.off("disconnect", this._disconnected);
      this._wallet = null;
      this._publicKey = null;
      this.emit("disconnect");
    }
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signature } = await wallet.signMessage(message);
        return signature;
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-hyperpay/lib/esm/adapter.js
init_index_browser_esm();
var HyperPayWalletName = "HyperPay";
var HyperPayWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = HyperPayWalletName;
    this.url = "https://hyperpay.io";
    this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNTIwcHgiIGhlaWdodD0iNTIwcHgiIHZpZXdCb3g9IjAgMCA1MjAgNTIwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPHRpdGxlPkh5cGVyUGF5PC90aXRsZT4KICAgIDxnIGlkPSLpobXpnaItMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9Iue8lue7hC0zMyIgZmlsbD0iIzFBNzJGRSIgZmlsbC1ydWxlPSJub256ZXJvIj4KICAgICAgICAgICAgPHBhdGggZD0iTTI2MCwwIEM0MDMuNTIsMCA1MjAsMTE1Ljk0MTI1NSA1MjAsMjU5LjY1Mjg3IEM1MjAsNDAzLjM2NDQ4NiA0MDMuNTIsNTIwIDI2MCw1MjAgQzExNi40OCw1MjAgMCw0MDQuMDU4NzQ1IDAsMjYwLjM0NzEzIEMwLDExNi42MzU1MTQgMTE2LjQ4LDAgMjYwLDAgWiBNMTIzLjQ2Mzk4NSwxMjIuNjQ3NzM3IEwxMjMuNDEzMzMzLDEyMi42NDc1MyBMMTA2LjA4LDE4My42MjQ4MzMgTDIyMS44NjY2NjcsMTgzLjYyNDgzMyBMMjA4LDI0OC43NTk2OCBMMjc5LjQxMzMzMywyNDguNzU5NjggTDI3OS40MTMzMzMsMjQ4Ljc1OTY4IEwyNzkuNDEzODUzLDI0OC43MDU5NzggQzI3OS40MjM3MzMsMjQ4LjAxNDc4NiAyNzkuNjIxMzMzLDI0MC40NDQ1OTMgMjgzLjU3MzMzMywyMTQuMTEzNDg1IEMyODkuODEzMzMzLDE3MC40NTkyNzkgMzY1LjM4NjY2NywxNjcuNjg3NTgzIDM2NC42OTMzMzMsMjE2Ljg4NTE4IEMzNjQsMjUyLjkxNzIyMyAzMzYuMjY2NjY3LDI1Ny4wNzQ3NjYgMzE4LjI0LDI1Ny43Njc2OSBDMzEyLjQ3MTQ2NywyNTcuOTg5NDI2IDI4Ni4xODQ3MDQsMjU4LjA2OTI1MSAyNTMuMTAyMDc3LDI1OC4wNzUyODIgTDI0My42Mjk3MDcsMjU4LjA3NTA4OSBDMTc0LjA4NzMzMywyNTguMDYwNDUxIDgxLjgxMzMzMzMsMjU3Ljc2NzY5IDgxLjgxMzMzMzMsMjU3Ljc2NzY5IEw4MS44MTMzMzMzLDI1Ny43Njc2OSBMNjEuNzA2NjY2NywzMTguMDUyMDY5IEwxODcuMiwzMTguMDUyMDY5IEwxNjguNDgsMzkxLjUwMjAwMyBMMjQ4LjkwNjY2NywzOTEuNTAyMDAzIEwyNjguMzIsMzE2LjY2NjIyMiBDMjY4LjMyLDMxNi42NjYyMjIgMjgzLjc5NTIsMzE2LjQxNjc2OSAyOTkuOTE5MzYsMzE2LjIxNzIwNyBMMzAyLjM0MDk5OCwzMTYuMTg3Njg0IEMzMTIuMzAxMzkyLDMxNi4wNjgxNTkgMzIyLjIyNjY2NywzMTUuOTczMjk4IDMyOC42NCwzMTUuOTczMjk4IEMzNTkuODQsMzE1Ljk3MzI5OCA0NDIuMzQ2NjY3LDI5NS44Nzg1MDUgNDQyLjM0NjY2NywyMDkuOTU1OTQxIEM0NDIuMzQ2NjY3LDEzMS42NTU1NDEgMzU3LjA2NjY2NywxMjMuMzQwNDU0IDMyNS4xNzMzMzMsMTIzLjM0MDQ1NCBDMjkzLjI4LDEyMy4zNDA0NTQgMTIzLjQxMzMzMywxMjIuNjQ3NTMgMTIzLjQxMzMzMywxMjIuNjQ3NTMgWiIgaWQ9IuW9oueKtue7k+WQiCI+PC9wYXRoPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2, _b;
        if ((_b = (_a2 = window.hyperPay) == null ? void 0 : _a2.solana) == null ? void 0 : _b.isHyperPay) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    var _a2;
    return !!((_a2 = this._wallet) == null ? void 0 : _a2.isConnected);
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.hyperPay.solana;
      try {
        await wallet.connect();
      } catch (error) {
        throw new WalletConnectionError(error == null ? void 0 : error.message, error);
      }
      if (!wallet.publicKey)
        throw new WalletAccountError();
      let publicKey;
      try {
        publicKey = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      wallet.on("disconnect", this._disconnected);
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.off("disconnect", this._disconnected);
      this._wallet = null;
      this._publicKey = null;
      this.emit("disconnect");
    }
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signature } = await wallet.signMessage(message);
        return signature;
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-keystone/lib/esm/adapter.js
init_index_browser_esm();

// node_modules/@solana/wallet-adapter-keystone/lib/esm/polyfills/Buffer.js
var import_buffer2 = __toESM(require_buffer(), 1);
if (typeof window !== "undefined" && window.Buffer === void 0) {
  window.Buffer = import_buffer2.Buffer;
}

// node_modules/@solana/wallet-adapter-keystone/lib/esm/adapter.js
var KeystoneWalletName = "Keystone";
var KeystoneWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get readyState() {
    return this._readyState;
  }
  constructor(config = {}) {
    super();
    this.name = KeystoneWalletName;
    this.url = "https://keyst.one";
    this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxjaXJjbGUgY3g9IjE2IiBjeT0iMTYiIHI9IjE2IiBmaWxsPSJ3aGl0ZSIvPgogICAgPHJlY3QgeD0iNSIgeT0iNSIgd2lkdGg9IjIyIiBoZWlnaHQ9IjIyIiBmaWxsPSJ3aGl0ZSIgZmlsbC1vcGFjaXR5PSIxIi8+CiAgICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0LjY5NjUgNS40MzQ4N0MxNS4wOTEgNC43NTMxNiAxNi4wNzQ5IDQuNzUyMTEgMTYuNDcwOCA1LjQzMjk5TDE3LjMzOTggNi45MjcxOUMxNy42NDkgNy40NTg5NiAxNy42NDg3IDguMTE1ODggMTcuMzM4OSA4LjY0NzM0TDkuNjMxMjEgMjEuODcxQzkuMjE4NTEgMjIuNTc5MSA4LjE5NjIzIDIyLjU4MTEgNy43ODA3NiAyMS44NzQ2QzcuNzMxMzIgMjEuNzkwNiA3LjY5MzU4IDIxLjcwMDEgNy42Njg1OCAyMS42MDU4TDcuMzcwODggMjAuNDgyOUM3LjA5MjY2IDE5LjQzMzQgNy4yNDE4IDE4LjMxNjQgNy43ODU2MyAxNy4zNzY3TDE0LjY5NjUgNS40MzQ4N1pNMTIuNjYzNiAxOS4yODU4QzEzLjA2MzUgMTguNTk5NyAxNC4wMDM1IDE4LjQ3NTcgMTQuNTY3NyAxOS4wMzQ1TDE3LjQyODggMjEuODY4NkMxOC44NjA1IDIzLjI4NjcgMTguODU2NSAyNS42MDE2IDE3LjQyIDI3LjAxNDlDMTcuMjA0NSAyNy4yMjY5IDE2Ljg3OTggMjcuMjgyNSAxNi42MDYgMjcuMTU0MkwxMS42MDAyIDI0LjgwODFDMTAuNjkwNyAyNC4zODE5IDEwLjM0MyAyMy4yNjcxIDEwLjg0ODcgMjIuMzk5NEwxMi42NjM2IDE5LjI4NThaTTIwLjQzNSAxNi4zMzcyQzIxLjQ4OTcgMTYuMzM3MiAyMi4xNDc0IDE1LjE5MzkgMjEuNjE3MiAxNC4yODIyTDE5Ljc4MjggMTEuMTI4QzE5LjI1NTggMTAuMjIxOCAxNy45NDcxIDEwLjIyMTIgMTcuNDE5MiAxMS4xMjY5TDE1LjQzMDkgMTQuNTM4MUMxNC45NjYgMTUuMzM1OCAxNS41NDE0IDE2LjMzNzIgMTYuNDY0NyAxNi4zMzcyTDIwLjQzNSAxNi4zMzcyWiIgZmlsbD0iYmxhY2siLz4KICAgIDxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMjEuNzMwMyAxNy42NDU5QzIyLjg3MTMgMTcuNjQ1OSAyMy45MjYxIDE4LjI1MjcgMjQuNDk5OCAxOS4yMzlWMTkuMjM5QzI0LjY3NjMgMTkuNTQyNyAyNC42MjQ3IDE5LjkyNzQgMjQuMzc0MyAyMC4xNzM3TDIyLjA1MTEgMjIuNDU5QzIxLjQ1MDkgMjMuMDQ5NCAyMC40ODc3IDIzLjA0NzggMTkuODg5NSAyMi40NTUzTDE2LjUxMDEgMTkuMTA3OEMxNS45Njc3IDE4LjU3MDYgMTYuMzQ4MSAxNy42NDU5IDE3LjExMTYgMTcuNjQ1OUwyMS43MzAzIDE3LjY0NTlaIiBmaWxsPSIjMjE2MUZGIi8+Cjwvc3ZnPgo=";
    this.supportedTransactionVersions = /* @__PURE__ */ new Set(["legacy", 0]);
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
    this._keyring = null;
    this._publicKey = null;
    this._connecting = false;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Loadable)
        throw new WalletNotReadyError();
      this._connecting = true;
      let keyring;
      try {
        const { DefaultKeyring } = await import("./dist-TOO5CYIC.js");
        keyring = DefaultKeyring.getEmptyKeyring();
      } catch (error) {
        throw new WalletLoadError(error == null ? void 0 : error.message, error);
      }
      let account;
      try {
        await keyring.readKeyring();
        account = keyring.getAccounts()[0].pubKey;
      } catch (error) {
        throw new WalletAccountError(error == null ? void 0 : error.message, error);
      }
      let publicKey;
      try {
        publicKey = new PublicKey(account);
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      this._keyring = keyring;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    if (this._keyring) {
      this._keyring = null;
      this._publicKey = null;
    }
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    try {
      const keyring = this._keyring;
      const publicKey = this._publicKey;
      if (!keyring || !publicKey)
        throw new WalletNotConnectedError();
      try {
        if (isVersionedTransaction(transaction)) {
          const txHex = transaction.serialize();
          const signature = await keyring.signTransaction(publicKey.toString(), txHex);
          transaction.addSignature(publicKey, signature);
        } else {
          const txHex = transaction.serializeMessage();
          const signature = await keyring.signTransaction(publicKey.toString(), txHex);
          transaction.addSignature(publicKey, Buffer.from(signature));
        }
        return transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    var _a2;
    try {
      const keyring = this._keyring;
      const publicKey = (_a2 = this._publicKey) == null ? void 0 : _a2.toString();
      if (!keyring || !publicKey)
        throw new WalletNotConnectedError();
      try {
        return keyring.signMessage(publicKey, message);
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-krystal/lib/esm/adapter.js
init_index_browser_esm();
var KrystalWalletName = "Krystal";
var KrystalWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = KrystalWalletName;
    this.url = "https://krystal.app";
    this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiBmaWxsPSIjMDEwMTAxIi8+CjxyZWN0IHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiByeD0iMTAwIiBmaWxsPSIjMDEwMTAxIi8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMjkxLjg4NyA4MC44NDA3QzI5MS44ODcgNzUuMDgyNiAyOTcuNTg1IDcxLjA1NzYgMzAzLjAxMiA3Mi45ODJMMzc3LjYxOCA5OS40Mzc2QzM4My4wMyAxMDEuMzU3IDM4NC45MjggMTA4LjA0MyAzODEuMzMxIDExMi41MTlMMzA2LjcyNSAyMDUuMzcyQzMwMS43OTQgMjExLjUxIDI5MS44ODcgMjA4LjAyMyAyOTEuODg3IDIwMC4xNVY4MC44NDA3Wk0xNTIuMzUzIDE3Mi4zM0MxNDYuMjg1IDE3NS44NDYgMTQ3LjAwNiAxODQuODI4IDE1My41NTcgMTg3LjMzM0wyNjYuMTEyIDIzMC4zNTNDMjcxLjU3MSAyMzIuNDQgMjc3LjQyNyAyMjguNDA5IDI3Ny40MjcgMjIyLjU2NVYxMTQuMzE5QzI3Ny40MjcgMTA3Ljg5NSAyNzAuNDY3IDEwMy44ODQgMjY0LjkwOCAxMDcuMTA1TDE1Mi4zNTMgMTcyLjMzWk03Mi41MjcyIDI5MC40NzJDNzIuMDY0MSAyOTYuMTg5IDc3LjM3NzUgMzAwLjY1NSA4Mi45Mjk3IDI5OS4yMTdMMjQ5LjkwNyAyNTUuOTQ1QzI1Ny43NjkgMjUzLjkwOCAyNTguMzc1IDI0Mi45NzcgMjUwLjc4NyAyNDAuMDgzTDkyLjIxMiAxNzkuNjEzQzg3LjAxOTEgMTc3LjYzMyA4MS4zNzg5IDE4MS4xOTEgODAuOTMwMiAxODYuNzNMNzIuNTI3MiAyOTAuNDcyWk0yNDkuOTA4IDI4Ni45M0MyNTIuMTQ2IDI4MC42MjcgMjQ2LjQyNCAyNzQuMzg3IDIzOS45NSAyNzYuMDcyTDEyNy42NDkgMzA1LjMwMkMxMjEuMzU3IDMwNi45MzkgMTE5LjI3NyAzMTQuODI5IDEyMy45NDQgMzE5LjM1NkwxOTkuNzYgMzkyLjkwNEMyMDQuMTE5IDM5Ny4xMzIgMjExLjM5MiAzOTUuNDMyIDIxMy40MjQgMzg5LjcwOEwyNDkuOTA4IDI4Ni45M1pNMzExLjk0MyAyNDQuMTQ3QzMwNS44MzEgMjQyLjg5NiAzMDMuMjA4IDIzNS42MjMgMzA3LjExNCAyMzAuNzU4TDM4NS43MDMgMTMyLjg4MkMzOTAuMTMyIDEyNy4zNjUgMzk4Ljk4NyAxMjkuNTI1IDQwMC4zNzkgMTM2LjQ2MUw0MjQuMjI5IDI1NS4zMTJDNDI1LjQwMyAyNjEuMTY0IDQyMC4yMjggMjY2LjMxOCA0MTQuMzgxIDI2NS4xMjFMMzExLjk0MyAyNDQuMTQ3Wk0zMjEuMjA0IDI2NC4wNjhDMzEzLjI5MSAyNjIuNDQyIDMwNy45MjEgMjcxLjg5MiAzMTMuMzY4IDI3Ny44NThMNDE1Ljc3OSAzOTAuMDMxQzQyMC41NDMgMzk1LjI0OSA0MjkuMjMxIDM5Mi41NDggNDMwLjE5NyAzODUuNTQ5TDQ0Mi40MjIgMjk2LjkzMkM0NDMuMDIyIDI5Mi41OCA0NDAuMTQzIDI4OC41MDkgNDM1Ljg0IDI4Ny42MjVMMzIxLjIwNCAyNjQuMDY4Wk0yNzYuMjQ3IDMwMi44MDhDMjc2LjA3NSAyOTMuNTM3IDI2My4xNzEgMjkxLjQyOCAyNjAuMDU2IDMwMC4xNjFMMjE1LjA1MiA0MjYuMzYyQzIxMi44NzUgNDMyLjQ2NSAyMTguMTg4IDQzOC42MTEgMjI0LjU0MyA0MzcuMzM4TDI3MS43MDcgNDI3Ljg5M0MyNzUuNjYgNDI3LjEwMiAyNzguNDgxIDQyMy41OTUgMjc4LjQwNiA0MTkuNTYzTDI3Ni4yNDcgMzAyLjgwOFpNMjkyLjI5NiAzMDQuMDM2QzI5Mi4xNTMgMjk2LjM2OSAzMDEuNTYzIDI5Mi41OTEgMzA2Ljc2MiAyOTguMjI4TDM4MS43NjUgMzc5LjU2QzM4Ni4yMTggMzg0LjM4OCAzODMuNTk5IDM5Mi4yMyAzNzcuMTM5IDM5My40MTRMMzAzLjkgNDA2LjgzM0MyOTguODQxIDQwNy43NiAyOTQuMTU3IDQwMy45MyAyOTQuMDYxIDM5OC43ODdMMjkyLjI5NiAzMDQuMDM2WiIgZmlsbD0iIzFERTlCNiIvPgo8L3N2Zz4K";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2;
        if ((_a2 = window.krystal) == null ? void 0 : _a2.solana) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    var _a2;
    return !!((_a2 = this._wallet) == null ? void 0 : _a2.isConnected());
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.krystal.solana;
      let account;
      try {
        account = (await wallet.connect())[0];
      } catch (error) {
        throw new WalletAccountError(error == null ? void 0 : error.message, error);
      }
      let publicKey;
      try {
        publicKey = new PublicKey(account);
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction);
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions);
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signature } = await wallet.signMessage(message);
        return signature;
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-ledger/lib/esm/polyfills/Buffer.js
var import_buffer3 = __toESM(require_buffer(), 1);
if (typeof window !== "undefined" && window.Buffer === void 0) {
  window.Buffer = import_buffer3.Buffer;
}

// node_modules/@solana/wallet-adapter-ledger/lib/esm/util.js
init_index_browser_esm();
function getDerivationPath(account, change) {
  const length = account !== void 0 ? change === void 0 ? 3 : 4 : 2;
  const derivationPath = Buffer.alloc(1 + length * 4);
  let offset = derivationPath.writeUInt8(length, 0);
  offset = derivationPath.writeUInt32BE(harden(44), offset);
  offset = derivationPath.writeUInt32BE(harden(501), offset);
  if (account !== void 0) {
    offset = derivationPath.writeUInt32BE(harden(account), offset);
    if (change !== void 0) {
      derivationPath.writeUInt32BE(harden(change), offset);
    }
  }
  return derivationPath;
}
var BIP32_HARDENED_BIT = 1 << 31 >>> 0;
function harden(n3) {
  return (n3 | BIP32_HARDENED_BIT) >>> 0;
}
var INS_GET_PUBKEY = 5;
var INS_SIGN_MESSAGE = 6;
var P1_NON_CONFIRM = 0;
var P1_CONFIRM = 1;
var P2_EXTEND = 1;
var P2_MORE = 2;
var MAX_PAYLOAD = 255;
var LEDGER_CLA = 224;
async function getPublicKey(transport, derivationPath) {
  const bytes = await send(transport, INS_GET_PUBKEY, P1_NON_CONFIRM, derivationPath);
  return new PublicKey(bytes);
}
async function signTransaction(transport, transaction, derivationPath) {
  const paths = Buffer.alloc(1);
  paths.writeUInt8(1, 0);
  const message = isVersionedTransaction(transaction) ? transaction.message.serialize() : transaction.serializeMessage();
  const data = Buffer.concat([paths, derivationPath, message]);
  return await send(transport, INS_SIGN_MESSAGE, P1_CONFIRM, data);
}
async function send(transport, instruction, p1, data) {
  let p22 = 0;
  let offset = 0;
  if (data.length > MAX_PAYLOAD) {
    while (data.length - offset > MAX_PAYLOAD) {
      const buffer2 = data.slice(offset, offset + MAX_PAYLOAD);
      const response2 = await transport.send(LEDGER_CLA, instruction, p1, p22 | P2_MORE, buffer2);
      if (response2.length !== 2)
        throw new TransportStatusError(StatusCodes.INCORRECT_DATA);
      p22 |= P2_EXTEND;
      offset += MAX_PAYLOAD;
    }
  }
  const buffer = data.slice(offset);
  const response = await transport.send(LEDGER_CLA, instruction, p1, p22, buffer);
  return response.slice(0, response.length - 2);
}

// node_modules/@solana/wallet-adapter-ledger/lib/esm/adapter.js
var LedgerWalletName = "Ledger";
var LedgerWalletAdapter = class extends BaseSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = LedgerWalletName;
    this.url = "https://ledger.com";
    this.icon = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMzUgMzUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI2ZmZiI+PHBhdGggZD0ibTIzLjU4OCAwaC0xNnYyMS41ODNoMjEuNnYtMTZhNS41ODUgNS41ODUgMCAwIDAgLTUuNi01LjU4M3oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUuNzM5KSIvPjxwYXRoIGQ9Im04LjM0MiAwaC0yLjc1N2E1LjU4NSA1LjU4NSAwIDAgMCAtNS41ODUgNS41ODV2Mi43NTdoOC4zNDJ6Ii8+PHBhdGggZD0ibTAgNy41OWg4LjM0MnY4LjM0MmgtOC4zNDJ6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDUuNzM5KSIvPjxwYXRoIGQ9Im0xNS4xOCAyMy40NTFoMi43NTdhNS41ODUgNS41ODUgMCAwIDAgNS41ODUtNS42di0yLjY3MWgtOC4zNDJ6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMS40NzggMTEuNDc4KSIvPjxwYXRoIGQ9Im03LjU5IDE1LjE4aDguMzQydjguMzQyaC04LjM0MnoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUuNzM5IDExLjQ3OCkiLz48cGF0aCBkPSJtMCAxNS4xOHYyLjc1N2E1LjU4NSA1LjU4NSAwIDAgMCA1LjU4NSA1LjU4NWgyLjc1N3YtOC4zNDJ6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDExLjQ3OCkiLz48L2c+PC9zdmc+";
    this.supportedTransactionVersions = /* @__PURE__ */ new Set(["legacy", 0]);
    this._readyState = typeof window === "undefined" || typeof document === "undefined" || typeof navigator === "undefined" || !navigator.hid ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
    this._disconnected = () => {
      const transport = this._transport;
      if (transport) {
        transport.off("disconnect", this._disconnected);
        this._transport = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._derivationPath = config.derivationPath || getDerivationPath(0, 0);
    this._connecting = false;
    this._transport = null;
    this._publicKey = null;
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Loadable)
        throw new WalletNotReadyError();
      this._connecting = true;
      let TransportWebHIDClass;
      try {
        TransportWebHIDClass = (await import("./TransportWebHID-ERGOGLGP.js")).default;
      } catch (error) {
        throw new WalletLoadError(error == null ? void 0 : error.message, error);
      }
      let transport;
      try {
        transport = await TransportWebHIDClass.create();
      } catch (error) {
        throw new WalletConnectionError(error == null ? void 0 : error.message, error);
      }
      let publicKey;
      try {
        publicKey = await getPublicKey(transport, this._derivationPath);
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      transport.on("disconnect", this._disconnected);
      this._transport = transport;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const transport = this._transport;
    if (transport) {
      transport.off("disconnect", this._disconnected);
      this._transport = null;
      this._publicKey = null;
      try {
        await transport.close();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    try {
      const transport = this._transport;
      const publicKey = this._publicKey;
      if (!transport || !publicKey)
        throw new WalletNotConnectedError();
      try {
        const signature = await signTransaction(transport, transaction, this._derivationPath);
        transaction.addSignature(publicKey, signature);
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
      return transaction;
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-mathwallet/lib/esm/adapter.js
init_index_browser_esm();
var MathWalletName = "MathWallet";
var MathWalletAdapter = class extends BaseSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = MathWalletName;
    this.url = "https://mathwallet.org";
    this.icon = "data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIHdpZHRoPSIxMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI2ZmZiIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJtMCAwaDEyOHYxMjhoLTEyOHoiIG9wYWNpdHk9IjAiLz48cGF0aCBkPSJtOTAuODQ3MDA4NiA1Ny43NjEwMDIzYy0yLjI3NzAzNjMtMi4yNzcwMzYzLTIuMjc3MDM2My01Ljk2ODg0MTYgMC04LjI0NTg3NzggMi4yNzcwMzYyLTIuMjc3MDM2MyA1Ljk2ODg0MTUtMi4yNzcwMzYzIDguMjQ1ODc3OCAwIDIuMjc3MDM2NiAyLjI3NzAzNjIgMi4yNzcwMzY2IDUuOTY4ODQxNSAwIDguMjQ1ODc3OC0yLjI3NzAzNjMgMi4yNzcwMzYyLTUuOTY4ODQxNiAyLjI3NzAzNjItOC4yNDU4Nzc4IDB6bS0xOS41ODM5NTk4IDE5LjU4Mzk1OTdjLTEuNzA3Nzc3Mi0xLjcwNzc3NzItMS43MDc3NzcyLTQuNDc2NjMxMSAwLTYuMTg0NDA4M3M0LjQ3NjYzMTEtMS43MDc3NzcyIDYuMTg0NDA4MyAwIDEuNzA3Nzc3MiA0LjQ3NjYzMTEgMCA2LjE4NDQwODMtNC40NzY2MzExIDEuNzA3Nzc3Mi02LjE4NDQwODMgMHptMzAuOTIyMDQyMi0xMC4zMDczNDcyYy0xLjcwNzc3OC0xLjcwNzc3NzItMS43MDc3NzgtNC40NzY2MzEyIDAtNi4xODQ0MDg0IDEuNzA3Nzc3LTEuNzA3Nzc3MiA0LjQ3NjYzMS0xLjcwNzc3NzIgNi4xODQ0MDggMHMxLjcwNzc3NyA0LjQ3NjYzMTIgMCA2LjE4NDQwODQtNC40NzY2MzEgMS43MDc3NzcyLTYuMTg0NDA4IDB6bS0xMC4zMDczNDc3IDEwLjMwNzM0NzJjLTEuNzA3Nzc3Mi0xLjcwNzc3NzItMS43MDc3NzcyLTQuNDc2NjMxMSAwLTYuMTg0NDA4M3M0LjQ3NjYzMTEtMS43MDc3NzcyIDYuMTg0NDA4MyAwIDEuNzA3Nzc3MiA0LjQ3NjYzMTEgMCA2LjE4NDQwODMtNC40NzY2MzExIDEuNzA3Nzc3Mi02LjE4NDQwODMgMHptMjEuNjQ1NDI4Ny0xLjAzMDczNDdjLTEuMTM4NTE4LTEuMTM4NTE4MS0xLjEzODUxOC0yLjk4NDQyMDggMC00LjEyMjkzODkgMS4xMzg1MTktMS4xMzg1MTgxIDIuOTg0NDIxLTEuMTM4NTE4MSA0LjEyMjkzOSAwIDEuMTM4NTE5IDEuMTM4NTE4MSAxLjEzODUxOSAyLjk4NDQyMDggMCA0LjEyMjkzODktMS4xMzg1MTggMS4xMzg1MTgxLTIuOTg0NDIgMS4xMzg1MTgxLTQuMTIyOTM5IDB6bS0xMC4zMDczNDcgMTAuMzA3MzQ3MmMtMS4xMzg1MTgtMS4xMzg1MTgxLTEuMTM4NTE4LTIuOTg0NDIwNyAwLTQuMTIyOTM4OSAxLjEzODUxOC0xLjEzODUxODEgMi45ODQ0MjEtMS4xMzg1MTgxIDQuMTIyOTM5IDAgMS4xMzg1MTggMS4xMzg1MTgyIDEuMTM4NTE4IDIuOTg0NDIwOCAwIDQuMTIyOTM4OS0xLjEzODUxOCAxLjEzODUxODItMi45ODQ0MjEgMS4xMzg1MTgyLTQuMTIyOTM5IDB6bS0yMi42NzYxNjM3LTE4LjU1MzIyNWMtMi4yNzcwMzYzLTIuMjc3MDM2My0yLjI3NzAzNjMtNS45Njg4NDE1IDAtOC4yNDU4Nzc4czUuOTY4ODQxNS0yLjI3NzAzNjMgOC4yNDU4Nzc4IDAgMi4yNzcwMzYzIDUuOTY4ODQxNSAwIDguMjQ1ODc3OC01Ljk2ODg0MTUgMi4yNzcwMzYzLTguMjQ1ODc3OCAwem0wLTIwLjYxNDY5NDVjLTIuMjc3MDM2My0yLjI3NzAzNjMtMi4yNzcwMzYzLTUuOTY4ODQxNSAwLTguMjQ1ODc3OHM1Ljk2ODg0MTUtMi4yNzcwMzYzIDguMjQ1ODc3OCAwIDIuMjc3MDM2MyA1Ljk2ODg0MTUgMCA4LjI0NTg3NzgtNS45Njg4NDE1IDIuMjc3MDM2My04LjI0NTg3NzggMHptLTEwLjMwNzM0NzIgMTAuMzA3MzQ3M2MtMi4yNzcwMzYzLTIuMjc3MDM2My0yLjI3NzAzNjMtNS45Njg4NDE2IDAtOC4yNDU4Nzc4IDIuMjc3MDM2Mi0yLjI3NzAzNjMgNS45Njg4NDE1LTIuMjc3MDM2MyA4LjI0NTg3NzggMCAyLjI3NzAzNjIgMi4yNzcwMzYyIDIuMjc3MDM2MiA1Ljk2ODg0MTUgMCA4LjI0NTg3NzgtMi4yNzcwMzYzIDIuMjc3MDM2Mi01Ljk2ODg0MTYgMi4yNzcwMzYyLTguMjQ1ODc3OCAwem0tMjAuNzEwNTA2IDBjLTIuMjc3MDM2Mi0yLjI3NzAzNjMtMi4yNzcwMzYyLTUuOTY4ODQxNiAwLTguMjQ1ODc3OCAyLjI3NzAzNjMtMi4yNzcwMzYzIDUuOTY4ODQxNi0yLjI3NzAzNjMgOC4yNDU4Nzc4IDAgMi4yNzcwMzYzIDIuMjc3MDM2MiAyLjI3NzAzNjMgNS45Njg4NDE1IDAgOC4yNDU4Nzc4LTIuMjc3MDM2MiAyLjI3NzAzNjItNS45Njg4NDE1IDIuMjc3MDM2Mi04LjI0NTg3NzggMHptLTE5LjU4Mzk1OTcgMTkuNTgzOTU5N2MtMS43MDc3NzcyLTEuNzA3Nzc3Mi0xLjcwNzc3NzItNC40NzY2MzExIDAtNi4xODQ0MDgzczQuNDc2NjMxMS0xLjcwNzc3NzIgNi4xODQ0MDgzIDAgMS43MDc3NzcyIDQuNDc2NjMxMSAwIDYuMTg0NDA4My00LjQ3NjYzMTEgMS43MDc3NzcyLTYuMTg0NDA4MyAwem0zMC45MjIwNDE3LTEwLjMwNzM0NzJjLTEuNzA3Nzc3Mi0xLjcwNzc3NzItMS43MDc3NzcyLTQuNDc2NjMxMiAwLTYuMTg0NDA4NHM0LjQ3NjYzMTItMS43MDc3NzcyIDYuMTg0NDA4NCAwIDEuNzA3Nzc3MiA0LjQ3NjYzMTIgMCA2LjE4NDQwODQtNC40NzY2MzEyIDEuNzA3Nzc3Mi02LjE4NDQwODQgMHptLTEwLjMwNzM0NzIgMTAuMzA3MzQ3MmMtMS43MDc3NzcyLTEuNzA3Nzc3Mi0xLjcwNzc3NzItNC40NzY2MzExIDAtNi4xODQ0MDgzczQuNDc2NjMxMS0xLjcwNzc3NzIgNi4xODQ0MDgzIDAgMS43MDc3NzcyIDQuNDc2NjMxMSAwIDYuMTg0NDA4My00LjQ3NjYzMTEgMS43MDc3NzcyLTYuMTg0NDA4MyAwem0tNDAuMTk4NjU0My0xLjAzMDczNDdjLTEuMTM4NTE4MTMtMS4xMzg1MTgxLTEuMTM4NTE4MTMtMi45ODQ0MjA4IDAtNC4xMjI5Mzg5IDEuMTM4NTE4MS0xLjEzODUxODEgMi45ODQ0MjA4LTEuMTM4NTE4MSA0LjEyMjkzODkgMHMxLjEzODUxODEgMi45ODQ0MjA4IDAgNC4xMjI5Mzg5LTIuOTg0NDIwOCAxLjEzODUxODEtNC4xMjI5Mzg5IDB6bTEwLjMwNzM0NzMgMTAuMzA3MzQ3MmMtMS4xMzg1MTgyLTEuMTM4NTE4MS0xLjEzODUxODItMi45ODQ0MjA3IDAtNC4xMjI5Mzg5IDEuMTM4NTE4MS0xLjEzODUxODEgMi45ODQ0MjA3LTEuMTM4NTE4MSA0LjEyMjkzODggMCAxLjEzODUxODIgMS4xMzg1MTgyIDEuMTM4NTE4MiAyLjk4NDQyMDggMCA0LjEyMjkzODktMS4xMzg1MTgxIDEuMTM4NTE4Mi0yLjk4NDQyMDcgMS4xMzg1MTgyLTQuMTIyOTM4OCAwem00MS4yMjkzODg5IDBjLTEuMTM4NTE4MS0xLjEzODUxODEtMS4xMzg1MTgxLTIuOTg0NDIwNyAwLTQuMTIyOTM4OSAxLjEzODUxODItMS4xMzg1MTgxIDIuOTg0NDIwOC0xLjEzODUxODEgNC4xMjI5Mzg5IDAgMS4xMzg1MTgyIDEuMTM4NTE4MiAxLjEzODUxODIgMi45ODQ0MjA4IDAgNC4xMjI5Mzg5LTEuMTM4NTE4MSAxLjEzODUxODItMi45ODQ0MjA3IDEuMTM4NTE4Mi00LjEyMjkzODkgMHptLTQyLjI2MDEyMzctMTkuNTgzOTU5N2MtMS43MDc3NzcyLTEuNzA3Nzc3Mi0xLjcwNzc3NzItNC40NzY2MzEyIDAtNi4xODQ0MDg0czQuNDc2NjMxMi0xLjcwNzc3NzIgNi4xODQ0MDg0IDAgMS43MDc3NzcyIDQuNDc2NjMxMiAwIDYuMTg0NDA4NC00LjQ3NjYzMTIgMS43MDc3NzcyLTYuMTg0NDA4NCAwem0xOS41ODM5NTk4IDEuMDMwNzM0N2MtMi4yNzcwMzYzLTIuMjc3MDM2My0yLjI3NzAzNjMtNS45Njg4NDE1IDAtOC4yNDU4Nzc4czUuOTY4ODQxNS0yLjI3NzAzNjMgOC4yNDU4Nzc4IDAgMi4yNzcwMzYzIDUuOTY4ODQxNSAwIDguMjQ1ODc3OC01Ljk2ODg0MTUgMi4yNzcwMzYzLTguMjQ1ODc3OCAwem0wLTIwLjYxNDY5NDVjLTIuMjc3MDM2My0yLjI3NzAzNjMtMi4yNzcwMzYzLTUuOTY4ODQxNSAwLTguMjQ1ODc3OHM1Ljk2ODg0MTUtMi4yNzcwMzYzIDguMjQ1ODc3OCAwIDIuMjc3MDM2MyA1Ljk2ODg0MTUgMCA4LjI0NTg3NzgtNS45Njg4NDE1IDIuMjc3MDM2My04LjI0NTg3NzggMHptLTEwLjMwNzM0NzMgMTAuMzA3MzQ3M2MtMi4yNzcwMzYyLTIuMjc3MDM2My0yLjI3NzAzNjItNS45Njg4NDE2IDAtOC4yNDU4Nzc4IDIuMjc3MDM2My0yLjI3NzAzNjMgNS45Njg4NDE2LTIuMjc3MDM2MyA4LjI0NTg3NzggMCAyLjI3NzAzNjMgMi4yNzcwMzYyIDIuMjc3MDM2MyA1Ljk2ODg0MTUgMCA4LjI0NTg3NzgtMi4yNzcwMzYyIDIuMjc3MDM2Mi01Ljk2ODg0MTUgMi4yNzcwMzYyLTguMjQ1ODc3OCAweiIvPjwvZz48L3N2Zz4=";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._messaged = (event) => {
      const data = event.data;
      if (data && data.origin === "mathwallet_internal" && data.type === "lockStatusChanged" && !data.payload) {
        this._disconnected();
      }
    };
    this._disconnected = () => {
      if (this._wallet) {
        window.removeEventListener("message", this._messaged);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2;
        if ((_a2 = window.solana) == null ? void 0 : _a2.isMathWallet) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.solana;
      let account;
      try {
        account = await wallet.getAccount();
      } catch (error) {
        throw new WalletAccountError(error == null ? void 0 : error.message, error);
      }
      let publicKey;
      try {
        publicKey = new PublicKey(account);
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      window.addEventListener("message", this._messaged);
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    if (this._wallet) {
      window.removeEventListener("message", this._messaged);
      this._wallet = null;
      this._publicKey = null;
    }
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-neko/lib/esm/adapter.js
init_index_browser_esm();
var NekoWalletName = "Neko";
var NekoWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = NekoWalletName;
    this.url = "https://nekowallet.com";
    this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIyNDRweCIgaGVpZ2h0PSIyNjBweCIgdmlld0JveD0iMCAwIDI0NCAyNjAiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDI0NCAyNjAiIHhtbDpzcGFjZT0icHJlc2VydmUiPiAgPGltYWdlIGlkPSJpbWFnZTAiIHdpZHRoPSIyNDQiIGhlaWdodD0iMjYwIiB4PSIwIiB5PSIwIgogICAgaHJlZj0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFQUUFBQUVFQ0FNQUFBQW9GT2xoQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUNCalNGSk4KQUFCNkpnQUFnSVFBQVBvQUFBQ0E2QUFBZFRBQUFPcGdBQUE2bUFBQUYzQ2N1bEU4QUFBQjQxQk1WRVVBQUFEL2Z5RC9jQ0QvZ0NyLwpmeXIvZ0VEL2dBRC9iU1QvY0JEM2JCajViUnI0YlJuNGJScjViaHI0YmhuNWJCbjRiaG40YlJyNmJodjNiQmo0YlJyM2NCajRiUm41CmJoci9jUno0Ynh2NWJocjNhQmovY3huNWJocjFhaHYzYkJyL2JSdjNiUnIyYkJ2M2JSdjRiQnI0YmhydmNDRDRiUm40YlJyM2NCajQKYmhmM2JSdjRieG4zYkJyM2JCbjRiQm41YlJyNWJScjRiQm4vZGgzNGJocjZhaHY0YXhuL2RTRDNiaHIzYlJqL2JCMzNhQmowYWh2MwpiUnIvYnhINGJCbjRiUnYvYnhENGJSbjZhaFg0YlJyMWJCbjRiUnI2YmhqNGJScjRiUm40YkJuNGJCcjNiUmo0YmhuNGJCcjRiUnI0CmJodjRiUnY5MnNiN3Y1cjVkaWo2bW1INnJYNzh5S245MGJqOHY1djd0b3o1aUVYKzQ5VCs3T1ArOXZILy8vLzVrVlA1ZGluN28zRDcKdG8zNnBIRDVpRWI1ZnpiKzdlTDdyWC81ZnpmLzl2SCs3ZVA3djV2KzdlSC8vLzcrNU5UN3BIRCs0OVA4dG8zOTJzWDZtMkw1ZnpqLwo5dkQ1Z0RqN3JYNzZwSEg4eUtqKzdPSC8vdjc4djVuNGRpbi85ZkQ4djVyNmlFYjd0b3Y5NDlQOHRveis1TlA5MExmNmtWUDRkeW42CmtWVDZtbUQ0ZGlqOTBiZis3T0Q3dFl2KzlmRDdtbUQ4dnBuOHRZdjgwYmo2bzNEOTVOVDZtbUw3bzNIKzl2RDZpRVg4ckgvNm0ySDcKcllEOTI4WDdtbUg4ckg3N3JIN1dKTE5MQUFBQVQzUlNUbE1BQUFBQUFBQUFBQkJBbjkvdno1QlFiOTlmUWQ0Z3YzOEJqODRnQVlBeApnQUh1a0dIUHpoQncvaUZQWUkrZ29JK2VyNzRCenpCd0FZQmdBU0V3N3hDUWp4QytNTEJRcjErdTNyK3VYNC9Pd0xqT0dBQUFBQUZpClMwZEVYM1BSVVMwQUFBQUpjRWhaY3dBQUN4TUFBQXNUQVFDYW5CZ0FBQUFIZEVsTlJRZm1CaHdHRkNaaGFHR2lBQUFPMTBsRVFWUjQKMnUyZCsyTVVWeFhIbDFacU5vWGF0QW1VaDRhdEJiYUNiVVNMSWxTMFZTeDlPTTAweXo2U3pTNGh6UVBMMGhwVEVaWUVBelZxMGFxawppbS8rVkdkMlp2WTVNK2Q3WnM2ZG05MzAreVBNenIyZm5Edm5mdStkZSsra1Vnd05wWWVmM0dQczJUdWM1dnhLb1hhbG43SXFaT3dkCi9vcXlJcDYyN3U5cTVCbmR2RGJ5c3lQTkNvMnFxZERZUHFOZCszVWpwNTQ3MEZHaGc0Y1VNSThZblJyV3pIeDR1S3RDbytMVVE5M00KdW1QOTJGZDdLalE2SkZ6R0FhTlhPdFBaNDEvenFkQzRiQmxqUGtVWSt6UkNIeG54cVZCR050VFArMEZyRFBXWHZ1NWJJZGxRditCYgp4b2cyYU45QUc4WlJ5VEtPR2Y0NnJvazVJTkJHVnJKOXB3T2c5MGpuUzB5N1h4d0pnSmJzdFlLZ3BmTWxLSi91eW9YK2htQXBKNEtnCnRZUjY5NHRCMWNtZUVDeG1QS2dVNDZRRzZNUGZES3lPWk10N0tiQVVRNEhqSlJRY2FNTjRXYkNjZmNIRkpPOVFRZ0p0VENRRG5iaEQKMmZWc1NHVWtPK3FSa0hLU0R2V1JzTXFNQ2haa2hDblpVQWY1RWtkWnVZTEdRcUgzSmdvZEdtaEpTNVlPaFRhU25Eb0tEN1NrSlNPZwpFM1FvZ1FiVWc1YXpaQ2ZDb1JNMG80RUcxSU9XczJUakJIUmlvUTd6SmRKLy8rZVRLeXBjWWI3RWtad2wreFpWVkVKbWxBNjBvQ1hiClI1YVZ6SHd3SFdqamxGaGhJMlJaaVRnVTN4blFMc2xaTXJxc1JNem90NzlEMXlNalZkZ3h1cXdrUWszNEVrZGlsdXdWQkZwOXFJOEEKVDVtY0pVc0RoYWszbzFDZ2pheFVpNk1NbWFNUnhRNEZDclNjSlJ1SG9CVTdGTXFBZXRDbmhjb2pEWmtqcFdhVUdtazBKV1hKYUVPbQpQdFNBTDNFMElWUWdiY2pjVUtzem80QUJkU1ZseWNDR3BkS013b0VXczJSb2Vlb2NDaDVvS1VzR0dUSkhxaHpLZDlFblRNeVNRWVpNCmFhZ3hYK0pDeXlRV3pKQ3BERFhtUzF4b21iODdac2hjcVRDam5FQkxXYkp4RHJRS004b0p0SlFsQXcyWkszbUhBaHBRVHpLV0REVmsKanNUTktHeEFYVTJJbElwM0YwcENqZnNTUnpLV2pQZUhsamFqREYvaVNNYVNNUXNWTnFQY1FCdVpKd1JLWlJneVY1SU9oUjFvR1V2RwpNV1NPSkIwS3c0QjYwQktQRjhlUWlZZWE1VXRjYUluU1dZWk1PdFFzWCtKQ1MxaXljVDYwOGIwelFqckFMMXZFa3ZFTTJUYVFoQ1hqCkdiSnRvQWtCYUhiNjFDMEpTOFpQSlpvbFljbDBNN0FsWU1uNGhreTNCQ3daMzVEcGxvQWxpMkRJZEVQSHQyUVJESmx1NlBpV2JGdzMKQXg4NnZpWHJPME1tWWNuNnpwQkpXTEsrTTJTV0pkc1Zrem5kZDRiTWNpZnB4Mkl4NzljTkVFblovZC9mSFJsNXFBL2J0cU9EWjZOUwpuK3ZEcHUxcDlPeVhJekUvc3lkKzJmcjA2dkVvRDNaL1BzNHRaZmZ6cWZ1ZDJhWitic2N4V3pwNW1NVThITC9FN2FCaERuV0VtZGZ0CnFXRzhoUTlFMjNaMEVzMW1BOFJzWlRPc3YzNWFkMFZscVk4anc0LytteDhpcU5PMEl4M3JZKy9wcjh4WmFrNTRhT0NZZ2RPckJxYXoKYXRkd2VESWJyQ1RtS1hzODdMRWU2K3VCVmJBeVowT2dCL0NCZG5RdzJLTU1raXZwMG5oUUF4K0xmMjlWZXJkZGs1T1Q3QnNFdnVBaQo5bSthb041ci9XUXFkeWxmc1A0cFh5emxwcm4xdEg4OFU1NnRkR3UyYkJaSzFjdE04SDMrR1p4NmExVUJOZWRWK29yWldkbkMvQlJjCngycHhoaWhtcHZnK2h6dDczTStpa0xZRWhWNXdrV2Q5L2krL0FNWFk5N2U5V3B5L2pGTm5maEFsaTRITVp1UGlwYUJxMDlqTGVReTUKZ1gxbEdhWWU3dzAxbmNYQWV0aXRlOG9NL3YrclMrRlJMc0xFYnJUUlJ1NXp3T1pMNUkvQVdsaVJYUDU1NkJVZmhEemFTM2lVUFYxRApnMzF5Tnp2UUlMUkpNbHM1S0lqNnNnbVYwYVhhRWwxNVd6M2RGaDFvRUhxT1pnNmtmcC8rcGI4K3dKcjQrU2U0Z1FhaEY0enJ3RlY1CnZ3SSs1RGR0VHg5QmFid3JnZjlRQ3JwZy9BSzZ6cWRGWWo4TUVQWmdkeVp3WktRQkZUNVh4U3A1dGFmbmlzVU14anJ6STRZWnc2R24KME1mU2xHV3VWRllBaEk0MU9OQjdhS1RrQWw3M2FzZk5meG1YMmNwbUFNTnJqek9IVjBqQkpieU9IYUZlalo3RG1rSjZydXpyVFdocwoyUlJRN3RVOG81SnR3NjdKcUgxVmh6NEdqUDA0SzQxQjBOVElxRU9sMXExalA5Q09nTWM2NDAzOWc5UDdNaFZyYWJGNTUxOEozUkZvCjRNMkZvK0NpUUdub1p2dVdhZHkyUHFZSDdPZGQ2QmZJSzlWQTMzQnYvR3U1VzVaSWl0SGRyS2t4Y2VpYnJFRFhrSXZvVUx1akRuUngKc3pqMExVNmdiODFEbDVHaGR2MEp1dVJWSExyZUNNc2tOcHk4dlFaZHRrNWkvTGdCamI3VmtJZHU5S3RZNnE3bHNLZWdWcVV3TXZaRApEVy9TRUlldTVlemIzc0d1clU0V29BdnpGRWJqb2Y2SlB1aDVBMDVqOWFsSnpPMlI3YnV4MndGZXVpOFBiZmRadjhHdXJSc0c1dXZyCnBCYzlqNDZ3bEVCWE5xeTdMbUdYV3BuK2hoRDBhNHc4aGtNWDBlazlDeHA4VWl0M0RRUHJzOGptYldjeWZJY2RERDEvandIOUNYYnAKQ2pyay9pM0pZV1V5ZkRFUkRyMkpRLzhPdk5TQy9qMXlYZTBQTlBUcmpNMW1NSFQxVXh3YXpHT1YreUQwSDJrT0szMlBLNEEyd0dIVApCa2hTYWZoMHhNWFFhY3l3SnhLQVdYNCtORGlCc29HUHNERG8rcDhRa0FuR3Zpc0dOSlpvYldpd3g4S2dNV2JqZ2dyb0JXTVpoa1puCkVoRm9rTms0eWxoUXhJQTJzTWxOV2VqUC9neUNqQ3FDeHV5SlpQT3Uvd1ZlMnpIS09QSUFocmF1eGV3Skk1RVZER00xK0g5cm4vMFYKV3RmaEtLc0lHck1uRzR3M0d5Vmo3VUhBUXpPYnorRXJlQlJDWS9hRVlVNHNlMkxGY25xdWFKYmIvN0g4b0xqRlhxdWxDaHF6Snd3YgphdW1xTi8rMU1MM1owSUovazZibkJoVkFOeWJ4SVh1eXdaenpYbHdpbjl5RlMrWXRiZENRUGJHaE9XKy9MSm56d2R6VFczbTc3ZC9YCkJnM1pFOFlrUXB0bThwZXFuZVJUMC9hS1NqZk4xVzVRSUNxZ1AyOWNqZGdUR3hyUFpKMHFtNlpaeU9kTmM2YmMrUjgxTXJHcGdIWmUKUENQMnhJYVdlNUhsaW55a0ZVSWo5bVFEdlpDam14cWhFWHZTZ0VaSDFLRG8xcTBFdXRDNEdyRW5EV2p3dFE0cXVuVXJnWGJmTVFEUAphZ1BhK0pza2MyMk9CbEVJRFhUQURyUm9LZ01DclFUNmpuTTVZRThjYU9QdmNzeElvSlZBdXhZWnNDY3V0T0JUalFSYUpUUmdUMXhvCnVRUU9wRzdGMEhUOFBHandkUzJ0MnhDSUNtalArOUt1b3dtOXhscUFGcWhiMkZ5Q0N1aDU5M3JhbmpTaFJaWkpWaDZDVTBZcW9XbDcKMG9LVzZLeHJINElnS3FCejNnL0kvcmNOV3NDQ2I2QWdLcUNiUzExSWU5SlJ6YmpVTUxOYWFITHBRR2M5NDFIanpHcWgvOEdzNkQragpJOVBUSllxaFd3YUJTc25kMFltOFJlbmhKb05aQ1hTcjQ2RHNTVStUWEgwUWlYbUY4WHBET1RSbHRIeWV3emwrc0djNVRWczk5TC80CjBNWXljMDY0Y3BQMVNrY1ZkT3NYbEQzeHo3Z3M3QUw3cFk1cWFNcWVCSFV6eTNtc2tjL2VZMGM1QVdnaVppRjk2MmFlR29PVWk2eVUKblJ3MFlVL0NEY1Z5cnZUQUxQdjhyRHlUTC9KZXprYUhIaGg5QWIxVDlBWDBUaEVIdXN5Ui95Mm10MHI1d2t6WlRzbmw4b3haS0FWYgppNm5wcldMZTlMbXo5YlBpcFdxTTVLMW16VW1sZDB1NEJWRXRtajJqcnFDNStlb1ZreHFoelJUSmZUbEpRM2VOQWFhMi9DRjhOeFJOClhTbGpoU3plNUkydVZFTjNOTnRxTVNoczlkNVdXbVVOT0ZhaWhGc1I5R0xiejZvaG8rcTczV1h3QjlUTXNiUkM2TmFPc09WUWlxNkYKUU9qcFZKMWlOM0pGME0zOFJCeEYxR20rbzg0V1hadkhJUlJDdTMvN1pXSytxSlpydi8rL295SGJvcmROcTRkMkZsVVpWYXF4dHI5awp2TXlkTWVuUVI1d21yZ2JhZVMxUEw0dGJiMk8rSG9mWmF1SzZsejQ3TTkvQWlSYXQweXBXWXpLenFOVkFnOHl0MThtWEJaYWQ0TlJLCm9HMFBpaXo1Ykw2V21Md2VuNWxCclFUYVlwbEdydk5NNkNUeldNRWdJVWMyS1lPZVJnNmZxN1JNYUl5K3FsUHZZU0NLbGo1ank0WGMKcFVBaXF4QWFvZzlFVUFhZFJ6ZmdPYzFSY3UwY3R1aEVCZlFjMXJnOUV5cld1RzFCRFZ6SnV5elFXemttZEZWMHZUZlV3QlZBZnc1dQp0SFJNS0hjUEJ5WG8wRDE1NkRzb1J0MitLWG9xMXl6WUlKQlFLNENHYy9GZFRxRHo2UDVFSU5TcXBvc1EyVE1JYU9xdTVkQW1VYWNUCnVFYm9oZ2xGNDFlYmZoZHRRZlF5STUzUVZjYWk1enJlbmE5dloyaTdIY0k3TFcvQnA4QUFxVXdqdEIwUmVDUHhDcU52STl1M1J1Z1YKVGllOWdoOGtRT2R2amRDMzhUTjhHanZNWUdneWYrdUR0bDlqNFp1bmJ6TE9uQ1QzTkdpRXJuTDJiakJPVDNET2R0dWUwTFlKeFk5Ngo1a0NUT3puMFFkc21GRDhqbW5IS0ViM0ZWQiswYlVMeFRUb3NhQ3A5NjRObUhRMWdQNlk0OUYwQ1JCOTBUaDAwdFExUEUvVHN6SU9GCkhRTnRMM0RjeWkyNDdtSEFvV2ZOZk1tQzdicWhLdWh0a3NnS3ZqZGtRTi9vUTJqN0tUYUxwYTNxZEljdlZ0UlBVNmU3SkovSUxQcTgKVFcvZkVUZFpuUE9zdHE4ajQ1d0RYR0Y2YjJvamkxNUhwbWlVUlUyZDZJTmVOeml2c1FabFBGM2xwTy83REdqS2hlcWNPV0VkVWNXWgpJeVBQOGRFN1I3Ynpaa1B0UncrZTkxN25YTHFOb1J0dmF0SDJYVitBMzNEb09hVUtsZTBoMWtDVVdnNTlFb0RYbGpxaDdjRVFuSjVLCnFDSFRja3JWOWYrZzBJMnp1RkZIdlhnZHUwN1BLVlVsZENHQ1l4ZUZUeVBUZEVwVkNWeFBWWEdIZ0ZJZkNIUC9rSHBPcVNxQjM4dW8KZUoyTDFMbEZEWkZuaHFxQy9oVHRYSnhFdXlhNHZBZzZzbDhKdElGNkovZWxxdURKaXRoaEowcWcwYzl3ZVBNNllnMGNYQkdyQkJvOAp2TDQ1Q0p5VU9aZ0xYdnVzQmhvOWtNZDd2eWl6YWhBOW1Vc1JOTnkrUFo4c1FWMkRqMGhRQXcxMzFldmV2ZU5UdzZlUktZTkd1K3BXCkZ4T1grdUYvY1JCRjBPZ1hoZG9tTHVOUlgrT2M4WklWL3c2SHN4a09iZDl0bmN4YWpQWEFuN0MyVzJiRW9aMk5hR2dxVzIrZnVmeGYKMUgwTjJNbVpUUjJGUCtXSlFqc2JhbEVyMmpua1g0VzlYRWVZdVNmYm5NSS9kc2lDaGwxV1Y1RDRKM094RCtZeWpKZkZ2NHptUXFQdAp1MmVTbW9jZDVjaW03RS94RDVqeW9OR1BvL204anBpRGQ4dWJqNkljZ21GL1YxNzRFNDhlTkdoRmZWZTZMYytSaDE5WXhQZWlIUU5oCkplOFUvajA0SGpUYVZRZk4yRzQrS3BvQnAyQ1VaL0tQTnFNZmRETEIrUHkwSGkzMEtNNnhMcmFzUnpxVk9nYTM3OEZRcHZIOWFielQKR2doTk5LRHhiNWdPZ3R4dnlqTStlRGdBdXVBdzc2aFFlNEZPcFM3b3JrcHltdkNZVTJNN0pvRm5tb0ZPcFU3cnJreEN5cDVPdFdtSAo1TEkzMnBsVHg1N1VYWjhrZFBGUUIzVHEzQTU0ckROZHpEdWgzOHFlUy9Yb2pPNUtxV1kra2ZKUmVxQmJlQ2FkOHRYWUFHZXppK2RTCkFSb2JXR3QyYWlnVnJOTUQyY1F6cDFPaEdvTm5qL3BIYnh4S1VYcmxUZDJWbE5XYmFSTFppZmJBTlBKWG44S1FiUTJkZVN1VHplcXUKY1R4bHM1bUp0NGRnWkVmbnpyeHo2bWNXZWovcTRzVzMzbms3c0pOSy9SOXZRRFNYcURYRjdRQUFBQ1YwUlZoMFpHRjBaVHBqY21WaApkR1VBTWpBeU1pMHdOaTB5T0ZRd05Eb3lNRG96T0Nzd01qb3dNSmVEK2JFQUFBQWxkRVZZZEdSaGRHVTZiVzlrYVdaNUFESXdNakl0Ck1EWXRNamhVTURRNk1qQTZNemdyTURJNk1ERG0za0VOQUFBQUFFbEZUa1N1UW1DQyIgLz4KPC9zdmc+Cg==";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2;
        if ((_a2 = window.neko) == null ? void 0 : _a2.isNeko) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    var _a2;
    return !!((_a2 = this._wallet) == null ? void 0 : _a2.isConnected);
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.neko;
      if (!wallet.isConnected) {
        try {
          await wallet.connect();
        } catch (error) {
          throw new WalletConnectionError(error == null ? void 0 : error.message, error);
        }
      }
      if (!wallet.publicKey)
        throw new WalletAccountError();
      let publicKey;
      try {
        publicKey = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      wallet.on("disconnect", this._disconnected);
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.off("disconnect", this._disconnected);
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signature } = await wallet.signMessage(message);
        return signature;
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-nightly/lib/esm/adapter.js
init_index_browser_esm();
var NightlyWalletName = "Nightly";
var NightlyWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor() {
    super();
    this.name = NightlyWalletName;
    this.url = "https://nightly.app";
    this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOTYiIGhlaWdodD0iOTYiIHZpZXdCb3g9IjAgMCA5NiA5NiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTQ4IDk2Qzc0LjUwOTcgOTYgOTYgNzQuNTA5NyA5NiA0OEM5NiAyMS40OTAzIDc0LjUwOTcgMCA0OCAwQzIxLjQ5MDMgMCAwIDIxLjQ5MDMgMCA0OEMwIDc0LjUwOTcgMjEuNDkwMyA5NiA0OCA5NloiIGZpbGw9IiM2RDczRjgiLz4KPHBhdGggZD0iTTQ4IDg1LjYzNTZDNDggODUuNjM1NiA1Mi40NTMzIDg1LjYzNTYgNTUuNDQgODIuNTg2N0M1OC45MTU1IDc5LjI4MDEgNTcuMzUxMSA3NS40MzEyIDYyLjI3NTUgNzEuNDMxMkM2Ni45ODY2IDY3LjY0NDUgNzIuOTI0NCA3MC4zMzc5IDcyLjkyNDQgNzAuMzM3OUM3Ny4wMjIyIDYyLjEyNDUgNzQuNzkxMSA1Mi41NjkgNzQuNzkxMSA1Mi41NjlDODEuNzY4OCAzNC4yNTc5IDc1Ljk2NDQgMjEuMTU1NyA3NC40NDQ0IDE3LjM2MDFDNjkuNDQ4OCAyNC4zMzc5IDYzLjE5MTEgMjkuMTczNCA1NS43OTU1IDMyLjQwOUM1My4yMjY2IDMxLjcwNjggNTAuNTk1NSAzMS4zMzM0IDQ4IDMxLjM2MDFDNDUuNDEzMyAzMS4zMzM0IDQyLjc3MzMgMzEuNzA2OCA0MC4yMDQ0IDMyLjQwOUMzMi44MTc3IDI5LjE2NDUgMjYuNTUxMSAyNC4zMzc5IDIxLjU1NTUgMTcuMzYwMUMyMC4wMzU1IDIxLjE1NTcgMTQuMjMxMSAzNC4yNTc5IDIxLjIwODkgNTIuNTY5QzIxLjIwODkgNTIuNTY5IDE4Ljk3NzggNjIuMTI0NSAyMy4wNzU1IDcwLjMzNzlDMjMuMDc1NSA3MC4zMzc5IDI5LjAxMzMgNjcuNjQ0NSAzMy43MjQ0IDcxLjQzMTJDMzguNjU3NyA3NS40MzEyIDM3LjA4NDQgNzkuMjgwMSA0MC41NiA4Mi41ODY3QzQzLjU0NjYgODUuNjM1NiA0OCA4NS42MzU2IDQ4IDg1LjYzNTZaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNNDIuNDc5OSA2NS4yOThDNDIuMjkzMyA1OS4yMTggMzYuMzAyMSA1Ny4yNjI0IDMyLjIxMzMgNTkuODIyNEMzMi4yMTMzIDU5LjgyMjQgMzIuODUzMyA2Mi40MzU4IDM1LjgzOTkgNjMuNzUxM0MzOC4yNzU1IDY0LjgyNjkgMzkuMzI0NCA2My4zODY5IDQyLjQ3OTkgNjUuMjk4WiIgZmlsbD0iIzdCODFGOSIvPgo8cGF0aCBkPSJNMjIuNDk3NyAyMy4wOTM1QzIwLjA4ODggMzEuNTQ2OCAyMS4xMjg4IDQyLjI0MDIgMjQuOTMzMyA1MC4wMjY5QzI4LjgyNjYgNDcuMjcxMyAzMi45MTU1IDQzLjAxMzUgMzUuMDkzMyAzOC41MDY5QzI5Ljk2NDQgMzQuNzExMyAyNS42NjIyIDMxLjEwMjQgMjIuNDk3NyAyMy4wOTM1WiIgZmlsbD0iIzdCODFGOSIvPgo8cGF0aCBkPSJNNTMuNTE5OSA2NS4yOThDNTMuNzA2NiA1OS4yMTggNTkuNjk3NyA1Ny4yNjI0IDYzLjc4NjYgNTkuODIyNEM2My43ODY2IDU5LjgyMjQgNjMuMTQ2NiA2Mi40MzU4IDYwLjE1OTkgNjMuNzUxM0M1Ny43MjQzIDY0LjgyNjkgNTYuNjc1NSA2My4zODY5IDUzLjUxOTkgNjUuMjk4WiIgZmlsbD0iIzdCODFGOSIvPgo8cGF0aCBkPSJNNzMuNTAyMiAyMy4wOTM1Qzc1LjkxMTEgMzEuNTQ2OCA3NC44NzExIDQyLjI0MDIgNzEuMDY2NiA1MC4wMjY5QzY3LjE3MzMgNDcuMjcxMyA2My4wODQ0IDQzLjAxMzUgNjAuOTA2NiAzOC41MDY5QzY2LjAzNTUgMzQuNzExMyA3MC4zMzc3IDMxLjEwMjQgNzMuNTAyMiAyMy4wOTM1WiIgZmlsbD0iIzdCODFGOSIvPgo8cGF0aCBkPSJNNDcuOTk5OSA4NS4zMDY5QzUwLjE0MDQgODUuMzA2OSA1MS44NzU1IDgzLjc3ODcgNTEuODc1NSA4MS44OTM2QzUxLjg3NTUgODAuMDA4NCA1MC4xNDA0IDc4LjQ4MDIgNDcuOTk5OSA3OC40ODAyQzQ1Ljg1OTUgNzguNDgwMiA0NC4xMjQ0IDgwLjAwODQgNDQuMTI0NCA4MS44OTM2QzQ0LjEyNDQgODMuNzc4NyA0NS44NTk1IDg1LjMwNjkgNDcuOTk5OSA4NS4zMDY5WiIgZmlsbD0iIzdCODFGOSIvPgo8L3N2Zz4K";
    this.supportedTransactionVersions = /* @__PURE__ */ new Set(["legacy", 0]);
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._connecting = false;
    this._publicKey = null;
    this._wallet = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2;
        if ((_a2 = window == null ? void 0 : window.nightly) == null ? void 0 : _a2.solana) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get connecting() {
    return this._connecting;
  }
  get readyState() {
    return this._readyState;
  }
  get publicKey() {
    return this._publicKey;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.nightly.solana;
      try {
        await wallet.connect();
      } catch (error) {
        throw new WalletConnectionError(error == null ? void 0 : error.message, error);
      }
      if (wallet.publicKey.toString() === "11111111111111111111111111111111")
        throw new WalletAccountError();
      let publicKey;
      try {
        publicKey = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectedError());
      }
    }
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction);
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions);
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return wallet.signMessage(new TextDecoder().decode(message));
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-nufi/lib/esm/adapter.js
init_index_browser_esm();
var NufiWalletName = "NuFi";
var NufiWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = NufiWalletName;
    this.url = "https://nu.fi";
    this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjMiIHZpZXdCb3g9IjAgMCAyMiAyMyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0iIzIxMjEyMSIgLz4KPHBhdGggZD0iTTQuMzA5OTkgOS4wMDAwOEM1LjMwODc3IDYuMjA0MDEgNy45ODA2OSA0LjIwMzA4IDExLjEyIDQuMjAzMDhDMTQuMjU5MiA0LjIwMzA4IDE2LjkzMTEgNi4yMDQwMSAxNy45Mjk5IDkuMDAwMDhDMTcuOTc5IDkuMTM3NDcgMTguMTA3NCA5LjIzMjE4IDE4LjI1MzMgOS4yMzIxOEgyMS4wNTk0QzIxLjI3MjUgOS4yMzIxOCAyMS40MzE3IDkuMDM1NzYgMjEuMzc5NCA4LjgyOTE5QzIwLjIxOTUgNC4yNDM2MiAxNi4wNjYgMC44NTAzNDIgMTEuMTIgMC44NTAzNDJDNi4xNzM5MSAwLjg1MDM0MiAyLjAyMDQyIDQuMjQzNjIgMC44NjA0NjggOC44MjkxOEMwLjgwODIxMyA5LjAzNTc2IDAuOTY3NDM0IDkuMjMyMTggMS4xODA1MiA5LjIzMjE4SDMuOTg2NTlDNC4xMzI0OSA5LjIzMjE4IDQuMjYwOTEgOS4xMzc0NyA0LjMwOTk5IDkuMDAwMDhaIiBmaWxsPSIjQzZGRjAwIi8+CjxwYXRoIGQ9Ik0zLjk4NjU5IDEzLjYzMjdDNC4xMzI0OSAxMy42MzI3IDQuMjYwOTEgMTMuNzI3NCA0LjMwOTk5IDEzLjg2NDhDNS4zMDg3NyAxNi42NjA4IDcuOTgwNjkgMTguNjYxOCAxMS4xMiAxOC42NjE4QzE0LjI1OTIgMTguNjYxOCAxNi45MzExIDE2LjY2MDggMTcuOTI5OSAxMy44NjQ4QzE3Ljk3OSAxMy43Mjc0IDE4LjEwNzQgMTMuNjMyNyAxOC4yNTMzIDEzLjYzMjdIMjEuMDU5NEMyMS4yNzI1IDEzLjYzMjcgMjEuNDMxNyAxMy44MjkxIDIxLjM3OTQgMTQuMDM1N0MyMC4yMTk1IDE4LjYyMTIgMTYuMDY2IDIyLjAxNDUgMTEuMTIgMjIuMDE0NUM2LjE3MzkxIDIyLjAxNDUgMi4wMjA0MiAxOC42MjEyIDAuODYwNDY4IDE0LjAzNTdDMC44MDgyMTMgMTMuODI5MSAwLjk2NzQzNCAxMy42MzI3IDEuMTgwNTIgMTMuNjMyN0gzLjk4NjU5WiIgZmlsbD0iI0M2RkYwMCIvPgo8cGF0aCBkPSJNOS4yNTQ5OSA5LjIzMjE4QzkuMDY5ODMgOS4yMzIxOCA4LjkxOTcyIDkuMzgyMjkgOC45MTk3MiA5LjU2NzQ2VjEzLjI5NzRDOC45MTk3MiAxMy40ODI1IDkuMDY5ODMgMTMuNjMyNyA5LjI1NDk5IDEzLjYzMjdIMTIuOTg0OUMxMy4xNzAxIDEzLjYzMjcgMTMuMzIwMiAxMy40ODI1IDEzLjMyMDIgMTMuMjk3NFY5LjU2NzQ2QzEzLjMyMDIgOS4zODIyOSAxMy4xNzAxIDkuMjMyMTggMTIuOTg0OSA5LjIzMjE4SDkuMjU0OTlaIiBmaWxsPSIjQzZGRjAwIi8+Cjwvc3ZnPgo=";
    this.supportedTransactionVersions = /* @__PURE__ */ new Set(["legacy", 0]);
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2;
        if ((_a2 = window.nufiSolana) == null ? void 0 : _a2.isNufi) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    var _a2;
    return !!((_a2 = this._wallet) == null ? void 0 : _a2.isConnected);
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.nufiSolana;
      if (!wallet.isConnected) {
        try {
          await wallet.connect();
        } catch (error) {
          throw new WalletConnectionError(error == null ? void 0 : error.message, error);
        }
      }
      if (!wallet.publicKey)
        throw new WalletAccountError();
      let publicKey;
      try {
        publicKey = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      wallet.on("disconnect", this._disconnected);
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.off("disconnect", this._disconnected);
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async sendTransaction(transaction, connection, options = {}) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signers, ...sendOptions } = options;
        if (isVersionedTransaction(transaction)) {
          (signers == null ? void 0 : signers.length) && transaction.sign(signers);
        } else {
          transaction = await this.prepareTransaction(transaction, connection, sendOptions);
          (signers == null ? void 0 : signers.length) && transaction.partialSign(...signers);
        }
        sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
        const { signature } = await wallet.signAndSendTransaction(transaction);
        return signature;
      } catch (error) {
        if (error instanceof WalletError)
          throw error;
        throw new WalletSendTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signature } = await wallet.signMessage(message);
        return signature;
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-onto/lib/esm/adapter.js
init_index_browser_esm();
var OntoWalletName = "ONTO";
var OntoWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = OntoWalletName;
    this.url = "https://onto.app";
    this.icon = "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyODggMjg4Ij4KICA8dGl0bGU+T05UTyBMT0dPXzI4OHgyODg8L3RpdGxlPgogIDxnIGlkPSJMT0dPIj4KICAgIDxwYXRoIGlkPSLlvaLnirbnu5PlkIgiIGQ9Ik0zMCwxMS4xNSw3MS4xOSw1Mi4zMkExMTUsMTE1LDAsMCwxLDI1OCwxMzguNjdMMjU4LDE0MlYyNzYuODVsLTQxLjE5LTQxLjE2QTExNSwxMTUsMCwwLDEsMzAuMDUsMTQ5LjM0TDMwLDE0NlptMjguMTcsNjhWMTQ2YTg2Ljc5LDg2Ljc5LDAsMCwwLDEzNS4xNSw3MmwyLjIzLTEuNTVMNjMuNjcsODQuNjVaTTk0LjY4LDcwbC0yLjIzLDEuNTVMMjI0LjMzLDIwMy4zNmw1LjUsNS41VjE0MkE4Ni43OSw4Ni43OSwwLDAsMCw5NC42OCw3MFoiLz4KICA8L2c+Cjwvc3ZnPg==";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2, _b;
        if ((_b = (_a2 = window.onto) == null ? void 0 : _a2.solana) == null ? void 0 : _b.isONTO) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    var _a2;
    return !!((_a2 = this._wallet) == null ? void 0 : _a2.isConnected);
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.onto.solana;
      let account;
      try {
        account = await wallet.getAccount();
      } catch (error) {
        throw new WalletAccountError(error == null ? void 0 : error.message, error);
      }
      let publicKey;
      try {
        publicKey = new PublicKey(account);
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signature } = await wallet.signMessage(message);
        return signature;
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-particle/lib/esm/adapter.js
init_index_browser_esm();
var ParticleName = "Particle";
var ParticleAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    var _a2, _b;
    super();
    this.name = ParticleName;
    this.url = "https://particle.network";
    this.icon = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMTQwIiBoZWlnaHQ9IjE0MCIgdmlld0JveD0iMCAwIDE0MCAxNDAiPjxkZWZzPjxmaWx0ZXIgaWQ9ImEiIHg9IjAiIHk9IjAiIHdpZHRoPSIxNDAiIGhlaWdodD0iMTQwIiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiPjxmZUltYWdlIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiIHdpZHRoPSIxNDAiIGhlaWdodD0iMTQwIiByZXN1bHQ9ImltYWdlIiB4bGluazpocmVmPSJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGh0Ykc1ek9uaHNhVzVyUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMM2hzYVc1cklpQjNhV1IwYUQwaU1UUXdJaUJvWldsbmFIUTlJakUwTUNJZ2RtbGxkMEp2ZUQwaU1DQXdJREUwTUNBeE5EQWlQZ29nSUR4a1pXWnpQZ29nSUNBZ1BITjBlV3hsUGdvZ0lDQWdJQ0F1WTJ4ekxURWdld29nSUNBZ0lDQWdJR1pwYkd3NklIVnliQ2dqYkdsdVpXRnlMV2R5WVdScFpXNTBLVHNLSUNBZ0lDQWdmUW9nSUNBZ1BDOXpkSGxzWlQ0S0lDQWdJRHhzYVc1bFlYSkhjbUZrYVdWdWRDQnBaRDBpYkdsdVpXRnlMV2R5WVdScFpXNTBJaUI0TVQwaU1UUXdJaUI1TVQwaU1UUXdJaUI0TWowaU1DSWdaM0poWkdsbGJuUlZibWwwY3owaWRYTmxjbE53WVdObFQyNVZjMlVpUGdvZ0lDQWdJQ0E4YzNSdmNDQnZabVp6WlhROUlqQWlJSE4wYjNBdFkyOXNiM0k5SWlObE1EUXdaRGNpTHo0S0lDQWdJQ0FnUEhOMGIzQWdiMlptYzJWMFBTSXhJaUJ6ZEc5d0xXTnZiRzl5UFNJak5qSXlOMlUySWk4K0NpQWdJQ0E4TDJ4cGJtVmhja2R5WVdScFpXNTBQZ29nSUR3dlpHVm1jejRLSUNBOGNtVmpkQ0JqYkdGemN6MGlZMnh6TFRFaUlIZHBaSFJvUFNJeE5EQWlJR2hsYVdkb2REMGlNVFF3SWk4K0Nqd3ZjM1puUGdvPSIvPjxmZUNvbXBvc2l0ZSByZXN1bHQ9ImNvbXBvc2l0ZSIgb3BlcmF0b3I9ImluIiBpbjI9IlNvdXJjZUdyYXBoaWMiLz48ZmVCbGVuZCByZXN1bHQ9ImJsZW5kIiBpbjI9IlNvdXJjZUdyYXBoaWMiLz48L2ZpbHRlcj48L2RlZnM+PHJlY3QgZGF0YS1uYW1lPSLlnIbop5Lnn6nlvaIgMSIgd2lkdGg9IjE0MCIgaGVpZ2h0PSIxNDAiIHJ4PSI0MCIgcnk9IjQwIiBmaWx0ZXI9InVybCgjYSkiLz48cGF0aCBkYXRhLW5hbWU9IuakreWchiAzIOaLt+i0nSIgZD0iTTM0LjkxIDMwLjhhNi42MTQgNi42MTQgMCAxIDAgNi41NTMgNi42MTRBNi41ODQgNi41ODQgMCAwIDAgMzQuOTEgMzAuOHptMTMuNjE1LTcuODJhNi41NTIgNi41NTIgMCAwIDAtOC4yNzIgNC4yNTQgNi42MzkgNi42MzkgMCAwIDAgNC4yMTUgOC4zNDkgNi41NTIgNi41NTIgMCAwIDAgOC4yNzItNC4yNTQgNi42MzkgNi42MzkgMCAwIDAtNC4yMTUtOC4zNDl6bTE1LjMxMS0zLjI0OGE2LjUyNSA2LjUyNSAwIDAgMC05LjE3IDEuNDY4IDYuNjY2IDYuNjY2IDAgMCAwIDEuNDUyIDkuMjU1IDYuNTI1IDYuNTI1IDAgMCAwIDkuMTY5LTEuNDY2IDYuNjY2IDYuNjY2IDAgMCAwLTEuNDUxLTkuMjU3em0xNS41NTYgMS42ODdhNi41MjUgNi41MjUgMCAwIDAtOS4xNjktMS40NjYgNi42NjYgNi42NjYgMCAwIDAtMS40NTIgOS4yNTUgNi41MjUgNi41MjUgMCAwIDAgOS4xNjkgMS40NjYgNi42NjYgNi42NjYgMCAwIDAgMS40NTEtOS4yNTZ6bTE0LjI3OCA2LjQ1NWE2LjU1MiA2LjU1MiAwIDAgMC04LjI3LTQuMjU0IDYuNjM5IDYuNjM5IDAgMCAwLTQuMjE1IDguMzQ5IDYuNTUyIDYuNTUyIDAgMCAwIDguMjcyIDQuMjU0IDYuNjM5IDYuNjM5IDAgMCAwIDQuMjEzLTguMzQ5em0xMS42IDEwLjU5NGE2LjU2NCA2LjU2NCAwIDEgMC02LjU2NCA2LjYyNiA2LjYgNi42IDAgMCAwIDYuNTY2LTYuNjI2em03Ljc5MiAxMy42OTRhNi42MzkgNi42MzkgMCAwIDAtNC4yMTQtOC4zNDkgNi41NTIgNi41NTIgMCAwIDAtOC4yNzIgNC4yNTQgNi42MzkgNi42MzkgMCAwIDAgNC4yMTUgOC4zNDkgNi41NTEgNi41NTEgMCAwIDAgOC4yNzMtNC4yNTN6bTMuMjE4IDE1LjQ1NWE2LjY2NiA2LjY2NiAwIDAgMC0xLjQ1Mi05LjI1NSA2LjUyNSA2LjUyNSAwIDAgMC05LjE2OSAxLjQ2NiA2LjY2NiA2LjY2NiAwIDAgMCAxLjQ1MiA5LjI1NSA2LjUyNSA2LjUyNSAwIDAgMCA5LjE3MS0xLjQ2NnptLTEuNjcxIDE1LjdhNi42NjYgNi42NjYgMCAwIDAgMS40NTItOS4yNTUgNi41MjUgNi41MjUgMCAwIDAtOS4xNjktMS40NjYgNi42NjYgNi42NjYgMCAwIDAtMS40NTIgOS4yNTUgNi41MjUgNi41MjUgMCAwIDAgOS4xNzEgMS40Njh6bS02LjQgMTQuNDEyYTYuNjM4IDYuNjM4IDAgMCAwIDQuMjE0LTguMzQ5IDYuNTUxIDYuNTUxIDAgMCAwLTguMjcxLTQuMjU0IDYuNjM5IDYuNjM5IDAgMCAwLTQuMjE1IDguMzQ5IDYuNTUyIDYuNTUyIDAgMCAwIDguMjc4IDQuMjU2em0tMTAuNSAxMS43MTFhNi42MjYgNi42MjYgMCAxIDAtNi41NjQtNi42MjYgNi42IDYuNiAwIDAgMCA2LjU3NSA2LjYyOHptLTEzLjU2NyA3Ljg2NWE2LjU1MiA2LjU1MiAwIDAgMCA4LjI3Mi00LjI1NCA2LjYzOSA2LjYzOSAwIDAgMC00LjIxNS04LjM0OSA2LjU1MiA2LjU1MiAwIDAgMC04LjI3MiA0LjI1NCA2LjYzOSA2LjYzOSAwIDAgMCA0LjIyNSA4LjM1MXptLTE1LjMxMSAzLjI0OEE2LjUyNSA2LjUyNSAwIDAgMCA3OCAxMTkuMDg3YTYuNjY2IDYuNjY2IDAgMCAwLTEuNDUyLTkuMjU1IDYuNTI1IDYuNTI1IDAgMCAwLTkuMTY5IDEuNDY2IDYuNjY2IDYuNjY2IDAgMCAwIDEuNDYyIDkuMjU3em0tMTUuNTU2LTEuNjg2YTYuNTI1IDYuNTI1IDAgMCAwIDkuMTY5IDEuNDY1IDYuNjY2IDYuNjY2IDAgMCAwIDEuNDUyLTkuMjU1IDYuNTI1IDYuNTI1IDAgMCAwLTkuMTY5LTEuNDY2IDYuNjY3IDYuNjY3IDAgMCAwLTEuNDQxIDkuMjU4em0tMTQuMjc4LTYuNDU3YTYuNTUyIDYuNTUyIDAgMCAwIDguMjcyIDQuMjU1IDYuNjQgNi42NCAwIDAgMCA0LjIxNS04LjM1IDYuNTUyIDYuNTUyIDAgMCAwLTguMjcyLTQuMjU0IDYuNjM5IDYuNjM5IDAgMCAwLTQuMjA1IDguMzUxek0yNy40IDEwMS44MTlhNi41NjUgNi41NjUgMCAxIDAgNi41NjQtNi42MjYgNi42IDYuNiAwIDAgMC02LjU2NCA2LjYyNnptMTguNzgtNTYuNDY2YTMuOTY5IDMuOTY5IDAgMSAwIDMuOTMyIDMuOTY4IDMuOTUgMy45NSAwIDAgMC0zLjkzMi0zLjk2OHptOC40NTUtNS4wMjlhMy45MzEgMy45MzEgMCAwIDAtNC45NjMgMi41NTIgMy45ODMgMy45ODMgMCAwIDAgMi41MjkgNS4wMSAzLjkzMSAzLjkzMSAwIDAgMCA0Ljk2My0yLjU1MiAzLjk4NCAzLjk4NCAwIDAgMC0yLjUyOS01LjAxem05LjUzNy0yLjIzMmEzLjkxNSAzLjkxNSAwIDAgMC01LjUuODggNCA0IDAgMCAwIC44NzEgNS41NTMgMy45MTUgMy45MTUgMCAwIDAgNS41LS44OCA0IDQgMCAwIDAtLjg3MS01LjU1M3ptOS43NTMuODUyYTMuOTE1IDMuOTE1IDAgMCAwLTUuNS0uODggNCA0IDAgMCAwLS44NzEgNS41NTMgMy45MTUgMy45MTUgMCAwIDAgNS41Ljg4IDQgNCAwIDAgMCAuODcxLTUuNTUzem05LjAxNiAzLjg1NmEzLjkzMSAzLjkzMSAwIDAgMC00Ljk2My0yLjU1MyAzLjk4NCAzLjk4NCAwIDAgMC0yLjUyOSA1LjAxIDMuOTMxIDMuOTMxIDAgMCAwIDQuOTYzIDIuNTUzIDMuOTg0IDMuOTg0IDAgMCAwIDIuNTI5LTUuMDF6bTcuMzk1IDYuNDc2YTMuOTM5IDMuOTM5IDAgMSAwLTMuOTM2IDMuOTcyIDMuOTU3IDMuOTU3IDAgMCAwIDMuOTM1LTMuOTc2em01LjA1IDguNDY1YTMuOTgzIDMuOTgzIDAgMCAwLTIuNTI5LTUuMDEgMy45MzEgMy45MzEgMCAwIDAtNC45NjMgMi41NTIgMy45ODQgMy45ODQgMCAwIDAgMi41MjkgNS4wMSAzLjkzMSAzLjkzMSAwIDAgMCA0Ljk2Mi0yLjU1NnptMi4yMTQgOS42MjNhNCA0IDAgMCAwLS44NzEtNS41NTMgMy45MTUgMy45MTUgMCAwIDAtNS41Ljg4IDQgNCAwIDAgMCAuODcxIDUuNTUzIDMuOTE1IDMuOTE1IDAgMCAwIDUuNS0uODh6bS0uODQ0IDkuODQ1YTQgNCAwIDAgMCAuODcxLTUuNTUzIDMuOTE1IDMuOTE1IDAgMCAwLTUuNS0uODggNCA0IDAgMCAwLS44NzEgNS41NTMgMy45MTUgMy45MTUgMCAwIDAgNS40OTcuODh6bS0zLjgxNyA5LjFhMy45ODMgMy45ODMgMCAwIDAgMi41MjktNS4wMSAzLjkzMSAzLjkzMSAwIDAgMC00Ljk2OC0yLjU1MyAzLjk4MyAzLjk4MyAwIDAgMC0yLjUyOSA1LjAwOSAzLjkzMSAzLjkzMSAwIDAgMCA0Ljk2NSAyLjU1M3ptLTYuNDE5IDcuNDYzYTMuOTc2IDMuOTc2IDAgMSAwLTMuOTM4LTMuOTcyIDMuOTU3IDMuOTU3IDAgMCAwIDMuOTM4IDMuOTcyem0tOC4zODcgNS4xYTMuOTMxIDMuOTMxIDAgMCAwIDQuOTY3LTIuNTU1IDMuOTgzIDMuOTgzIDAgMCAwLTIuNTI5LTUuMDFBMy45MzEgMy45MzEgMCAwIDAgNzUuNiA5My44NmEzLjk4MyAzLjk4MyAwIDAgMCAyLjUzNCA1LjAxek02OC42IDEwMS4xYTMuOTE1IDMuOTE1IDAgMCAwIDUuNS0uODggNCA0IDAgMCAwLS44NzEtNS41NTMgMy45MTUgMy45MTUgMCAwIDAtNS41Ljg4IDQgNCAwIDAgMCAuODcxIDUuNTUzem0tOS43NTMtLjg1MmEzLjkxNiAzLjkxNiAwIDAgMCA1LjUuODggNCA0IDAgMCAwIC44NzEtNS41NTQgMy45MTUgMy45MTUgMCAwIDAtNS41LS44OCA0IDQgMCAwIDAtLjg3NSA1LjU1NnpNNDkuODI4IDk2LjRhMy45MzEgMy45MzEgMCAwIDAgNC45NjMgMi41NTMgMy45ODQgMy45ODQgMCAwIDAgMi41MjktNS4wMSAzLjkzMSAzLjkzMSAwIDAgMC00Ljk2My0yLjU1MyAzLjk4MyAzLjk4MyAwIDAgMC0yLjUyOSA1LjAxem0tNy4zOTUtNi40NzZhMy45MzkgMy45MzkgMCAxIDAgMy45MzktMy45NzYgMy45NTcgMy45NTcgMCAwIDAtMy45MzggMy45NzR6TTUzLjUxOSA1Ni4yYTIuMTE3IDIuMTE3IDAgMSAwIDIuMSAyLjExNyAyLjEwNyAyLjEwNyAwIDAgMC0yLjEtMi4xMTd6bTQuNjM5LTIuNzIzYTIuMSAyLjEgMCAwIDAtMi42NDcgMS4zNjEgMi4xMjUgMi4xMjUgMCAwIDAgMS4zNDkgMi42NzIgMi4xIDIuMSAwIDAgMCAyLjY0Ny0xLjM2MSAyLjEyNCAyLjEyNCAwIDAgMC0xLjM0OS0yLjY3MnptNS4yLTEuMjUyYTIuMDg4IDIuMDg4IDAgMCAwLTIuOTM0LjQ2OSAyLjEzMyAyLjEzMyAwIDAgMCAuNDY1IDIuOTYyIDIuMDg4IDIuMDg4IDAgMCAwIDIuOTM0LS40NjkgMi4xMzMgMi4xMzMgMCAwIDAtLjQ3LTIuOTYxem01LjMyNC40M2EyLjA4OCAyLjA4OCAwIDAgMC0yLjkzNC0uNDY5IDIuMTMzIDIuMTMzIDAgMCAwLS40NjUgMi45NjIgMi4wODggMi4wODggMCAwIDAgMi45MzQuNDY5IDIuMTMzIDIuMTMzIDAgMCAwIC40Ni0yLjk2MXptNC45MzIgMi4wN2EyLjEgMi4xIDAgMCAwLTIuNjQ3LTEuMzYxIDIuMTI0IDIuMTI0IDAgMCAwLTEuMzQ5IDIuNjcyQTIuMSAyLjEgMCAwIDAgNzIuMjYgNTcuNGEyLjEyNCAyLjEyNCAwIDAgMCAxLjM0OS0yLjY3NHptNC4wNTcgMy41MDdhMi4xIDIuMSAwIDEgMC0yLjEgMi4xMiAyLjExMSAyLjExMSAwIDAgMCAyLjA5NS0yLjEyem0yLjc4NSA0LjZhMi4xMjUgMi4xMjUgMCAwIDAtMS4zNTYtMi42NzEgMi4xIDIuMSAwIDAgMC0yLjY0NyAxLjM2MSAyLjEyNSAyLjEyNSAwIDAgMCAxLjM0NyAyLjY3MiAyLjEgMi4xIDAgMCAwIDIuNjUxLTEuMzYxem0xLjI0IDUuMjQ0YTIuMTMzIDIuMTMzIDAgMCAwLS40NjUtMi45NjIgMi4wODggMi4wODggMCAwIDAtMi45MzQuNDY5IDIuMTMzIDIuMTMzIDAgMCAwIC40NjUgMi45NjIgMi4wODggMi4wODggMCAwIDAgMi45MjktLjQ2OHptLS40MjYgNS4zNzRhMi4xMzMgMi4xMzMgMCAwIDAgLjQ2NS0yLjk2MiAyLjA4OCAyLjA4OCAwIDAgMC0yLjkzNS0uNDY4IDIuMTMzIDIuMTMzIDAgMCAwLS40NjUgMi45NjIgMi4wODggMi4wODggMCAwIDAgMi45MjkuNDY5em0tMi4wNSA0Ljk3OGEyLjEyNSAyLjEyNSAwIDAgMCAxLjM0OS0yLjY3MiAyLjEgMi4xIDAgMCAwLTIuNjUzLTEuMzU2IDIuMTI0IDIuMTI0IDAgMCAwLTEuMzQ5IDIuNjcyIDIuMSAyLjEgMCAwIDAgMi42NDcgMS4zNTd6bS0zLjQ4IDQuMDk1YTIuMTIgMi4xMiAwIDEgMC0yLjEtMi4xMiAyLjExMSAyLjExMSAwIDAgMCAyLjEgMi4xMnptLTQuNTU4IDIuODExYTIuMSAyLjEgMCAwIDAgMi42NDctMS4zNjFBMi4xMjUgMi4xMjUgMCAwIDAgNzIuNDggODEuM2EyLjEgMi4xIDAgMCAwLTIuNjQ3IDEuMzYxIDIuMTI1IDIuMTI1IDAgMCAwIDEuMzQ5IDIuNjczem0tNS4yIDEuMjUyYTIuMDg4IDIuMDg4IDAgMCAwIDIuOTM0LS40NjkgMi4xMzMgMi4xMzMgMCAwIDAtLjQ2NS0yLjk2MiAyLjA4OCAyLjA4OCAwIDAgMC0yLjkzNC40NjkgMi4xMzMgMi4xMzMgMCAwIDAgLjQ3IDIuOTYyem0tNS4zMjQtLjQzYTIuMDg4IDIuMDg4IDAgMCAwIDIuOTM0LjQ2OSAyLjEzMyAyLjEzMyAwIDAgMCAuNDY1LTIuOTYyIDIuMDg4IDIuMDg4IDAgMCAwLTIuOTM0LS40NjkgMi4xMzMgMi4xMzMgMCAwIDAtLjQ2IDIuOTYyem0tNC45MzItMi4wN2EyLjEgMi4xIDAgMCAwIDIuNjQ3IDEuMzYxIDIuMTI1IDIuMTI1IDAgMCAwIDEuMzQ5LTIuNjcyIDIuMSAyLjEgMCAwIDAtMi42NDctMS4zNjEgMi4xMjQgMi4xMjQgMCAwIDAtMS4zNDQgMi42NzJ6bS00LjA1Ny0zLjUwN2EyLjEgMi4xIDAgMSAwIDIuMS0yLjEyIDIuMTExIDIuMTExIDAgMCAwLTIuMDk1IDIuMTJ6IiBmaWxsPSIjZmZmIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
    this._particle = null;
    this._connecting = false;
    this._publicKey = null;
    this._wallet = null;
    this._config = {
      config: {
        projectId: "",
        clientKey: "",
        appId: "",
        ...config.config,
        chainId: ((_a2 = config.config) == null ? void 0 : _a2.chainId) ?? 101,
        chainName: ((_b = config.config) == null ? void 0 : _b.chainName) ?? "solana"
      },
      login: config.login
    };
  }
  get particle() {
    return this._particle;
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Loadable)
        throw new WalletNotReadyError();
      this._connecting = true;
      let ParticleClass;
      let WalletClass;
      try {
        ({ ParticleNetwork: ParticleClass, SolanaWallet: WalletClass } = await import("./es-6XB7LSB4.js"));
      } catch (error) {
        throw new WalletLoadError(error == null ? void 0 : error.message, error);
      }
      let particle;
      try {
        particle = new ParticleClass(this._config.config);
        if (!particle.auth.isLogin()) {
          await particle.auth.login(this._config.login);
        }
      } catch (error) {
        throw new WalletConfigError(error == null ? void 0 : error.message, error);
      }
      let wallet;
      try {
        wallet = new WalletClass(particle.auth);
      } catch (error) {
        throw new WalletConfigError(error == null ? void 0 : error.message, error);
      }
      const account = wallet.publicKey;
      if (!account)
        throw new WalletAccountError();
      let publicKey;
      try {
        publicKey = new PublicKey(account.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      this._particle = particle;
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signMessage(message);
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-phantom/lib/esm/adapter.js
init_index_browser_esm();
var PhantomWalletName = "Phantom";
var PhantomWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = PhantomWalletName;
    this.url = "https://phantom.app";
    this.icon = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiB2aWV3Qm94PSIwIDAgMTA4IDEwOCIgZmlsbD0ibm9uZSI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPg==";
    this.supportedTransactionVersions = /* @__PURE__ */ new Set(["legacy", 0]);
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        wallet.off("accountChanged", this._accountChanged);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._accountChanged = (newPublicKey) => {
      const publicKey = this._publicKey;
      if (!publicKey)
        return;
      try {
        newPublicKey = new PublicKey(newPublicKey.toBytes());
      } catch (error) {
        this.emit("error", new WalletPublicKeyError(error == null ? void 0 : error.message, error));
        return;
      }
      if (publicKey.equals(newPublicKey))
        return;
      this._publicKey = newPublicKey;
      this.emit("connect", newPublicKey);
    };
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      if (isIosAndRedirectable()) {
        this._readyState = WalletReadyState.Loadable;
        this.emit("readyStateChange", this._readyState);
      } else {
        scopePollingDetectionStrategy(() => {
          var _a2, _b, _c2;
          if (((_b = (_a2 = window.phantom) == null ? void 0 : _a2.solana) == null ? void 0 : _b.isPhantom) || ((_c2 = window.solana) == null ? void 0 : _c2.isPhantom)) {
            this._readyState = WalletReadyState.Installed;
            this.emit("readyStateChange", this._readyState);
            return true;
          }
          return false;
        });
      }
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get readyState() {
    return this._readyState;
  }
  async autoConnect() {
    if (this.readyState === WalletReadyState.Installed) {
      await this.connect();
    }
  }
  async connect() {
    var _a2;
    try {
      if (this.connected || this.connecting)
        return;
      if (this.readyState === WalletReadyState.Loadable) {
        const url = encodeURIComponent(window.location.href);
        const ref = encodeURIComponent(window.location.origin);
        window.location.href = `https://phantom.app/ul/browse/${url}?ref=${ref}`;
        return;
      }
      if (this.readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = ((_a2 = window.phantom) == null ? void 0 : _a2.solana) || window.solana;
      if (!wallet.isConnected) {
        try {
          await wallet.connect();
        } catch (error) {
          throw new WalletConnectionError(error == null ? void 0 : error.message, error);
        }
      }
      if (!wallet.publicKey)
        throw new WalletAccountError();
      let publicKey;
      try {
        publicKey = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      wallet.on("disconnect", this._disconnected);
      wallet.on("accountChanged", this._accountChanged);
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.off("disconnect", this._disconnected);
      wallet.off("accountChanged", this._accountChanged);
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async sendTransaction(transaction, connection, options = {}) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signers, ...sendOptions } = options;
        if (isVersionedTransaction(transaction)) {
          (signers == null ? void 0 : signers.length) && transaction.sign(signers);
        } else {
          transaction = await this.prepareTransaction(transaction, connection, sendOptions);
          (signers == null ? void 0 : signers.length) && transaction.partialSign(...signers);
        }
        sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
        const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);
        return signature;
      } catch (error) {
        if (error instanceof WalletError)
          throw error;
        throw new WalletSendTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signature } = await wallet.signMessage(message);
        return signature;
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-safepal/lib/esm/adapter.js
init_index_browser_esm();
var SafePalWalletName = "SafePal";
var SafePalWalletAdapter = class extends BaseSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = SafePalWalletName;
    this.url = "https://safepal.io";
    this.icon = "data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI1NiIgdmlld0JveD0iMCAwIDI1NiAyNTYiIHdpZHRoPSIyNTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJtMjU2IDEyOGMwIDcwLjY5Mzg3My01Ny4zMDc5MzMgMTI4LTEyOCAxMjgtNzAuNjkyMDY2NyAwLTEyOC01Ny4zMDYxMjctMTI4LTEyOCAwLTcwLjY5MjA2NjcgNTcuMzA3OTMzMy0xMjggMTI4LTEyOCA3MC42OTIwNjcgMCAxMjggNTcuMzA3OTMzMyAxMjggMTI4IiBmaWxsPSIjMDAwIi8+PHBhdGggZD0ibTIwMC45OTE0OTkgMTQxLjM4NDM3OXYxMS45MzQ0MDRjMCAzMi40OTcwNzgtNDYuMjA1ODI2IDUxLjQ3NTM0Ni02MS45MzUzOTggNTYuOTg2NTMybC02LjI4OTM3MSAyLjE3NDY4NXYtMjAuNjI5NDAxbDIuNjIxOTE2LS45ODkyOGMyMi43MTQ3NDUtOC41NDg4MzYgNDUuNjMyMjgyLTIzLjI5NTQ2NSA0Ni4wODgzNjEtMzcuMTIzNzg0bC4wMDY5MjItLjQxODc1MnYtMTEuOTM0NDA0em0tNzIuODY1MTcyLTk3Ljg2NDM3OSAxOS42NjExMzUgNi4wNjMzODIydjIxLjA0ODA2N2wtMTkuNjYxMTM1LTYuMDg0Mzk2My0xLjI4NjcxMS4zOTkyNjgzdjQ3LjM1NDUxMzhoMjAuOTQ3ODQ2djE5LjUxMDgwM2gtMjAuOTQ3ODQ2djgwLjM4MDYzbC02LjM2Mjg5Mi0yLjM3NTQ2N2MtMi40NDg2MzUtLjkyODUwMi01Ljk3MzE2Ny0yLjMzOTg4Ni0xMC4yMTU4NzUtNC4yNDkxNDJsLS41NTc0NC0uMjUxODU4LTIuMzc0NTk2LTEuMDg0NjUydi0xNTQuMjkzNzU5N3ptLTI2Ljk2OTIgOC40MDA0NzU4djIwLjk1MTA3ODhsLTI2LjY0MTA1NTggOC4yNjk4NjQ5djMxLjE1OTA5MjVoMjYuNjQxMDU1OHY5MC4yNDI3MThsLTUuOTAwMTE4Mi0zLjAzNDExNWMtMTguMTc2Mjc3My05LjM1NTM5LTM5LjgxMTA4ODItMjUuMDcwMTczLTQwLjI0MTk2NjgtNDYuOTcwMjQ4bC0uMDA2NTQxMS0uNjY1NTMydi0xMC40ODkyOGgxOS41MDc1NzAzdjEwLjQ4OTI4YzAgNC40NjY3MzcgMi4yNTgyODY3IDkuMTU1OCA2LjcxODY5NjMgMTMuOTgyOTQ0bC40MTE1NTY2LjQzOTIwOXYtMzQuNDg0MTczaC0yNi42Mzc4MjMydi02NS42NDY0OTh6bTUyLjU1MjYtLjQ5OTE2NjIgNDcuMjgxNzcyIDE0LjYzMzkxMDZ2NjUuNzU2NDE3OGgtMjcuNzU4MDM3djI4LjQ3NTc1MWwtLjI4NTQ4OS4zNTQyMDZjLTEuMzU1MjUgMS42MzQ0NTUtNy41NjM1NzUgOC42MjI2NTUtMTkuMjIwNDY1IDE0LjU5NDkxNnptMTkuNTIzNzM1IDI3LjA3NzUwMzN2MzMuODAyMDIyMWg4LjI1MDQ2N3YtMzEuMjU0NDY0eiIgZmlsbD0iI2ZmZiIvPjwvZz48L3N2Zz4=";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2;
        if ((_a2 = window.safepal) == null ? void 0 : _a2.isSafePalWallet) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.safepal;
      let account;
      try {
        account = await wallet.getAccount();
      } catch (error) {
        throw new WalletAccountError(error == null ? void 0 : error.message, error);
      }
      let publicKey;
      try {
        publicKey = new PublicKey(account);
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    if (this._wallet) {
      this._wallet = null;
      this._publicKey = null;
    }
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction);
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions);
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-saifu/lib/esm/adapter.js
init_index_browser_esm();
var SaifuWalletName = "Saifu";
var SaifuWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = SaifuWalletName;
    this.url = "https://saifuwallet.com";
    this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNTQxcHgiIGhlaWdodD0iNTQxcHgiIHZpZXdCb3g9IjAgMCA1NDEgNTQxIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPHRpdGxlPkFydGJvYXJkIENvcHkgOTwvdGl0bGU+CiAgICA8ZGVmcz4KICAgICAgICA8bGluZWFyR3JhZGllbnQgeDE9IjEuNzk5ODcyMTYlIiB5MT0iMCUiIHgyPSI5OC4zOTcxMDUxJSIgeTI9Ijk3Ljk5MDI5MSUiIGlkPSJsaW5lYXJHcmFkaWVudC0xIj4KICAgICAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj0iI0ZCOTIzQyIgb2Zmc2V0PSIwJSI+PC9zdG9wPgogICAgICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPSIjRUM0ODk5IiBvZmZzZXQ9IjEwMCUiPjwvc3RvcD4KICAgICAgICA8L2xpbmVhckdyYWRpZW50PgogICAgPC9kZWZzPgogICAgPGcgaWQ9IkFydGJvYXJkLUNvcHktOSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPHBhdGggZD0iTTIzMi4yNzAwNDQsLTcuODU2NzI5NzFlLTE1IEwzMDcuNzI5OTU2LDcuODU2NzI5NzFlLTE1IEMzNzkuNDY1Mzc2LC01LjMyMDg1MzMyZS0xNSA0MTIuMzM3Mzc5LDguODE4NDMzMDYgNDQzLjMwMDM0MiwyNS4zNzc2MDY5IEM0NzQuMjYzMzA1LDQxLjkzNjc4MDcgNDk4LjU2MzIxOSw2Ni4yMzY2OTUyIDUxNS4xMjIzOTMsOTcuMTk5NjU4MiBDNTMxLjY4MTU2NywxMjguMTYyNjIxIDU0MC41LDE2MS4wMzQ2MjQgNTQwLjUsMjMyLjc3MDA0NCBMNTQwLjUsMzA4LjIyOTk1NiBDNTQwLjUsMzc5Ljk2NTM3NiA1MzEuNjgxNTY3LDQxMi44MzczNzkgNTE1LjEyMjM5Myw0NDMuODAwMzQyIEM0OTguNTYzMjE5LDQ3NC43NjMzMDUgNDc0LjI2MzMwNSw0OTkuMDYzMjE5IDQ0My4zMDAzNDIsNTE1LjYyMjM5MyBDNDEyLjMzNzM3OSw1MzIuMTgxNTY3IDM3OS40NjUzNzYsNTQxIDMwNy43Mjk5NTYsNTQxIEwyMzIuMjcwMDQ0LDU0MSBDMTYwLjUzNDYyNCw1NDEgMTI3LjY2MjYyMSw1MzIuMTgxNTY3IDk2LjY5OTY1ODIsNTE1LjYyMjM5MyBDNjUuNzM2Njk1Miw0OTkuMDYzMjE5IDQxLjQzNjc4MDcsNDc0Ljc2MzMwNSAyNC44Nzc2MDY5LDQ0My44MDAzNDIgQzguMzE4NDMzMDYsNDEyLjgzNzM3OSAtMC41LDM3OS45NjUzNzYgLTAuNSwzMDguMjI5OTU2IEwtMC41LDIzMi43NzAwNDQgQy0wLjUsMTYxLjAzNDYyNCA4LjMxODQzMzA2LDEyOC4xNjI2MjEgMjQuODc3NjA2OSw5Ny4xOTk2NTgyIEM0MS40MzY3ODA3LDY2LjIzNjY5NTIgNjUuNzM2Njk1Miw0MS45MzY3ODA3IDk2LjY5OTY1ODIsMjUuMzc3NjA2OSBDMTI3LjY2MjYyMSw4LjgxODQzMzA2IDE2MC41MzQ2MjQsNS4zMjA4NTMzMmUtMTUgMjMyLjI3MDA0NCwtNy44NTY3Mjk3MWUtMTUgWiIgaWQ9IlJlY3RhbmdsZSIgZmlsbD0idXJsKCNsaW5lYXJHcmFkaWVudC0xKSI+PC9wYXRoPgogICAgICAgIDxnIGlkPSJMYXllciIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTA3LjUwMjc2NCwgODcuMDIxNTg5KSIgZmlsbD0iI0ZGRkZGRiI+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNjEuMzI1MTQ3LDMyMy44NjM0MjEgQzE0Mi44Mjk2OTQsMzIzLjc5NzY1NSAxMjMuMjczNDA1LDMyMy4xODE2MjggMTE1LjYyMDA1NCwzMjIuNDIzNjkzIEMxMDguMjYyNjAyLDMyMS42OTUwNTUgOTYuMTg1MjU1MywzMTkuOTI1MzEgODguNzgxNTA3MywzMTguNDkwODYyIEM4MS4zNzc3NjAzLDMxNy4wNTY0NDQgNzAuNTIyNDg5MywzMTQuMzEyMjczIDY0LjY1ODY4OTMsMzEyLjM5MjcxOCBDNTguNzk0ODg5MywzMTAuNDczMTMxIDUwLjMxNDQ1MTMsMzA3LjEyMTE3MiA0NS44MTMyNzYzLDMwNC45NDM4NjUgQzQxLjMxMjA5MzMsMzAyLjc2NjU4OCAzMy45ODIzODIzLDI5OC4yMzcxMzkgMjkuNTI1MDMwMywyOTQuODc4NDM1IEMyNS4wNjc2NzEzLDI5MS41MTk3MDEgMTkuMTY5NTMxMywyODYuMDA1Njk0IDE2LjQxODA0MzMsMjgyLjYyNTAxNyBDMTMuNjY2NTU1MywyNzkuMjQ0NDAyIDkuNjgzMDk2MjksMjczLjAzNzM3MSA3LjU2NTkwMTI5LDI2OC44MzE2MjEgQzUuNDQ4NzEzMjksMjY0LjYyNTg3MiAyLjg3OTY0NDI5LDI1Ny42NTA4OTYgMS44NTY4NTUyOSwyNTMuMzMxNjIxIEMwLjU0MDkzNzI4NywyNDcuNzc0NDkzIDAsMjQxLjY3NzU2OSAwLDIzMi40Nzg0MTEgQzAsMjIzLjk1Mzc1MyAwLjYyMzY5MzI4NywyMTYuMzgwMDgzIDEuODA2NDE3MjksMjEwLjQ3ODQxMSBDMi43OTg0MjkyOSwyMDUuNTI4Mzk5IDQuOTYyNzg5MjksMTk3LjQyODQyMyA2LjYxNjExNzI5LDE5Mi40Nzg0MTEgQzguMjY5NDQ1MjksMTg3LjUyODM5OSAxMS4zNzA1MjczLDE3OS41MzcwOTYgMTMuNTA3NDIxMywxNzQuNzE5OTI3IEMxNy4zOTI2NjgzLDE2NS45NjE0NDMgMTcuMzkyNjY4MywxNjUuOTYxNDQzIDE0Ljg0OTI0MTMsMTYxLjA1OTA5OSBDMTMuMjU3MzY4MywxNTcuOTkwODMyIDEyLjI0ODA5MDMsMTU0LjMwNjUwNSAxMi4xNTE1MjUzLDE1MS4yMTExODQgQzEyLjA2NjY2MzMsMTQ4LjQ5MTEyMiAxMi42MjU5NTkzLDE0NC41MTM1MDYgMTMuMzk0Mzk5MywxNDIuMzcyMDI3IEMxNC4xNjI4NDAzLDE0MC4yMzA1NDcgMTcuOTQ4MTk0MywxMzQuMjE2NDc5IDIxLjgwNjMwMzMsMTI5LjAwNzQzMyBDMjUuNjY0NDExMywxMjMuNzk4Mzg4IDMzLjEzNTY4NzMsMTE1LjA3NTYwOSAzOC40MDkxMzkzLDEwOS42MjM0OTIgQzQzLjY4MjU5MjMsMTA0LjE3MTM3NCA1MS41OTcyNDIzLDk2LjY3NTczODQgNTUuOTk3MjM2Myw5Mi45NjY0Nzk0IEM2MC4zOTcyMzAzLDg5LjI1NzI1MDQgNjcuODIyMjMzMyw4My42Nzk5MTk0IDcyLjQ5NzIzNjMsODAuNTcyNDM2NCBDNzcuMTcyMjM5Myw3Ny40NjQ5MjI0IDg1LjQwNTkyNzMsNzIuNjU0Mzc1NCA5MC43OTQzMjUzLDY5Ljg4MjMxMTQgQzk2LjE4MjcyMjMsNjcuMTEwMjQ3NCAxMDQuNTg1OTgxLDYzLjM1NzEwNDQgMTA5LjQ2ODIxNCw2MS41NDE5NDk0IEMxMTQuMzUwNDYyLDU5LjcyNjgyNDQgMTIxLjQxNjc2MSw1Ny40MzYzMjc0IDEyNS4xNzExMjUsNTYuNDUxOTgzNCBDMTI4LjkyNTQ4OSw1NS40Njc2MDg0IDEzMi4zNzk0MzgsNTQuMzI4NjYxNCAxMzIuODQ2NTcxLDUzLjkyMDk3NzQgQzEzMy4zMTM3MDMsNTMuNTEzMjkzNCAxMzMuMzkzNDkxLDUyLjIyNjg4NTQgMTMzLjAyMzg2Myw1MS4wNjIzMDQ0IEMxMzIuNjU0MjM0LDQ5Ljg5NzcyMzQgMTMwLjY1NDQzMiw0OC4wNzg5MzY0IDEyOC41Nzk4NDcsNDcuMDIwNTU2NCBDMTI2LjUwNTI2Miw0NS45NjIxNzY0IDEyMy4zMzE2OTMsNDMuNDE0OTY1NCAxMjEuNTI3NDY0LDQxLjM2MDA2NDQgQzExOS43MjMyMzQsMzkuMzA1MTYzNCAxMTcuNjI4MzQsMzYuMTQzMDg0NCAxMTYuODcyMTQ0LDM0LjMzMzI2OTQgQzExNi4xMTU5NDksMzIuNTIzNDI0NCAxMTUuNDk3MjM2LDI4LjMxMzczODQgMTE1LjQ5NzIzNiwyNC45Nzg0MTE0IEMxMTUuNDk3MjM2LDIxLjY0MzA4NDQgMTE2LjE4NjE1NSwxNy4yNjUzMzc0IDExNy4wMjgxODEsMTUuMjUwMTA5NCBDMTE3Ljg3MDE5MSwxMy4yMzQ4ODE0IDExOS42OTgxMDMsMTAuMDkyNzkxNCAxMjEuMDkwMTkzLDguMjY3NjU3NDMgQzEyMi40ODIyNjcsNi40NDI1NTM0MyAxMjUuODI4Mzk3LDMuODMwODI4NDMgMTI4LjUyNTk5OSwyLjQ2MzgyNDQzIEMxMzIuMzM4NDIzLDAuNTMxOTM5NDI1IDEzNC45NDE0MTksLTAuMDE2NzA1NTc0NiAxNDAuMjEzOTg3LDAgQzE0NC42MTc5NDgsMC4wMTQ2MzU0MjU0IDE0OC40MTM4NDcsMC42NjU4MTk0MjUgMTUxLjAzNTk0OCwxLjg1Njg5MDQzIEMxNTMuMjU3MjMxLDIuODY1ODkzNDMgMTU2Ljk2OTc0LDUuODQ0MzQ3NDMgMTU5LjI4NTk0OCw4LjQ3NTcyNTQzIEMxNjMuNDk3MjM2LDEzLjI1OTk5NzQgMTYzLjQ5NzIzNiwxMy4yNTk5OTc0IDE2Ny43MDg1MjQsOC40NzU3MjU0MyBDMTcwLjAyNDczMiw1Ljg0NDM0NzQzIDE3My43MzcyNDEsMi44NjU4OTM0MyAxNzUuOTU4NTI0LDEuODU2ODkwNDMgQzE3OC41ODA2MjUsMC42NjU4MTk0MjUgMTgyLjM3NjUzOSwwLjAxNDYzNTQyNTQgMTg2Ljc4MDQ3LDAgQzE5Mi4wNTMwNTMsLTAuMDE2NzA1NTc0NiAxOTQuNjU2MDQ5LDAuNTMxOTM5NDI1IDE5OC40Njg0NTgsMi40NjM4MjQ0MyBDMjAxLjE2NjA5LDMuODMwODI4NDMgMjA0LjQ3MzAwNSw2LjQxODMyMjQzIDIwNS44MTcxODIsOC4yMTM4MjQ0MyBDMjA3LjE2MTM2LDEwLjAwOTM1NjQgMjA4Ljk4OTI0LDEyLjkxODU2NjQgMjA5Ljg3OTE5NCwxNC42Nzg3NTk0IEMyMTAuODgxODgsMTYuNjYxOTQ0NCAyMTEuNDk3MjM2LDIwLjM4MjIyMDQgMjExLjQ5NzIzNiwyNC40NjA4NjM0IEMyMTEuNDk3MjM2LDI4LjA4MDg1OTQgMjEwLjg3ODUyMywzMi41MjM0MjQ0IDIxMC4xMjIzMjgsMzQuMzMzMjY5NCBDMjA5LjM2NjEzMiwzNi4xNDMwODQ0IDIwNy4yNzEyNTMsMzkuMzA1MTYzNCAyMDUuNDY3MDI0LDQxLjM2MDA2NDQgQzIwMy42NjI3OTQsNDMuNDE0OTY1NCAyMDAuNDg5MjEsNDUuOTYyMTc2NCAxOTguNDE0NjI1LDQ3LjAyMDU1NjQgQzE5Ni4zNDAwNCw0OC4wNzg5MzY0IDE5NC4zNDAyMjMsNDkuODk3NzIzNCAxOTMuOTcwNjI1LDUxLjA2MjMwNDQgQzE5My42MDA5OTYsNTIuMjI2ODg1NCAxOTMuNjgwNzY5LDUzLjUwODI4ODQgMTk0LjE0NzkwMSw1My45MDk4Mzg0IEMxOTQuNjE1MDM0LDU0LjMxMTM4ODQgMTk3LjY5NzI0OCw1NS4zNzA1MzE0IDIwMC45OTcyMzYsNTYuMjYzNDQ1NCBDMjA0LjI5NzIyNCw1Ny4xNTYzNTk0IDIxMC4xNTMwODksNTguOTY5NDM5NCAyMTQuMDEwMjA2LDYwLjI5MjQ5ODQgQzIxNy44NjczNTMsNjEuNjE1NTI2NCAyMjQuMzY0NzI5LDY0LjE2NDYyOTQgMjI4LjQ0ODgzNSw2NS45NTcxNzE0IEMyMzIuNTMyOTQyLDY3Ljc0OTcxMjQgMjQwLjI5MjA2Niw3MS44MzkzNzM0IDI0NS42OTEyOTcsNzUuMDQ1MzM2NCBDMjUxLjA5MDUyOCw3OC4yNTEyOTk0IDI1OC45OTMxNDcsODMuNDY0MjgxNCAyNjMuMjUyNjY4LDg2LjYyOTcxNzQgQzI2Ny41MTIxOSw4OS43OTUxODM0IDI3Ny4xMTY2ODIsOTguNDgxMDk3NCAyODQuNTk2MDIxLDEwNS45MzE3NSBDMjkyLjA3NTM2MSwxMTMuMzgyNDAzIDMwMS40MTI0MjgsMTIzLjgzNTQ2NyAzMDUuMzQ1MDc1LDEyOS4xNjA3ODQgQzMwOS4yNzc2OTMsMTM0LjQ4NjA3MSAzMTIuOTQ1NzUzLDE0MC4wMjc4OCAzMTMuNDk2MjU5LDE0MS40NzU4NzggQzMxNC4wNDY3OTcsMTQyLjkyMzg3NiAzMTQuNDk3MjM2LDE0Ni45MzcyODkgMzE0LjQ5NzIzNiwxNTAuMzk0NTY0IEMzMTQuNDk3MjM2LDE1NS4xMzAxMjkgMzEzLjg5ODExNSwxNTcuODA3Mjk5IDMxMi4wNjgxODksMTYxLjI0ODkxOSBDMzA5LjYzOTE3MywxNjUuODE3MzI0IDMwOS42MzkxNzMsMTY1LjgxNzMyNCAzMTQuNjI4MjE3LDE3Ny41ODk4MzEgQzMxNy4zNzIxNzUsMTg0LjA2NDcxNSAzMjAuNzM4NzUyLDE5My4yMTM0NTcgMzIyLjEwOTQ0OSwxOTcuOTIwMzY3IEMzMjMuNDgwMTc3LDIwMi42MjcyNzYgMzI1LjI5ODAxNywyMTAuOTc4NDExIDMyNi4xNDkwOTEsMjE2LjQ3ODQxMSBDMzI3LjIxNTAwOSwyMjMuMzY2Njg2IDMyNy41MTg4NDIsMjI5LjkwMTMyNCAzMjcuMTI1NTAxLDIzNy40Nzg0MTEgQzMyNi43OTc0MzcsMjQzLjc5NzY4NiAzMjUuNjgwNDY0LDI1MS41OTY4OCAzMjQuNTAwNTYyLDI1NS44MDcwMjQgQzMyMy4zNzA4OTMsMjU5LjgzNzc4NiAzMjEuMTU2ODEyLDI2NS42OTA3ODMgMzE5LjU4MDM5NiwyNjguODEzNjc3IEMzMTguMDAzOTUsMjcxLjkzNjYwMiAzMTQuNTU1NzA4LDI3Ny4zNjMwNTUgMzExLjkxNzY0NiwyODAuODcyNDU0IEMzMDkuMjc5NTU0LDI4NC4zODE4ODQgMzAzLjgyNDc4MSwyODkuODcyNjk4IDI5OS43OTU5NDIsMjkzLjA3NDI5NyBDMjk1Ljc2NzA3MiwyOTYuMjc1ODY2IDI4OS42NjQxOTgsMzAwLjQ2Mzg4NSAyODYuMjMzOTkxLDMwMi4zODA5NjggQzI4Mi44MDM3ODUsMzA0LjI5ODA4MyAyNzUuODc1MDEzLDMwNy40NTc3NTEgMjcwLjgzNjc0NCwzMDkuNDAyNDgzIEMyNjUuNzk4NDc1LDMxMS4zNDcyNDYgMjU3LjI0ODQ1NywzMTQuMDkwNTk0IDI1MS44MzY3NDQsMzE1LjQ5ODgyNyBDMjQ2LjQyNTAwMSwzMTYuOTA3MDYxIDIzNi41OTcyNDIsMzE4LjkxNDY5IDIyOS45OTcyMzYsMzE5Ljk2MDI4NCBDMjIzLjM5NzIzLDMyMS4wMDU4NDYgMjEyLjUxOTc4OCwzMjIuMzM3NjY0IDIwNS44MjUxNDcsMzIyLjkxOTg0OCBDMTk5LjEzMDUwNiwzMjMuNTAyMDYyIDE3OS4xMDU0OTcsMzIzLjkyNjY4NCAxNjEuMzI1MTQ3LDMyMy44NjM0MjEgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4=";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        if (window.saifu) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    var _a2;
    return !!((_a2 = this._wallet) == null ? void 0 : _a2.isConnected);
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.saifu;
      if (!wallet.isConnected) {
        try {
          await wallet.connect();
        } catch (error) {
          throw new WalletConnectionError(error == null ? void 0 : error.message, error);
        }
      }
      if (!wallet.publicKey)
        throw new WalletAccountError();
      let publicKey;
      try {
        publicKey = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      wallet.on("disconnect", this._disconnected);
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.off("disconnect", this._disconnected);
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async sendTransaction(transaction, connection, options = {}) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      if (wallet.signAndSendTransaction) {
        try {
          const { signers, ...sendOptions } = options;
          transaction = await this.prepareTransaction(transaction, connection, sendOptions);
          (signers == null ? void 0 : signers.length) && transaction.partialSign(...signers);
          sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
          const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);
          return signature;
        } catch (error) {
          if (error instanceof WalletError)
            throw error;
          throw new WalletSendTransactionError(error == null ? void 0 : error.message, error);
        }
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
    return await super.sendTransaction(transaction, connection, options);
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signature } = await wallet.signMessage(message);
        return signature;
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-salmon/lib/esm/adapter.js
init_index_browser_esm();
var SalmonWalletName = "Salmon";
var SalmonWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor({ network = WalletAdapterNetwork.Mainnet } = {}) {
    super();
    this.name = SalmonWalletName;
    this.url = "https://salmonwallet.io";
    this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB3aWR0aD0iODgiIGhlaWdodD0iODgiIHZpZXdCb3g9IjAgMCA4OCA4OCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9Ijg4IiBoZWlnaHQ9Ijg4IiByeD0iMzAiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl84NTVfNTgwKSIvPgo8cGF0aCBkPSJNNTkuODA1NSAyNy42M0M1Ni43OTU1IDI1LjgyMzkgNTMuNjIyMiAyNC41Mzg4IDUwLjM1OTcgMjMuODE0NEw0Ni45MDQyIDE2LjEyODdDNDYuNDkzMyAxNC44NTg1IDQ1LjMwMDIgMTQuMDAwMSA0My45NTM3IDE0LjAwMDFINDMuODE1QzQyLjQ2ODUgMTQuMDAwMSA0MS4yNzU0IDE0Ljg2MzUgNDAuODY0NSAxNi4xMjg3TDM3LjQwOSAyMy44MDk1QzM0LjE0MTYgMjQuNTM4OCAzMC45NTgzIDI1LjgyODkgMjcuOTQzNCAyNy42MzQ5QzIxLjk1MzIgMzkuMjYwMyAyMC4zMjk0IDUwLjU5MjggMjEuMTQxMyA2MS43NjY2QzI0LjY1MTMgNjUuMTY1NCAzMi40MzM2IDY5LjM2OCAzNi42MDcgNzEuMDMwMkMzOS4wNTI2IDcyLjAwMjcgMzkuODAwMSA3Mi40OTM5IDQyLjI1MDYgNzIuOTAwN0M0NC40Mjg5IDczLjUxNiA0NS4wODczIDczLjI3NzggNDYuNzU1NyA3My4xMDQyQzQ5LjMyNTEgNzIuNDE5NSA1MC4zOTQ0IDcxLjcyNDggNTEuNDM0IDcxLjE2NDFDNTUuODQ5OSA2OC44NzY4IDYzLjExNzQgNjUuMTcwNCA2Ni42Mjc0IDYxLjc3MTZDNjcuNTc3OSA0OC44MTE2IDY0Ljk5ODYgMzcuNTgzMiA1OS44MDU1IDI3LjYyNVYyNy42M1pNMzcuNTI3OCA1MS4xNDg1QzM1LjY0MTYgNTEuMTQ4NSAzNC4wODIyIDQ4LjkwMDkgMzQuMDgyMiA0Ni4xMzIyQzM0LjA4MjIgNDMuMzYzNiAzNS41ODcxIDQxLjA5NjEgMzcuNTE3OSA0MS4wOTYxQzM5LjQ0ODYgNDEuMDk2MSA0MC45OTgxIDQzLjM2MzYgNDAuOTYzNSA0Ni4xMzIyQzQwLjkyODggNDguOTAwOSAzOS40NDM3IDUxLjE0ODUgMzcuNTIyOCA1MS4xNDg1SDM3LjUyNzhaTTUwLjIzMSA1MS4xNDg1QzQ4LjMzOTkgNTEuMTQ4NSA0Ni43OTAzIDQ4LjkwMDkgNDYuNzkwMyA0Ni4xMzIyQzQ2Ljc5MDMgNDMuMzYzNiA0OC4yOTUzIDQxLjA5NjEgNTAuMjMxIDQxLjA5NjFDNTIuMTY2NyA0MS4wOTYxIDUzLjcwMTQgNDMuMzYzNiA1My42NjY3IDQ2LjEzMjJDNTMuNjMyMSA0OC45MDA5IDUyLjE1MTggNTEuMTQ4NSA1MC4yMzEgNTEuMTQ4NVoiIGZpbGw9IiNGQ0ZDRkMiLz4KPHBhdGggZD0iTTc1LjQwNTEgNTYuMTIwM0w3MC45NzkzIDQyLjE3MjlDNzAuNDM0NyA0MC40NjYxIDY4Ljg1NTUgMzkuMzA1MSA2Ny4wNjMzIDM5LjMwNTFDNjYuNTI4NyAzOS4zMDUxIDY2LjAwODkgMzkuNDA5MiA2NS41Mjg3IDM5LjYwMjhDNjcuNTQ4NSA0Ni4zMjU5IDY4LjM2MDQgNTMuNTc5OSA2Ny43MjY3IDYxLjQ4NEg3MS40ODQyQzc0LjI2NjUgNjEuNDg0IDc2LjI0MTcgNTguNzc0OSA3NS40MDAxIDU2LjEyMDNINzUuNDA1MVoiIGZpbGw9IiNGQ0ZDRkMiLz4KPHBhdGggZD0iTTEyLjE5MDggNTYuMzgzNUwxNi42MTY2IDQyLjQzNjFDMTcuMTYxMiA0MC43MjkyIDE4Ljc0MDUgMzkuNTY4MiAyMC41MzI2IDM5LjU2ODJDMjEuMDY3MiAzOS41NjgyIDIxLjU4NyAzOS42NzI0IDIyLjA2NzMgMzkuODY1OUMyMC4wNDc0IDQ2LjU4OSAxOS4yMzU1IDUzLjg0MzEgMTkuODY5MiA2MS43NDcxSDE2LjExMTdDMTMuMzI5NSA2MS43NDcxIDExLjM1NDIgNTkuMDM4IDEyLjE5NTggNTYuMzgzNUgxMi4xOTA4WiIgZmlsbD0iI0ZDRkNGQyIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzg1NV81ODAiIHgxPSI0NCIgeTE9IjAiIHgyPSI0NCIgeTI9Ijg4IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiNGRjgxNzAiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY1QzQ1Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjwvZGVmcz4KPC9zdmc+";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._network = network;
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        if (window.salmon) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    var _a2;
    return !!((_a2 = this._wallet) == null ? void 0 : _a2.connected);
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Loadable && this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      let SalmonClass;
      try {
        SalmonClass = (await import("./esm-L742EHLL.js")).default;
      } catch (error) {
        throw new WalletLoadError(error == null ? void 0 : error.message, error);
      }
      let wallet;
      try {
        wallet = new SalmonClass({ network: this._network });
      } catch (error) {
        throw new WalletConfigError(error == null ? void 0 : error.message, error);
      }
      if (!wallet.connected) {
        try {
          await wallet.connect();
        } catch (error) {
          throw new WalletConnectionError(error == null ? void 0 : error.message, error);
        }
      }
      if (!wallet.publicKey)
        throw new WalletAccountError();
      let publicKey;
      try {
        publicKey = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      wallet.on("disconnect", this._disconnected);
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.off("disconnect", this._disconnected);
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signMessage(message, "utf8");
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-sky/lib/esm/adapter.js
init_index_browser_esm();
var SkyWalletName = "SKY Wallet";
var SkyWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = SkyWalletName;
    this.url = "https://getsky.app";
    this.icon = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDY2IDY2IiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiPjxkZWZzPjxpbWFnZSAgd2lkdGg9IjY0IiBoZWlnaHQ9IjY0IiBpZD0iaW1nMSIgaHJlZj0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFFQUFBQUJBQ0FZQUFBQ3FhWEhlQUFBQUFYTlNSMElCMmNrc2Z3QUFFWGhKUkVGVWVKekZXd2x3RlZVVy9ZRUVRaEx5MTdCbGcwaEVrYzJFZ0d5akFoWUtLb2lvaUN3aUlpaWlvcWdnaTRBb0lBNmhCQUVabGtFREptSGZ3aFlNUzFCUjJVVUUwUUZucG5TbVpzWlNTNjJwS2JsenprdS84TkxwL2dSSndxODYxZjI3KzNmM3ZlOHU1OTczdnNkVGhaOTkrL1pGQXgwT0hEZ3c4cU9QUGxyd3lTZWZGSHo2NmFkSGdYOGRQbnhZamg0OVdvcGp4NDc5RXpnQ2JENSsvUGc4NEZFZ0M2aFZsZTlZcVorZE8zZDZkdTNhbGZEKysrL2ZzM2Z2M29VUS9PakJnd2QvZ09BWERoMDZKT0ZBaFJ3NWNrUXJReUQ0aFJNblRuei8yV2VmSFFMZUJPNEVBamgzdGNVcy95a29LUEJzMjdZdEZRcDR1YWlvNkFRRXZ3REJCU1A5dTZHVlFvVkFFUUxoTDV3OGVmSVFNQTVvaU85WFcyeVBaOU9tVFJHYk4yOU9nL0J6Q3dzTC93dkJCYU45UllLSFV3Z3RBNExMNTU5Ly9pdndHcEFFUkZ3VjRkZXRXeGNMQlV5RThQL1p2MzkvbFFudXBBaGFCYXhBVHAwNjlSMHdHcWhkYllMbjUrZEhyRm16cHQzR2pSdFB3OWZsNDQ4L3JoYkIzU3dDRmtCRkhBTmFBbFVyZkY1ZUhoVXdDV2IvWTNGeGNZVkgvWU1QUHBCbHk1YkpDeSs4SUE4OTlKRGNmZmZkMHFWTEY3bnBwcHNVdU4rN2QyOFpPSENnakI4L1hsYXNXQ0hJR2hXNk4rTUUzZUtMTDc3NEhuaXF5b1IvNzczM1FsREFTcGg4aFY0T0FWR21UWnNtUFh2MmxFYU5Hb25mNzVkQUlGQUtyOWNyb1ZCSWdmczhGZ3dHMVhWRWNuS3kzSFhYWFRKanhnelp2WHYzSlo5SGE0QUNMZ0NMQUc5bEM1K0lrVis5ZmZ2MnNOR2RGckZod3dZWk9YS2t0R3paVWhJU0VrcUZwWEJPd2pvcGhlZjBiK3JWcXlkdDJyU1IwYU5IQ3l3dnJOVXhOc0FOZmp0OSt2UnlLQ0ZRV2NMSDVPYm03dURJaC9OM3BEOTU4c2tuSlRVMVZiMDRFUjhmcjdZVXp1ZnpsUkdZNTdRRmNGOGY1M1dFcVJSOXY3UzBOSG51dWVlRTd1ZjJIdVFTbGhKeW9JU29LeFUrRHNJWFVIaTNrYWM3dlBIR0c1S1NrbEw2b3RxTTlVZzdtWHNnakFYbzY4cmR6L3JldEdsVG1UOS92dXVBV0VvUUtDRVhpUDVkd3E5Y3VaSUtXQWF6Y3pWNzBGd1Z1TFNnNWN5WUx3MFREalpzS0w0R0RjU1BXQkJNVEpRQTRNWDNFUHc4bEp5RS9mbzRobk5KU2VMRHRYNUFYWWZyZVYwd0tWR2Q4OWF2TDBIZWcxdTQxL0RISGhOeUR6Y2x3QUpvQ2JOL3o4aEhBSThqMTdzR3ZLMWJ0MHFuVHAxS0JlY0lxWDBDTHhob25Dcis2NitUbEU0ZHBYblBPNlJ0djN1bDNmMzlKS1B2UFdxLzdYMzNTdWE5ZlNXVCt4WXk4SjNYWk4zSDYvcXFiVnNnczE5ZkJWNlRpZDhuZGV3Z2dmU21Fb1RpdW5YdkpxRGZyakVCQ3JnQTNBOWxYSllDTWhEeGZ5VEJjYnJ4amgwN1ZHRFNKc3l0TWxtTXRpOGxXZnh0V3N2OVk1Nld4ZSt0a2kzSUJqdDNGOHB1Y0liM0t3Rzh6MVlJUEdMeVpBbEF3ZjU2Q1dvZzNONFZOWVdjT1hQbTMxQkNzNG9LVDc4L3pEVG1OdkkzM25oanFYOXFmdzQwYkNEZTY1cEpuMUZQeU5xdFcxVHFBbE5VV2FHeUFSSW1LTFprTUhoRjRKbzBDWVNDMHFGREIxZExJRm1DRW9xZ2hQQ01FY0xYQUo3bFE1ejhuZy90MkxGamFkRFNaay8vam9Qd1kxK2ZoZEd1T3NIdFNzaUJpeVpsdFZWeGh1L1RyVnMzeHd4aHhRTzZ3eU9BZSswQTRhL0Y2SDlEUVoyaVBWbWNFaGhwU2xrQW96VlFCNlB3L096WDFhaFh0ZUFtQ3ZjVVNhdmJlMGdBQTZEZmFjU0lFWTdaZ1JVbHJPQVVGSkRrSmp5UnpkRnpNaU9tT2pPWGN4c0h2NDlxMUVENlAvZXM4cy9xRkY0QjZia0pncXlmbWNZYUdMN2JnZ1VMeXIwL2F3ZkxDbDZHSXB4SEg0SHY3MDZqejVGbDBDdERYUERBNkdCQWtycDBrbUp3Zlpwa2RRcFBiakp4YnJZa0lCQUdrQkpORHNINndpa29NaUJDQVY4Q0RaMFVNSk9qNzBRMVNXMDFPZEYrejlHdjBhaWh2RFJuam16WnN1V1Mva29heSt1dUZBekNaSjEveXN1VnhQYnR3QTNxbGZJUXpTSkp3Y2VPSGV0b0JTQklUSXZqbklMZjF6UmpwOEJIZXF0OVRDc2lLaTVPNWVOdGhZVmhoZWM5VitPbFIwMmZKbzlPbmlURHJ4QkR4bytUTGdNZWxIcXRXNVVRSzd5UG5UTHpYZFBUMHgwNWpCVUxqdGdWMEd2dDJyV09QeGcyYkZnWm5xNGZGZ0hjK2Rod1Y5L25xQmZDZFI1QWZJaEt2MFpxZ2h4RkltZlh4T2h3V3dPcGk5dElqS0RlVitjU1NyWVhyd3VWWEFjLzV6WVdqTkVMcGhpdytiMm15MllkTVdiTUdNZU1ZSkdqVEZNQkt3b0tDc3FaLzU0OWUrVDY2Njh2SXp3ZldpY21Sang0NmFlbnZ5TDhuYU9QYnQ4dTB4Y3VFQjk4MUVlQ0ZNQUw4ajcra3EyWDk3T1lZenlEcTNWT3cydGN4NjM1Rzc4bHNGbEhhQXNOR09jWXQreHBrVzVBWGdBRlpHdmhvNEZUOUN1N3R1YkF2ODJINkJ0SDE2a2pIdERRYWZQbktkOTJVc0FPa0pMdVF4K1dJSmloejRvYjloR3ozN2VVVGhzQzJhOXpPdWEwSmVpdVM1WXNjUXVHbnlJcjFLUUNya1B1LzlYSi9HKysrZWFMMVp0aEJiVnExeFlQbU4rckM5NXlKVDFiUVpmYjN0TUhETEZoR2VzeDcyY1h3aHhGOHpwdDNsb0Jaay9CTkhtN0FuaU9UUlVYTi9nQkNraW1BZ2JULzUwcVBVWlQrNGdRVWJWcWlRZStPM0hPSDEwendDNEV4MzVQajVaZ2s4WXFVSm5sY1VVNlF1WjFadkMxbDhqNnV6MEk2dnV4RzJWbnRSWW5ZUGVvaHljbkoyYzV6WmpzeVFSN2VQYVgwemVPam80V0QzejZFVVJrRmtaT0NxQmljdGF2azRZZDJvc1hwV3dJRmhNQ1kvTnlkQmpBRUJUOTdCaFJ5YXdlY2N4TFFlRmFJWHpudmpvSGFKKzNDOHYzTTRYVlFUQmtaUVk5YVBuNStlWGtZelpBTEpqcFdiNTgrWDZhTVVmY3hJUUpFeHlEREtFVUVCY3JIVkNxTWsyNnBVQXFaMEZPanZ3QmFTc1ZqQzI1WFpZa0kzY250MnNuamRwbVN1cE43U1VGNEQ2UHB3Qkp1SWI4bnRjMnVMR04rSzVObDJCYWs1SitnR0ZCZGtzeDM4K3VsRm16WnBXVGowcEF1YnpKczNEaHdxL3BBdHNSdFUwTUdqVEkxUUxJQkNQZ0JyNldMV1RWaHZVcTVibUJXV0l2V0ZudXBvM3lMb3FYZC9Bc2J0OWRwN2NYOXkrZVd5Y3IxcXlSSmJtNU12UHRSVEpzd2t2U3VsZFBWZjRHazVOVmhqQ3R3VzRCZGpkanE4NHVINE0rNHQ1aER5TDlqeXRYcmhRcXdjU3R0OTVhSnFDWVprY0YxSXlNRkErK0QzeCtyTklveStlcUF0TXgyOTl6VjZ5UXJINTlKUUNyOElFVDJHT0YyVkExQjYxUG56N2w1S1BiNDc3ZmVkaDJYcnAwcVNBV2xFRldWcGFqQmVpSHhzVEdpZ2V1VUFkbDhPNERKWE1FZGorcmJEQjRuVGg1VWg2Wk9FRVNZSDBoVUhGdm1CaWdsZEsrZmZ0eThpSHpLVXZ3VEpreVJlQUdLbCthMEIwZmU0b3lGUkVaRlNXZStMcHl3NTI5NUlzdnY1U3paODlXQzg2ZlB5K3ZMbjViUWkxYXFGTFlMUWJvV0VGWjdQSng4b1V1NnBrOGViTHFzQzVldkxnTStDTTdjZEg3ZWh1SGVxQUdsWkFRa3B1SERKTHozM3lqWHZCTEtLT3FjZTdjT1hucXRWZkZEODdQYkdGeUJmdWdzWU5sbDQ5WmJ2MzY5ZUtaT25XcUxGcTBTQjB3a1pHUlVZNVkyQ2MwVkU4QVNtQkFKRFhPNm5ldjdFQTg0Q3hOVmJzRTczOEloT2EyaDRkSUlEV2xITGt5MzcwZHNvNWR2bmZlZWFmRUFwQWlma0lxRkJDaU1tQVFkTHFaMlJIUzU2aUVtbVNIZnAvVVIvcDZjZlpzMlZxNFM0b1BIRkRGVWlGSUVmdDFsNHRMQlVmMktSYkNuK3UxYVMwK3krK2RCbzN6am5iNTFpRExiTnUyN1Z2UHZIbnp6dkVBbzZLSi92Mzd1L0p1T3pmbmZ0MjZkYVUyYW9TSTJCaFZKNUFBOVIvempMenkxbnhabXBjbmVlQWFhMUVXczJHNmh0aFNndFZiTmdONkMrRForWnRMamhYQm1oaW93cVZaOWlDN3dmMDRkK0JtQVd5VDJlVWpSMEVXT09wQlFOaEhYMkJlTk1GWldwTzZta0hHY2RiR2VtZ3Nza01kSUJLSThJSXZnT0Y1OEhJZW1LbW5jV29aUkZpNHVKK2k0Q0dhcEVwMHE1WXlQbnVPS3F6Y09rNVUwTVRzYlBFMkxxSGNUa1NJbWM0dUgyZXM0VW9iU1lXWDhlYmt5eWFZR3UxcDBPd0k2YmtBblh2MVBLRFptVkhYWUJzREYvSHhPQnVvc0pSNEhtZFh5ZWVWdWpoUGhzZGpNYmdIcjRuSDkwaXlUWlRkRWFnbW41ZzZSYm1Fa3dMSVlwZmw1MG13eFEwbHo3QVJJZTdud1FMdDhsbHJrV2F5R0JwQ2Y3RDNBa2h1ekZFMml4Y3RyT2JpNWtQMXBLZVRVa3lYNFRrV1d3VGRSNWV2NXYzcXNPd0dHRmZXdS9RZE9IaWJZQVh4VUFCckRYUFF1TjhBeDV5S0lhNDVRajF3dXlxSGdWOC8vUEREY2hYaExiZmNVcTd3c1BOdiszUjJ5S3I4N01VTGp5ZFl6Y3R3bFIrdk1mdVBOWkJoSXVFZWI2NzRzM3Q3SENZZHpNeFF4Wlc5R0hJcWg2MUZGVDlBQWFvY3JnT2NjZW9Ic29pdzl3THNOYjA5OTVwVDR2WmVnbm1kM2FMY3Jxc0pDNGhERFVBemQ3T0FIUWlFM3RZdDFWeWgrWDY4TjBtZTA1d2hoRDl5L1BqeFNOMFZXc1Z1cTkwTnFCUTJGKzFLY0dwZ3FIMUw4MzZUTjFpV0V3eFpOWDFwSzh5NnhtcHhCYlQvMHFMNEd6NUQ5UVpEMGhuVjVPNGk5OTVqL3VaTjRnYzE5aHZsTWRFQ1ROR3BQVzZ0UTV4djlnVDdyRjY5V3B6Y1lQRGd3ZVVzb0F6VnBBQ3M3Vkd1Qm1HcVhsUnJiSUlFRUpXNXo2MGZ4MzBrSzV3eFRrMVZXeStDbXlwekFmTTZubGZBOXhpY1MrOXhtNm9XM1ZwdjdEdGtMMXNxUHM0V0c2YlA3YWhSb3h6Tm40c3dvWVNPcGdKcUFuOTFXb3RERXBORTRXeWNnQ1BJR1puQU5kZElzKzdkNUo0blI4blFsOGJMTUJRcWJGMC9iTzBQUlNuTDc5d2ZObWtpam8rVFIzRHNVZXp6ZXA1bnU3dmsydkdsN1crZW16QTNXL1pnQk4yRVYvNlA5Mk81SEtCaURjdmphaEtudFFNMGZ5amc1SkVqWlR2amFscU1OM1NhR0JrNmRHZ1p2MVQ3TU9rWWpDSWJuMFg3OTZrMHhkbWFpb0E5Z29vZ25PRGEvTmZCZGROdStZT3lRdE05MlFOd21oaWgrVU1KTHp2TkRMVkFpZmdQcCs0d3lRYjl5UXlDdGJIZnFsZFBLZHE3dDlxbnhUUm9zU05mbnF3V1M1aWQ1OHpNVE5WRGNHcUdRdmh6MktZNktZQ3JRaGFRRlRwWndmVHAweTkyaEtBQUZqL1B2RHBkamVqVkVKNit2eFNaSVJFY3djOWxORVphelFZenRMKy9ObjhJUHdOeG9QemtxTFlDNEZ1bldFRHF5TTRLSTdscWk5ZXZKNitFbVJlb1NqQmpyZCsrVFpyZDFsMkNLU2txZzJnZXdsYWUwOW9Hamo3d0ZZUlBjNWIrWWpDYzREWk5Sc1d3VEs1TkJTQUlqa1N3Y3VzS1Z3VlV6c2Z6MkMvTTZIMjN5alkrbzB6bjRnMHlXQ2ZmcHdJZy9DZ2cvT0pxS01EUG1TSnEyY21NdUhDS0VaWThQYjNyclZKUTZGNm9WS2JnYWxZWThXWWFxa3RPeXZxNUZpbDRjWmtPR3podTcwemhvWVNEUUd4WTRRMGxkQVIrZGdxSUJGOHFDYWJud1lNeit2U1dkWWpZYWdFVExLUXl3WHZ1Z0lKWklsUHd0RzVkeGQrc21YZzVyMkJNcWpEb3VTMm5aZDdIbG4vYWFGVWg0UzBGTUNDK3lBa0Z0M1Y0SkU1TjhUSWVWSFJzakRhN3ZZZTBlK0IrYVUvMHYzTHdYczN2N0NXTk9uV1VXRkRoZUZoZFBGT2ROVnVsQTE3bnpwMWRSNTZtenkxaXduQ1V2cGYzdjRKVnExWlJDV3RZS1RveFJFMlM3dWpaVTZKUjd0WkM3Yy9VV012dlUxc2lDbG1qZHBESC9GSXI0TGZPbDJ5anpPdlV2dDg2VjNLZXEwL3FjbGFaWklzelNKYXBteDJwQVFNR2lOT0tGZ01YRU12ZXhpQmVsdXltSmZpQS9VeU5ia3BnZG1CbnVZSFZuZFZ0YXI5QlNjMjFSZWF4MG1yUnZNNmxBV3ZXOTJTbU0yZk9ETHRxblgzRDR1TGlBZ2hmTWIrL2hCS0t3eW1CWUhUbVlvckV4TVF5ZlFTemQyanVtK1d5S2FUOWV2TTZya2QrL1BISHhhbHl0UWwvQVVYUVJsaEh6QlVKYnlnaERTaWdFdHhpZ3RZNlhFZmw0bWFJRDA2bGRMajFBZmJxVXYrbWVmUG1Tcm1NTzVmNmt3YXNnc0xuUS9qNmxTSzhvWVJHd0JiR2hFdjRuUUpiVmVQR2pWTnJEUFQvQm9KRzJxTFF1cGxpbnpvbitEOEJMbnljTkdtU3Fnc3U5VHdxNWtCSkZ6b1hDRldxOFBwakJjWnMxQXkvc0Q2bzZOOWFhTEt6Wjg5VzNWbitYYVpyMTY1cXNxSlZxMWJTdW5WcnRVOWh5VFJwNHFTeUZWR3lNZXBzZFA2MGMrZk9xWERGS3BHOTlHT2x5QjdBMzBpS0x1ZEY3U05tVG5MOG5udnd0MlIrRVBvcjFDU2RnZXI3QzUzRkdHY0RQNUtwVmVkZjV5ZzRGUStCdjBjdE1nV0ZVVnkxQ1c1VEF0Y1gzZ0Rrd0MxK295SllobGFWSW1qcWRDY0kvRDg4YXpFWWFUcFE0Nm9JYjFORWhLV0lPY0EzREpRTVhGUkdSZU9FMjBnenNKSG1zdnlGeTUzRnZWOUROa2pIOW1xTDdmeXhyS0lQRzYzc05uTUZHcXRMS29TQzBIUXBGRGtGbGFOQlFrVTNZdjNCZVQrVzJSRHlsN3k4dkZOY3h3amNRVVZmYmZrdTYyTzEzRG52TUFSWUFod0F6a0VwUDNPMnhnU08vUVQ4QmVmM0FXOEREd0xwWE1kWWxlLzRmLzRNQmw2a1JRUjRBQUFBQUVsRlRrU3VRbUNDIi8+PC9kZWZzPjxzdHlsZT48L3N0eWxlPjx1c2UgIGhyZWY9IiNpbWcxIiB4PSIxIiB5PSIxIi8+PC9zdmc+";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2;
        if ((_a2 = window.skySolana) == null ? void 0 : _a2.isSkyWallet) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    var _a2;
    return !!((_a2 = this._wallet) == null ? void 0 : _a2.isConnected);
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.skySolana;
      try {
        await wallet.connect();
      } catch (error) {
        throw new WalletConnectionError(error == null ? void 0 : error.message, error);
      }
      if (!wallet.publicKey)
        throw new WalletAccountError();
      let publicKey;
      try {
        publicKey = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      wallet.on("disconnect", this._disconnected);
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.off("disconnect", this._disconnected);
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async sendTransaction(transaction, connection, options = {}) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signers, ...sendOptions } = options;
        transaction = await this.prepareTransaction(transaction, connection, sendOptions);
        (signers == null ? void 0 : signers.length) && transaction.partialSign(...signers);
        sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
        const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);
        return signature;
      } catch (error) {
        if (error instanceof WalletError)
          throw error;
        throw new WalletSendTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signature } = await wallet.signMessage(message);
        return signature;
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-solflare/lib/esm/adapter.js
init_index_browser_esm();

// node_modules/@solana/wallet-adapter-solflare/lib/esm/metamask/icon.js
var icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjMxIiB2aWV3Qm94PSIwIDAgMzEgMzEiIHdpZHRoPSIzMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIwLjI1IiB4Mj0iMjYuNTcxIiB5MT0iMjcuMTczIiB5Mj0iMTkuODU4Ij48c3RvcCBvZmZzZXQ9Ii4wOCIgc3RvcC1jb2xvcj0iIzk5NDVmZiIvPjxzdG9wIG9mZnNldD0iLjMiIHN0b3AtY29sb3I9IiM4NzUyZjMiLz48c3RvcCBvZmZzZXQ9Ii41IiBzdG9wLWNvbG9yPSIjNTQ5N2Q1Ii8+PHN0b3Agb2Zmc2V0PSIuNiIgc3RvcC1jb2xvcj0iIzQzYjRjYSIvPjxzdG9wIG9mZnNldD0iLjcyIiBzdG9wLWNvbG9yPSIjMjhlMGI5Ii8+PHN0b3Agb2Zmc2V0PSIuOTciIHN0b3AtY29sb3I9IiMxOWZiOWIiLz48L2xpbmVhckdyYWRpZW50PjxnIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iLjA5NCI+PHBhdGggZD0ibTI2LjEwOSAzLjY0My05LjM2OSA2Ljk1OSAxLjczMy00LjEwNSA3LjYzNy0yLjg1M3oiIGZpbGw9IiNlMjc2MWIiIHN0cm9rZT0iI2UyNzYxYiIvPjxnIGZpbGw9IiNlNDc2MWIiIHN0cm9rZT0iI2U0NzYxYiI+PHBhdGggZD0ibTQuNDgxIDMuNjQzIDkuMjk0IDcuMDI0LTEuNjQ4LTQuMTcxem0xOC4yNTggMTYuMTMtMi40OTUgMy44MjMgNS4zMzkgMS40NjkgMS41MzUtNS4yMDctNC4zNzgtLjA4NXptLTE5LjI0Ny4wODUgMS41MjUgNS4yMDcgNS4zMzktMS40NjktMi40OTUtMy44MjN6Ii8+PHBhdGggZD0ibTEwLjA1NSAxMy4zMTMtMS40ODggMi4yNTEgNS4zMDEuMjM1LS4xODgtNS42OTd6bTEwLjQ4IDAtMy42NzItMy4yNzctLjEyMiA1Ljc2MyA1LjI5Mi0uMjM1LTEuNDk3LTIuMjUxem0tMTAuMTc4IDEwLjI4MyAzLjE4My0xLjU1NC0yLjc0OS0yLjE0Ny0uNDMzIDMuNzAxem02LjY5NS0xLjU1NCAzLjE5MiAxLjU1NC0uNDQzLTMuNzAxeiIvPjwvZz48cGF0aCBkPSJtMjAuMjQ0IDIzLjU5Ni0zLjE5Mi0xLjU1NC4yNTQgMi4wODEtLjAyOC44NzZ6bS05Ljg4NyAwIDIuOTY2IDEuNDAzLS4wMTktLjg3Ni4yMzUtMi4wODEtMy4xODMgMS41NTR6IiBmaWxsPSIjZDdjMWIzIiBzdHJva2U9IiNkN2MxYjMiLz48cGF0aCBkPSJtMTMuMzY5IDE4LjUyMS0yLjY1NS0uNzgxIDEuODc0LS44NTd6bTMuODUxIDAgLjc4MS0xLjYzOCAxLjg4My44NTctMi42NjUuNzgxeiIgZmlsbD0iIzIzMzQ0NyIgc3Ryb2tlPSIjMjMzNDQ3Ii8+PHBhdGggZD0ibTEwLjM1NyAyMy41OTYuNDUyLTMuODIzLTIuOTQ3LjA4NXptOS40MzUtMy44MjMuNDUyIDMuODIzIDIuNDk1LTMuNzM4em0yLjI0MS00LjIwOS01LjI5Mi4yMzUuNDkgMi43MjEuNzgyLTEuNjM4IDEuODgzLjg1N3ptLTExLjMxOCAyLjE3NSAxLjg4My0uODU3Ljc3MiAxLjYzOC40OTktMi43MjEtNS4zMDEtLjIzNXoiIGZpbGw9IiNjZDYxMTYiIHN0cm9rZT0iI2NkNjExNiIvPjxwYXRoIGQ9Im04LjU2NyAxNS41NjQgMi4yMjIgNC4zMzEtLjA3NS0yLjE1NnptMTEuMzI4IDIuMTc1LS4wOTQgMi4xNTYgMi4yMzItNC4zMzEtMi4xMzcgMi4xNzV6bS02LjAyNi0xLjk0LS40OTkgMi43MjEuNjIxIDMuMjExLjE0MS00LjIyOC0uMjY0LTEuNzA0em0yLjg3MiAwLS4yNTQgMS42OTUuMTEzIDQuMjM3LjYzMS0zLjIxMXoiIGZpbGw9IiNlNDc1MWYiIHN0cm9rZT0iI2U0NzUxZiIvPjxwYXRoIGQ9Im0xNy4yMyAxOC41Mi0uNjMxIDMuMjExLjQ1Mi4zMTEgMi43NS0yLjE0Ny4wOTQtMi4xNTZ6bS02LjUxNi0uNzgxLjA3NSAyLjE1NiAyLjc1IDIuMTQ3LjQ1Mi0uMzExLS42MjItMy4yMTF6IiBmaWxsPSIjZjY4NTFiIiBzdHJva2U9IiNmNjg1MWIiLz48cGF0aCBkPSJtMTcuMjc3IDI0Ljk5OS4wMjgtLjg3Ni0uMjM1LS4yMDdoLTMuNTVsLS4yMTcuMjA3LjAxOS44NzYtMi45NjYtMS40MDMgMS4wMzYuODQ4IDIuMSAxLjQ1OWgzLjYwNmwyLjEwOS0xLjQ1OSAxLjAzNi0uODQ4eiIgZmlsbD0iI2MwYWQ5ZSIgc3Ryb2tlPSIjYzBhZDllIi8+PHBhdGggZD0ibTE3LjA1MSAyMi4wNDItLjQ1Mi0uMzExaC0yLjYwOGwtLjQ1Mi4zMTEtLjIzNSAyLjA4MS4yMTctLjIwN2gzLjU1bC4yMzUuMjA3LS4yNTQtMi4wODF6IiBmaWxsPSIjMTYxNjE2IiBzdHJva2U9IiMxNjE2MTYiLz48cGF0aCBkPSJtMjYuNTA1IDExLjA1My44LTMuODQyLTEuMTk2LTMuNTY5LTkuMDU4IDYuNzIzIDMuNDg0IDIuOTQ3IDQuOTI1IDEuNDQxIDEuMDkyLTEuMjcxLS40NzEtLjMzOS43NTMtLjY4Ny0uNTg0LS40NTIuNzUzLS41NzQtLjQ5OS0uMzc3em0tMjMuMjExLTMuODQxLjggMy44NDItLjUwOC4zNzcuNzUzLjU3NC0uNTc0LjQ1Mi43NTMuNjg3LS40NzEuMzM5IDEuMDgzIDEuMjcxIDQuOTI1LTEuNDQxIDMuNDg0LTIuOTQ3LTkuMDU5LTYuNzIzeiIgZmlsbD0iIzc2M2QxNiIgc3Ryb2tlPSIjNzYzZDE2Ii8+PHBhdGggZD0ibTI1LjQ2IDE0Ljc1NC00LjkyNS0xLjQ0MSAxLjQ5NyAyLjI1MS0yLjIzMiA0LjMzMSAyLjkzOC0uMDM4aDQuMzc4bC0xLjY1Ny01LjEwNHptLTE1LjQwNS0xLjQ0MS00LjkyNSAxLjQ0MS0xLjYzOCA1LjEwNGg0LjM2OWwyLjkyOC4wMzgtMi4yMjItNC4zMzEgMS40ODgtMi4yNTF6bTYuNjg1IDIuNDg2LjMxMS01LjQzMyAxLjQzMS0zLjg3aC02LjM1NmwxLjQxMyAzLjg3LjMyOSA1LjQzMy4xMTMgMS43MTQuMDA5IDQuMjE5aDIuNjFsLjAxOS00LjIxOS4xMjItMS43MTR6IiBmaWxsPSIjZjY4NTFiIiBzdHJva2U9IiNmNjg1MWIiLz48L2c+PGNpcmNsZSBjeD0iMjMuNSIgY3k9IjIzLjUiIGZpbGw9IiMwMDAiIHI9IjYuNSIvPjxwYXRoIGQ9Im0yNy40NzMgMjUuNTQ1LTEuMzEgMS4zNjhjLS4wMjkuMDMtLjA2My4wNTMtLjEwMS4wN2EuMzEuMzEgMCAwIDEgLS4xMjEuMDI0aC02LjIwOWMtLjAzIDAtLjA1OS0uMDA4LS4wODMtLjAyNGEuMTUuMTUgMCAwIDEgLS4wNTYtLjA2NWMtLjAxMi0uMDI2LS4wMTUtLjA1Ni0uMDEtLjA4NHMuMDE4LS4wNTUuMDM5LS4wNzZsMS4zMTEtMS4zNjhjLjAyOC0uMDMuMDYzLS4wNTMuMTAxLS4wNjlhLjMxLjMxIDAgMCAxIC4xMjEtLjAyNWg2LjIwOGMuMDMgMCAuMDU5LjAwOC4wODMuMDI0YS4xNS4xNSAwIDAgMSAuMDU2LjA2NWMuMDEyLjAyNi4wMTUuMDU2LjAxLjA4NHMtLjAxOC4wNTUtLjAzOS4wNzZ6bS0xLjMxLTIuNzU2Yy0uMDI5LS4wMy0uMDYzLS4wNTMtLjEwMS0uMDdhLjMxLjMxIDAgMCAwIC0uMTIxLS4wMjRoLTYuMjA5Yy0uMDMgMC0uMDU5LjAwOC0uMDgzLjAyNHMtLjA0NC4wMzgtLjA1Ni4wNjUtLjAxNS4wNTYtLjAxLjA4NC4wMTguMDU1LjAzOS4wNzZsMS4zMTEgMS4zNjhjLjAyOC4wMy4wNjMuMDUzLjEwMS4wNjlhLjMxLjMxIDAgMCAwIC4xMjEuMDI1aDYuMjA4Yy4wMyAwIC4wNTktLjAwOC4wODMtLjAyNGEuMTUuMTUgMCAwIDAgLjA1Ni0uMDY1Yy4wMTItLjAyNi4wMTUtLjA1Ni4wMS0uMDg0cy0uMDE4LS4wNTUtLjAzOS0uMDc2em0tNi40MzEtLjk4M2g2LjIwOWEuMzEuMzEgMCAwIDAgLjEyMS0uMDI0Yy4wMzgtLjAxNi4wNzMtLjA0LjEwMS0uMDdsMS4zMS0xLjM2OGMuMDItLjAyMS4wMzQtLjA0Ny4wMzktLjA3NnMuMDAxLS4wNTgtLjAxLS4wODRhLjE1LjE1IDAgMCAwIC0uMDU2LS4wNjVjLS4wMjUtLjAxNi0uMDU0LS4wMjQtLjA4My0uMDI0aC02LjIwOGEuMzEuMzEgMCAwIDAgLS4xMjEuMDI1Yy0uMDM4LjAxNi0uMDcyLjA0LS4xMDEuMDY5bC0xLjMxIDEuMzY4Yy0uMDIuMDIxLS4wMzQuMDQ3LS4wMzkuMDc2cy0uMDAxLjA1OC4wMS4wODQuMDMxLjA0OS4wNTYuMDY1LjA1NC4wMjQuMDgzLjAyNHoiIGZpbGw9InVybCgjYSkiLz48L3N2Zz4=";

// node_modules/@solana/wallet-adapter-solflare/lib/esm/metamask/wallet.js
var __classPrivateFieldGet = function(receiver, state, kind, f10) {
  if (kind === "a" && !f10) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f10 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f10 : kind === "a" ? f10.call(receiver) : f10 ? f10.value : state.get(receiver);
};
var __classPrivateFieldSet = function(receiver, state, value, kind, f10) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f10) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f10 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f10.call(receiver, value) : f10 ? f10.value = value : state.set(receiver, value), value;
};
var _SolflareMetaMaskWallet_instances;
var _SolflareMetaMaskWallet_listeners;
var _SolflareMetaMaskWallet_version;
var _SolflareMetaMaskWallet_name;
var _SolflareMetaMaskWallet_icon;
var _SolflareMetaMaskWallet_solflareMetaMask;
var _SolflareMetaMaskWallet_on;
var _SolflareMetaMaskWallet_emit;
var _SolflareMetaMaskWallet_off;
var _SolflareMetaMaskWallet_connect;
var _SolflareMetaMaskWallet_disconnect;
var _SolflareMetaMaskWallet_signAndSendTransaction;
var _SolflareMetaMaskWallet_signTransaction;
var _SolflareMetaMaskWallet_signMessage;
var SolflareMetaMaskWallet = class {
  constructor() {
    _SolflareMetaMaskWallet_instances.add(this);
    _SolflareMetaMaskWallet_listeners.set(this, {});
    _SolflareMetaMaskWallet_version.set(this, "1.0.0");
    _SolflareMetaMaskWallet_name.set(this, "MetaMask");
    _SolflareMetaMaskWallet_icon.set(this, icon);
    _SolflareMetaMaskWallet_solflareMetaMask.set(this, null);
    _SolflareMetaMaskWallet_on.set(this, (event, listener) => {
      var _a2;
      ((_a2 = __classPrivateFieldGet(this, _SolflareMetaMaskWallet_listeners, "f")[event]) == null ? void 0 : _a2.push(listener)) || (__classPrivateFieldGet(this, _SolflareMetaMaskWallet_listeners, "f")[event] = [listener]);
      return () => __classPrivateFieldGet(this, _SolflareMetaMaskWallet_instances, "m", _SolflareMetaMaskWallet_off).call(this, event, listener);
    });
    _SolflareMetaMaskWallet_connect.set(this, async () => {
      if (!__classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f")) {
        let SolflareMetaMaskClass;
        try {
          SolflareMetaMaskClass = (await import("./esm-CKD3OKWB.js")).default;
        } catch (error) {
          throw new Error("Unable to load Solflare MetaMask SDK");
        }
        __classPrivateFieldSet(this, _SolflareMetaMaskWallet_solflareMetaMask, new SolflareMetaMaskClass(), "f");
        __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").on("standard_change", (properties) => __classPrivateFieldGet(this, _SolflareMetaMaskWallet_instances, "m", _SolflareMetaMaskWallet_emit).call(this, "change", properties));
      }
      if (!this.accounts.length) {
        await __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").connect();
      }
      return { accounts: this.accounts };
    });
    _SolflareMetaMaskWallet_disconnect.set(this, async () => {
      if (!__classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f"))
        return;
      await __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").disconnect();
    });
    _SolflareMetaMaskWallet_signAndSendTransaction.set(this, async (...inputs) => {
      if (!__classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f"))
        throw new WalletNotConnectedError();
      return await __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").standardSignAndSendTransaction(...inputs);
    });
    _SolflareMetaMaskWallet_signTransaction.set(this, async (...inputs) => {
      if (!__classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f"))
        throw new WalletNotConnectedError();
      return await __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").standardSignTransaction(...inputs);
    });
    _SolflareMetaMaskWallet_signMessage.set(this, async (...inputs) => {
      if (!__classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f"))
        throw new WalletNotConnectedError();
      return await __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").standardSignMessage(...inputs);
    });
  }
  get version() {
    return __classPrivateFieldGet(this, _SolflareMetaMaskWallet_version, "f");
  }
  get name() {
    return __classPrivateFieldGet(this, _SolflareMetaMaskWallet_name, "f");
  }
  get icon() {
    return __classPrivateFieldGet(this, _SolflareMetaMaskWallet_icon, "f");
  }
  get chains() {
    return [SOLANA_MAINNET_CHAIN, SOLANA_DEVNET_CHAIN, SOLANA_TESTNET_CHAIN];
  }
  get features() {
    return {
      [StandardConnect]: {
        version: "1.0.0",
        connect: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_connect, "f")
      },
      [StandardDisconnect]: {
        version: "1.0.0",
        disconnect: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_disconnect, "f")
      },
      [StandardEvents]: {
        version: "1.0.0",
        on: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_on, "f")
      },
      [SolanaSignAndSendTransaction]: {
        version: "1.0.0",
        supportedTransactionVersions: ["legacy", 0],
        signAndSendTransaction: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_signAndSendTransaction, "f")
      },
      [SolanaSignTransaction]: {
        version: "1.0.0",
        supportedTransactionVersions: ["legacy", 0],
        signTransaction: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_signTransaction, "f")
      },
      [SolanaSignMessage]: {
        version: "1.0.0",
        signMessage: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_signMessage, "f")
      }
    };
  }
  get accounts() {
    return __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f") ? __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").standardAccounts : [];
  }
};
_SolflareMetaMaskWallet_listeners = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_version = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_name = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_icon = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_solflareMetaMask = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_on = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_connect = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_disconnect = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_signAndSendTransaction = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_signTransaction = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_signMessage = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_instances = /* @__PURE__ */ new WeakSet(), _SolflareMetaMaskWallet_emit = function _SolflareMetaMaskWallet_emit2(event, ...args) {
  var _a2;
  (_a2 = __classPrivateFieldGet(this, _SolflareMetaMaskWallet_listeners, "f")[event]) == null ? void 0 : _a2.forEach((listener) => listener.apply(null, args));
}, _SolflareMetaMaskWallet_off = function _SolflareMetaMaskWallet_off2(event, listener) {
  var _a2;
  __classPrivateFieldGet(this, _SolflareMetaMaskWallet_listeners, "f")[event] = (_a2 = __classPrivateFieldGet(this, _SolflareMetaMaskWallet_listeners, "f")[event]) == null ? void 0 : _a2.filter((existingListener) => listener !== existingListener);
};

// node_modules/@solana/wallet-adapter-solflare/lib/esm/metamask/detect.js
var registered = false;
function register() {
  if (registered)
    return;
  registerWallet(new SolflareMetaMaskWallet());
  registered = true;
}
async function detectAndRegisterSolflareMetaMaskWallet() {
  const id = "solflare-detect-metamask";
  function postMessage() {
    window.postMessage({
      target: "metamask-contentscript",
      data: {
        name: "metamask-provider",
        data: {
          id,
          jsonrpc: "2.0",
          method: "wallet_getSnaps"
        }
      }
    }, window.location.origin);
  }
  function onMessage(event) {
    var _a2, _b;
    const message = event.data;
    if ((message == null ? void 0 : message.target) === "metamask-inpage" && ((_a2 = message.data) == null ? void 0 : _a2.name) === "metamask-provider") {
      if (((_b = message.data.data) == null ? void 0 : _b.id) === id) {
        window.removeEventListener("message", onMessage);
        if (!message.data.data.error) {
          register();
        }
      } else {
        postMessage();
      }
    }
  }
  window.addEventListener("message", onMessage);
  window.setTimeout(() => window.removeEventListener("message", onMessage), 5e3);
  postMessage();
}

// node_modules/@solana/wallet-adapter-solflare/lib/esm/adapter.js
var SolflareWalletName = "Solflare";
var SolflareWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = SolflareWalletName;
    this.url = "https://solflare.com";
    this.icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjUwIiB2aWV3Qm94PSIwIDAgNTAgNTAiIHdpZHRoPSI1MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmMxMGIiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNmYjNmMmUiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI2LjQ3ODM1IiB4Mj0iMzQuOTEwNyIgeGxpbms6aHJlZj0iI2EiIHkxPSI3LjkyIiB5Mj0iMzMuNjU5MyIvPjxyYWRpYWxHcmFkaWVudCBpZD0iYyIgY3g9IjAiIGN5PSIwIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQuOTkyMTg4MzIgMTIuMDYzODc5NjMgLTEyLjE4MTEzNjU1IDUuMDQwNzEwNzQgMjIuNTIwMiAyMC42MTgzKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHI9IjEiIHhsaW5rOmhyZWY9IiNhIi8+PHBhdGggZD0ibTI1LjE3MDggNDcuOTEwNGMuNTI1IDAgLjk1MDcuNDIxLjk1MDcuOTQwM3MtLjQyNTcuOTQwMi0uOTUwNy45NDAyLS45NTA3LS40MjA5LS45NTA3LS45NDAyLjQyNTctLjk0MDMuOTUwNy0uOTQwM3ptLTEuMDMyOC00NC45MTU2NWMuNDY0Ni4wMzgzNi44Mzk4LjM5MDQuOTAyNy44NDY4MWwxLjEzMDcgOC4yMTU3NGMuMzc5OCAyLjcxNDMgMy42NTM1IDMuODkwNCA1LjY3NDMgMi4wNDU5bDExLjMyOTEtMTAuMzExNThjLjI3MzMtLjI0ODczLjY5ODktLjIzMTQ5Ljk1MDcuMDM4NTEuMjMwOS4yNDc3Mi4yMzc5LjYyNjk3LjAxNjEuODgyNzdsLTkuODc5MSAxMS4zOTU4Yy0xLjgxODcgMi4wOTQyLS40NzY4IDUuMzY0MyAyLjI5NTYgNS41OTc4bDguNzE2OC44NDAzYy40MzQxLjA0MTguNzUxNy40MjM0LjcwOTMuODUyNC0uMDM0OS4zNTM3LS4zMDc0LjYzOTUtLjY2MjguNjk0OWwtOS4xNTk0IDEuNDMwMmMtMi42NTkzLjM2MjUtMy44NjM2IDMuNTExNy0yLjEzMzkgNS41NTc2bDMuMjIgMy43OTYxYy4yNTk0LjMwNTguMjE4OC43NjE1LS4wOTA4IDEuMDE3OC0uMjYyMi4yMTcyLS42NDE5LjIyNTYtLjkxMzguMDIwM2wtMy45Njk0LTIuOTk3OGMtMi4xNDIxLTEuNjEwOS01LjIyOTctLjI0MTctNS40NTYxIDIuNDI0M2wtLjg3NDcgMTAuMzk3NmMtLjAzNjIuNDI5NS0uNDE3OC43NDg3LS44NTI1LjcxMy0uMzY5LS4wMzAzLS42NjcxLS4zMDk3LS43MTcxLS42NzIxbC0xLjM4NzEtMTAuMDQzN2MtLjM3MTctMi43MTQ0LTMuNjQ1NC0zLjg5MDQtNS42NzQzLTIuMDQ1OWwtMTIuMDUxOTUgMTAuOTc0Yy0uMjQ5NDcuMjI3MS0uNjM4MDkuMjExNC0uODY4LS4wMzUtLjIxMDk0LS4yMjYyLS4yMTczNS0uNTcyNC0uMDE0OTMtLjgwNmwxMC41MTgxOC0xMi4xMzg1YzEuODE4Ny0yLjA5NDIuNDg0OS01LjM2NDQtMi4yODc2LTUuNTk3OGwtOC43MTg3Mi0uODQwNWMtLjQzNDEzLS4wNDE4LS43NTE3Mi0uNDIzNS0uNzA5MzYtLjg1MjQuMDM0OTMtLjM1MzcuMzA3MzktLjYzOTQuNjYyNy0uNjk1bDkuMTUzMzgtMS40Mjk5YzIuNjU5NC0uMzYyNSAzLjg3MTgtMy41MTE3IDIuMTQyMS01LjU1NzZsLTIuMTkyLTIuNTg0MWMtLjMyMTctLjM3OTItLjI3MTMtLjk0NDMuMTEyNi0xLjI2MjEuMzI1My0uMjY5NC43OTYzLS4yNzk3IDEuMTMzNC0uMDI0OWwyLjY5MTggMi4wMzQ3YzIuMTQyMSAxLjYxMDkgNS4yMjk3LjI0MTcgNS40NTYxLTIuNDI0M2wuNzI0MS04LjU1OTk4Yy4wNDU3LS41NDA4LjUyNjUtLjk0MjU3IDEuMDczOS0uODk3Mzd6bS0yMy4xODczMyAyMC40Mzk2NWMuNTI1MDQgMCAuOTUwNjcuNDIxLjk1MDY3Ljk0MDNzLS40MjU2My45NDAzLS45NTA2Ny45NDAzYy0uNTI1MDQxIDAtLjk1MDY3LS40MjEtLjk1MDY3LS45NDAzcy40MjU2MjktLjk0MDMuOTUwNjctLjk0MDN6bTQ3LjY3OTczLS45NTQ3Yy41MjUgMCAuOTUwNy40MjEuOTUwNy45NDAzcy0uNDI1Ny45NDAyLS45NTA3Ljk0MDItLjk1MDctLjQyMDktLjk1MDctLjk0MDIuNDI1Ny0uOTQwMy45NTA3LS45NDAzem0tMjQuNjI5Ni0yMi40Nzk3Yy41MjUgMCAuOTUwNi40MjA5NzMuOTUwNi45NDAyNyAwIC41MTkzLS40MjU2Ljk0MDI3LS45NTA2Ljk0MDI3LS41MjUxIDAtLjk1MDctLjQyMDk3LS45NTA3LS45NDAyNyAwLS41MTkyOTcuNDI1Ni0uOTQwMjcuOTUwNy0uOTQwMjd6IiBmaWxsPSJ1cmwoI2IpIi8+PHBhdGggZD0ibTI0LjU3MSAzMi43NzkyYzQuOTU5NiAwIDguOTgwMi0zLjk3NjUgOC45ODAyLTguODgxOSAwLTQuOTA1My00LjAyMDYtOC44ODE5LTguOTgwMi04Ljg4MTlzLTguOTgwMiAzLjk3NjYtOC45ODAyIDguODgxOWMwIDQuOTA1NCA0LjAyMDYgOC44ODE5IDguOTgwMiA4Ljg4MTl6IiBmaWxsPSJ1cmwoI2MpIi8+PC9zdmc+";
    this.supportedTransactionVersions = /* @__PURE__ */ new Set(["legacy", 0]);
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._accountChanged = (newPublicKey) => {
      if (!newPublicKey)
        return;
      const publicKey = this._publicKey;
      if (!publicKey)
        return;
      try {
        newPublicKey = new PublicKey(newPublicKey.toBytes());
      } catch (error) {
        this.emit("error", new WalletPublicKeyError(error == null ? void 0 : error.message, error));
        return;
      }
      if (publicKey.equals(newPublicKey))
        return;
      this._publicKey = newPublicKey;
      this.emit("connect", newPublicKey);
    };
    this._connecting = false;
    this._publicKey = null;
    this._wallet = null;
    this._config = config;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2;
        if (((_a2 = window.solflare) == null ? void 0 : _a2.isSolflare) || window.SolflareApp) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
      detectAndRegisterSolflareMetaMaskWallet();
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    var _a2;
    return !!((_a2 = this._wallet) == null ? void 0 : _a2.connected);
  }
  get readyState() {
    return this._readyState;
  }
  async autoConnect() {
    if (!(this.readyState === WalletReadyState.Loadable && isIosAndRedirectable())) {
      await this.connect();
    }
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Loadable && this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      if (this.readyState === WalletReadyState.Loadable && isIosAndRedirectable()) {
        const url = encodeURIComponent(window.location.href);
        const ref = encodeURIComponent(window.location.origin);
        window.location.href = `https://solflare.com/ul/v1/browse/${url}?ref=${ref}`;
        return;
      }
      let SolflareClass;
      try {
        SolflareClass = (await import("./esm-GBGW3Z5J.js")).default;
      } catch (error) {
        throw new WalletLoadError(error == null ? void 0 : error.message, error);
      }
      let wallet;
      try {
        wallet = new SolflareClass({ network: this._config.network });
      } catch (error) {
        throw new WalletConfigError(error == null ? void 0 : error.message, error);
      }
      this._connecting = true;
      if (!wallet.connected) {
        try {
          await wallet.connect();
        } catch (error) {
          throw new WalletConnectionError(error == null ? void 0 : error.message, error);
        }
      }
      if (!wallet.publicKey)
        throw new WalletConnectionError();
      let publicKey;
      try {
        publicKey = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      wallet.on("disconnect", this._disconnected);
      wallet.on("accountChanged", this._accountChanged);
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.off("disconnect", this._disconnected);
      wallet.off("accountChanged", this._accountChanged);
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async sendTransaction(transaction, connection, options = {}) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signers, ...sendOptions } = options;
        if (isVersionedTransaction(transaction)) {
          (signers == null ? void 0 : signers.length) && transaction.sign(signers);
        } else {
          transaction = await this.prepareTransaction(transaction, connection, sendOptions);
          (signers == null ? void 0 : signers.length) && transaction.partialSign(...signers);
        }
        sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
        return await wallet.signAndSendTransaction(transaction, sendOptions);
      } catch (error) {
        if (error instanceof WalletError)
          throw error;
        throw new WalletSendTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signMessage(message, "utf8");
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-solong/lib/esm/adapter.js
init_index_browser_esm();
var SolongWalletName = "Solong";
var SolongWalletAdapter = class extends BaseSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = SolongWalletName;
    this.url = "https://solongwallet.io";
    this.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAGlklEQVR4Ae3bA5DsyhfH8TNr49r2/du2bdu2bdu2zcdNrm3b9toz533rvctUn3Umk9p01WfdvVW/6nROBxJVS1rSkpa0pCUtaUlLWtKSpl4VXos3GJ4sujQFuUKfWl+qT730arzB8Ex9YksKcgXjFOCVeIPhBYydB8mawQ+yiGC8n0EN6zAVcgXhpQjoq1DDdsyDAAB9Pwo1HMC9INk0FIM8Bt1Qh9WohQQCvD+BtEMdtmC8I7y5aIE67MV0SBwDvB3qsE/UHwMJIpC/QB1OYiLEEeCPoQ7nMRcSwwDrao3Zl8aTIEGEUYlL0IAMXuQOr66UvsegDm+ExDJAPNiafSg0AlyIbmjAWX1aQzEkiH6T0QkNaEdpnAN8NNRhPcSF9e9el2ebBhyAuNBvGtLQgIuQOAd4D6jDMRQbM3AmOqEBDfq0xjJIEP3GohkakEFVjAP0y401sAsLnAE+pb6EsC5AA9J4sHsG+kX0PQR1eFJ8AwTWQh0+DjFm4a1Qh2/AOoz/BHX4ZdwD/CDU4aioX2GUMW+AOnB2bqiBBDHe86EOTYw5GRKJwQ/ijUM91OGTxgysxSmowzeNw7j08m5DHX4l7Igg2TY0g9hbLBZ+f7oxC98CdWjDvYzD+MVQh07GfEQsZyDgVWA71OGvorfnQQCAcqaYUFZDHW6j/itAoB70GcergzqsEa0rhGTTEA7mP0koK4xdyeOMmvBBhJU2zsjPMw7lu9O3zShpXheHk4hhcZ4w26AOG4RSxDiUfwZ12KdPqy+FBDHeV6EOZxizIg6HsMGbiQ5jdjzBXRfeefGg3tgbv9BYC0fhZE7sjUMY9Pf9rdcI5XtQh39BjBA/C3VYnM0zcgiDek+GOhzh93mQoMs7kIxze/eMhnxIEOPNM9bcFtTEeAb6I419axu/m2CsgxU4Aw1A/UxIUM/bO/9+cVkDDd5x42x8N1iH8Taow0NhHcZLoQ5Pi/MMzDMW+DTu7g6vIY9AdkAdHmaUMyn6roA6PD22AeLB6DbWplHG7LubfY+kfiIkiH5T0AJ1uFtMA1xUzOc1UIclzvCeXF+o7DygDlvds29RgVVzYj+K4xhgEX4NdcjgecE++rSL+ZdLmIxRB77Ose7l4XPIQB3eF8M60C/n8++ghltE/QLIFfqUiyUE8kOoYSW7jmLIFXeN4X0NaajDDlG/NG6XswrxKdxu+G/weh27j3wCej9uN9zEOjc3sObl4S243XBLhDfWE0mAMQjwZfhxDng7pG/8Sj4/ER/Gd/BdfBhPRGW2A/wxNAfcBOnFCHwZZ6GGs/gqapMAb/QEnIT20Uk8IQkQeB7aof3UihcM9wDvhyboANHXv1+IdWBOB2hsIftto+iSPEif8aGPcjrA50GHyPMiOIT9B/N5apaMgQT8D2poxMdwt8s+hkao4X9ZDxBTIdHwy/h8AeqQxhMhAU9BB9ThPMqHTYCYjU6owy3uPstSfL4Z6uZPC+Mk8gOomz8DEg3vXshAHb4MMXwZarhXGDPwa739w2j48623BPAniOFPUMPsMAL8INTw9AgDrLZOCmjFPEjA3WD1aUJVGAG+CGr4ECRCy6GGg3iyaF0+n/PwFByEGpaJ+qkw1sB7QA3/hUTozdBetFymvXhTWGVMOc7bp36/FhKRamNW9dcxZmpZiI+32ad+vAQSoWejGzpAXXh22Fek3wY1rDD2kVnijR3ExYQMPgkJOUB/nFW0Is3vnw6JhlHX9a4N70Iq/ACBv0MNu7J9WxHw7jaA2deFOtw32zeVHtHLWvMN0dtSkOzwS3spYy7iH1hx2d/wYdyTvnkR3BdeQjjerVBDN14JyZIfQWH5RC7e1rw32npZV54LCc+SPD5/HgqYD3WW5+gTqt6X+rA4v0701hRkKF0+bL+HTM9Hgv/MHH60wyvHWigsafwA1ZAhMguLoL34kbDcQEI1uAH8mcbuxPHImf8i5EMGxqvER9EI7cUqVMTl0Y6HoxHaBzvxNkyC9EEe7oEv4Sy0D/YQ+IS4ver1JNT38z7sWnwbb8TT8Cg8Gs/Gu/Ar7EEXtI/2ud7Ni0GAYCbiJDQiazA57k9nTcdqaJb9UtSvitXbmjavCJ9AMzRkJ/B80boUJBLhDe7Nw1/QCR1i9fgKRg6HByzvjZ/hInQQMjiCT2PSMHxC1a/l8wvwGxyG9kEaW/EtPI4xiiE5JcLrd6PxcLwM78SH8EG8Fc/H/UUXVUByGh8SSYBJgEmASYCJJMAkwBi6A3xCqZhiBz8+AAAAAElFTkSuQmCC";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        if (window.solong) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    var _a2;
    return !!((_a2 = this._wallet) == null ? void 0 : _a2.currentAccount);
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.solong;
      let account;
      try {
        account = await wallet.selectAccount();
      } catch (error) {
        throw new WalletAccountError(error == null ? void 0 : error.message, error);
      }
      let publicKey;
      try {
        publicKey = new PublicKey(account);
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    if (this._wallet) {
      this._wallet = null;
      this._publicKey = null;
    }
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-spot/lib/esm/adapter.js
init_index_browser_esm();
var SpotWalletName = "Spot";
var SpotWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = SpotWalletName;
    this.url = "https://spot-wallet.com";
    this.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFYAAABWCAYAAABVVmH3AAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAVqADAAQAAAABAAAAVgAAAAA6XCzdAAAmhUlEQVR4Aa2dC8xmR3nf57yX79tdr9d3e218JQRwguKAcGMVtw0tqtQgimhap4oUxQ1JS6kaqZIVpVJFBVJviKYlEa6KQgIFkcShTiOD6AVCiG3VsY3bdc1N0GKvCWvA1/Xuer/L+779//7PPOfM++77re0kA/PNzDPPzJn5nec8Z86c86678qcIf2exGP+XY+WG2U65sXTltYtSrlE3lyteXBbloNKD3bxMu65MulkZS1bG81I60lnkRzV1ebeUicoj6UzJK1ouGeVxldFmgzxtV9Js4zrVU57MFrUfpeo7jk1+oWMtZpOy2O3mi51JmZ0YL7rny2L21HgxOzYu3WOjbvE1jeeBS99y3pFbbtEsXmboXo7+9NuLm2az8m7xeZvanb9nWykAc6REgCOvMnlPsE4SUBPlDbmCCiADOJepU1wCuwO4kAMs25FyjCivgBXQMbAXgJ0r5WQq1WDHi7lOPDLVqTwqtVwWz467xV2j8eL2X/gPh+/bc84rFS8J7OTbizfP5uV9Ot7NK+3XFwGrMCIFqCdQwSoPCEMGiGKCnSq/CsmAKljqsNi04N5ya30PGrAARJ5WK6gTwHIiBVMWa4gABWxn0JIvQzVgQ7Z8cc+0K+/52Q9f+QVP8Cx/zgr23G8vLjo5Lx/QSbz1LH2srxJAoKbV9nAlM0xNEFBEW64hBDQA2/KUTtMylSZY1yXM2i5PADrT3QAYfSgvGZc/YA3UECMvdyADmAVYDRmII8EmHWO1PeiwYkPuuo8e2hjf9rc+dOVT6ycf815bt3F08boTu+UhHePWtQovUQhfQpv2eZ1W8dXga1DG+SqwXl+ZSstpVpNm5GBcEZ0sImRKax6LTL3ID3VAXI70mfXZzifi1pPbWw/99ru++brl0QwlDOqMMHl88eM783KvKq52ZZI4Q/NFBMygDTkjpQsidVVGmZDyPGSm1GH14uOG5N2ElLNDqsgN0FdJ1bderQMuHYyATGqQ+FLy9Ic8rRSQRMphwekSkMudXD3fWdz7Wz//jR9X0zPCGWCxVN2gfl+ah5a0NaY/TaCZoQEy4SGjM8qKulJdN0eHvKLrSM8WrBiq+HMgurXzQBLkCtLgnEe/wlW6BNgA5ToMM6C6PXo1+mRU+F2ZHRrNZ79/5zu/coblLoHFp+7Mymc0umWoOTkPPAsvklaIaCVQDIuQAIFnGUCr/tJJqHIOu+7QrTVaQUpYb0Ju69NKDai3VgGT3zVodbAMcfC1fT3A7X8TOtY8OzQvi8/c+Y++epEnV/8sgT25U/6t5FfnIFvFPr9uhn3lS8gAkKgj05XWugFVKcCpQ94eps2rypUtNJTdVMD61DKVkSnaBahpWDD6A6R0Cb5xqTOD7AHiJsIVtIB9oqRLW938rh6d3vmAx1b/DGAfXbxZh//ZtpIBrw17ydcqV1AJrQGHddp6kVFPIM1owfKfrEp1ai3jjq98WitpQvTkDQALC1BO7Y+RYZ0BKfKABHCkkTdAQw6rzTpSn6RbP/1z//vNOdoBrNap9cRmXaR7QdxLvtw6Zt3I8tJv3QFk6M6gldpyKdeIVWfAUrOCfIBk0jqUOg8LXU2pB1TAHkBW0Krr/aotNWClpcYJCt3BFXAiKlROgtrpbvG+HGeA/dbiJtXdnEIAL4XVclbuJc/6Bkj6Ts8OuWJaKd2Q73VWymccpvbrblSZsNtywKBOkwcqEatWOay1gjFIoEcZwLZAl0N/pNvrcDJqO8kMVv3Gutfpzf/j5790E9MPsIvybgpt+HOD23Za8y2oHih1CVfZVqc2W0oSJkIDJTVAytkaYFEmHVzCmTLaAI+Quu7PfQVM6lMv3UOckGhLfjbfNUvVL3ii49k/ZsOY6rjWws0xu0H9s07W1tcuU43UUTPoZTXfy5ld6kW2/2uotdTDBKpk4R6wHi57rBUZ5QpHCrZgLLO31rBS5GmxUQfI0HMf5G2p9EU/UbaO6/S0Nl+8bXHHYjwp3yw3qHVsqNTJeMzMkMmSkl1TFzX1b9VfkmWBtrUfiyjTd43kU97LqqhPUkf9kA2AkZJ3bHxsQiVlY4Vo66rugMs4/KrgGVCFmyArKNqHVVbIPdCw0tZyw8Ln59/92ftumKjVjUuTzpkw+gYWgF8SXNonhOyrpkADgOFlnWSUc3WQ4gRM2gfGo2CIZIAlGc//YaFYabVI6iTvLVp3ttDD2gJ2AuutNGFmaqgAjzaG2J+EFbAcV3pY76IsbmQP4rWKy4HJIMuUWuXV1qEHnO3ayaORbck3fSAGVA+XPqss4c7l9XPFsIg7AL30wYdSI8PNVLVRFgTJAq5S9U4XeZNhJysuX2BhgboB9aBC1pdX5ByXzZqEFydF/UuPfJadX8xfO1H/16rNEgCX2z/0CgHPSlkmVPNWa+r6ZikjbUPTV2+V1Lf9kV8pZ3fZVfhNqWGZquxhYjmOQMQFhHX2Mk049lyXIQf8FbjSzZOS4OKERN+dDtyCDsCALtdONNDDYTZ1MkyohZHlTOvMUqUHvDpz9FKJfG3fq3ED1pZf0XagDKeMlD8g2T4pHFDcP1ZeVRtqN1V+U1GzKHPpL7QtuNhWWSltO+25JmD8ZUAfAOcNCCi2WoABnHKVoWOXILlh+iYVAAMmEKmLy90pJ1CyANpa7fwwFnuxhthP3Pl15awAEKESUt+D9SIjpE6Uhr/UA3FLp3Rayht15B8+V2dWp/dygTsHiFLhbBMzv5qy878lwCdOdeX/PbYof3zvonz/cU1MJ8a7W7bYeoevVmsoPYi6BtUk4tJnnZp54PE+KU6QYSvPhNs+EvASVGBYb3FxV76yOKZeD0syAEkwL5Y2bXrLdUdNX5Qr0OkLpbxFWxXvuERgIdcEDnU2mMBtAbd5jPnUC4vyrW8syh/9993yJ0d3y4ZgbMgnsrk9mSsljzUqDStt0/S1wAs/mv40rDSsEpjpU9NSB8DCx9WCTrd4oitfXjyvcR2UJAJp5pG05ZTvlaKeddlWUDtZ6Os3S/nFq0q5Agp7hL3AJtSEuaH2mSdt73ELWc2xb87LXf/phfLMk7vSm5WpJgzUyWJ3CSqwDVJ1aZlhlVhtxrBUuxdB8w3PKXKVdbzBagOsrqgTWOxp1WvaNSQY0nV51F5E3sPVFTSRlf7Dq/X2UZf8iwUA7QWxla/mczht/3NZ6tH7t8tnP3mizE4LMK+LsVYAc6nbctNSB7DIY8EfQMMX5yUOOHQrTEMdrLmH3HVbXfd/dCvopLs6uiyTtnlG35bbfM5MMvzdfkH9Z68q5UbuQi8h0FVaLVZJPq1zNQVu6ii7Z9g5OSuf/ZWnyrHHtnQjBEpADbhhlcjOsFRbMQBDJ60y9AbQZ1qtrXgGWLQiaGYsgZYC5ZS1aZunQaPn5c/pUt77A6X82MuACqiMq1YJZLwIMYGjexbPotoIeoVSHvzN75cv33dCcAVWEddgoL0bqHABKZn9aQM1AKZ11rR1A21eALruSAXbgGE4BpzwELT1KV8js0hLoXe9Qjep82i4d8A7XKhICkgC7RNgLO7DhyKnnIfEGjKv7NmDlBdyDY//t6fL3Xc8WTb0Wji+JBlcAZbYL8V6oAPksNgKvIWYeV0NMR6lOh5PXjFC0sxXEeUecNYzhXZGTRuqdFWVH5EpvWP9yx2r4NCvVTygeFLt79Ya9qunSnlct9GnT2qtqpudv4hRX/vlUja1TiUeVoPrdLKu1pm47lBXLuVq6B268utCHXenQV/91y8qbzq1XR749FO2Wix3WAVgwYAbYuwhhD9NKzZgWTQI0OUhARlPTXETjXKAXTegKqODDL2bqIN1742CXYCg/ONXqUUjz/akWKgWBwb6S8dKueNegRQ8P4pK7m8ABDQ/NdrQZRxRbkJXwsaWIGsNO92aaSmzKO/4K6PyN//yuBzUNlK3CjnH2aTXvO1wee7xk+XokeOGGzenAWb4UMANNy+7AZWXQDPZaq081RHSqpl61z3kWlf4TwLJFKE1Q6W34CgOddLpZHl/VV9u/fI1WbmcXqDitYpHBPLvfb6U7z2nscm6u3MEVr5gLB8w0Rj5oAOwmwK5ub0o+08LpvL7tFbdOKWo8lTp4oTSLX0ktj0vN71mVP7+uzbL5sGwG4xor7jQSfmf/+LL5fknTpapnih6q8VabY3Veis438AyXy00LLdaM9B9MHBEvuu+tAJW43FoYBoswka2DvBY1vrBHyrlNdxVVgKi6xW/Kqh/41N6GtVlvLhcsfrh/DpmU0AnssgNRaDuU5+A3SdLPaD0gODuF8wDp+eSa2kkwDP5k23FiQD/wk9ulje8fb+GqsHqWHvBnT1zuvzBLz8kf7sjy8UvhoXiDtIyfakDiptZAk3ACVApFk0IuOhLhkWzNHJdnmW0yKc805SpTJuM6JK/THNZB5XurlUUk/Izf6DtAcHcfbUOgQmrjf6/FDiMB+CKKOUa0Zcq315pskA4qO+ILtu/U645d6ucLx/xiU+dKHe+/2nfrOz0aK6xLc1PsvH5G+WGn7iEDy9009rVzUZrXR4g6vo2l2Vjye17gUtkuaYO2+gxSeYx1XElbFHWBDPmQOr8esjIs64ZMO3YUHmjHldhsQpKV3oh/pvvl3JMy7DZdSpw61c7msYfMsq2gihIWn1eBcoGRzxJ6e6ux1WAnNPtlKv3n1Z8oTz48AvlI7f9ScCtx1kat+BpJ6dc8teuLBN95RZ9xI0MwPH4C1DWvDxQAF7HcgQqcKkbIm1SHieAiawCkygt2VbpyTLrGlO/SfGvr2uWVy1cDFNXdfn43eJ/TeWoslZA/YmCIceU55RQQQLKHqTyXgpVqxmnlWkyPKYSp3MsbqdcNDldXn3gRHniia3yxV/5jlY16oS1HN2qXZFOxN3S7V+U173jGu2OAWiwWEAmJD9ICFBY6gASfXTsnz0ulm6UpevVBgdcjQks5SrnZU8ag2zSKrtixbem9bJOfVg6L+jOvdDqXuNw7K2otk+4XPYxJsEVfcNV6lcshiorVRowA+qGYGC5U6WHtDnxQ/ueK/c/cLx859O6TLifsdxIqD6wZLq2Dt58WZlqj3JUQSVQ0oAaMG2RaZUAzJOcIAUGvwrYXA8PFssE6ySX4CXgmqYVYwxEt9G4L+WRaE1gufk1uYA5pksbHcPtap4m9qGCx0Ke/gJm+C1/z8qkvEslC5V12lKxUsUNAZvOt8uGNmuJ5A9ob/L6zWfLb33su2Whx1ptFugoSh3ylOu4k1G54scuFwxAcsnLEskDWjGviP6yxwXUpzevgwXYT3FOq0VrAnVtUo8HJGICznRVtqJnwBrzecu9uVNcHNN4VA8ABFt89qsU69U4HTmu+6pw850V68T0e1NN2pYpmABdikX7AYst7SiF/DztAL1q85nyyG98Sx1rFFN8AqMhDHDPf/0VPpH2ocAELgB1LF/qFSSXuG9kGmje0Hp3IP3Y+eJ+AFgmmaDa1AevdeisRk5+tlUKsInGmsPN4QOW8IzWoUDUmMNwlOKXbUS8Aeijrloue31Cji+dyP9NZpqs0qnSqX74kJa5Kevc1KsEYBqo8lGWrES8anKifOmPvlfmz+lgkzzNOboY7eQH9Jgoo5iov7DQcAM89sYNC6CRT8uNfd2Qx6qAExFuAAuOVUECasEiy9jK2zz1AFacIl8JDDuN+IVqlZwA3B1fcYelAlWKmjeykV63dLsaIGCVTpRODTXAbgBWcXMmy9QlT9xX4xLUCnkqwD+48XR57sGn1LlG1DGiABrD1YpXbuLiH71SYxUcrJJIniirteXWNOWsTKI+YdY3FpKHxSaohLiaUp+yvXQl54lpXWAKBPGp4FRIS1U61k16pMdW3nmNlQJzzKfuyk92ZSX6rnSqdGM3gBqqNhNsrfPTSskr4gLaaLewrZvZdrlYVvvIXY8yDA20BZuj68o51x8OiHYDemioPjZWAyy5ADlE7gF5k0In3YBdh8pYrU9gHsIHb/8IGE9Zrt8DHupaRp412HcCtAl+QlHZ76l0+fPefyKoE8GdAlRxY0c3px1BFdhNxX27stBZxLBWyXQJ75O/3RSMWB1wQ6mXribpy/KYll56cuumAquTFmGY9eTwIVssAD1W+0fmrTb9mIFBOdtHfVZ7q6JWxSYM+lm7Rzp03ig0QrJNsVEKOb9WsU+tegw+vwGwexBUllCGWsFubAfYTcHdFFzAbgK1gQvkzXoT26wPC7yOiQU7l2csjS4ZH9fegtauF7Y3MIYZox5fcMD+FP2QBJGEmPNDCkAvCWtz5uKQqQqcoKUQnQ6i1fJQM+R80BexWLS53HMQtlYNBGudANQ3rGqtgFXcBOyWoG7LIok7Ferulqx2q+wHMtZaLXbDFhuXITcdL9l01kaKh3Tw+fHtMrpoFWzMo9P79Q4/qnYmq7EtW6vKhqEK19X5K9+aZfKahNlXpdXEjZaFhihRdpCmnjepZe1BD4C4C1/29KvoDyoMNFYCUzniDQHdkE/dlBvY3N4VTEXB3bctiNsCqrgpsI7cvOwCcANyF/KPLMfyxpILdu5ZY1HZfWarTF7Jw3U/+mG4G2NBZZkVlhYQGecAwUaRlpG9uDp1hn4NduidjpZKg4UtddTopP6K5TcaznK5s2vllQB+SmX/mE3t+ZHbRkYslQhYRcBisQEZq90p++UKsNa4cQmoLDafunADeZPBtxJteVoNzPkYgdBTi6L/ij5LKHayMqRaugOfkJxvr4RAKwvLh7YTJticBKub+2oH2RFp1inFUmV0AazVWcn7XgxYHSx+aqlUDblhGSowZbGGaovFr0YE7n7cQHUFmwK7AVhFL78E1k9fguqnIMMFKksfpg3ckVdblPYKI7mLEZdUzk+6CTfaeDMyslUnegPAcq8T+ulD32EvaQ4iWXZGP02epRY/r2xDHsdAVeFfDmpPlWWkgcqV+WMKWapdgFPeDgAYS424fxeoslSlEQMoKwLghrXKYnUZx0oglkT4VVsrY2WwXr+2Izwz36mNY1+lWdC0LzeZvYTSJ/SrApeqkLzBrSnTn8eJEgclKut1KHXIFTJl+4DnnX26/Kd6+sICOJn8WJgfKA9Q5wKny98xLNf+VUA3HVkRyDIz1t2siXxrQOVRFP/K8qpCZRyeiI6ZA5VsrxAno7U0aXoiOZthXtlHdJ/1FYYqeWrrLRHlOo6llGYpT5i2XsBXuJqPAeYh3EbV+RCJPx0LLFbkfLXQaVpqdQX7lAI4rBPQAqtHWcp+KFCeuz9bhN7dsqVqQV9vPN4Y0WDj8ldaB9RvR2pMa4P0eGJiod836hWjk/bvchUgFPqXgoDVhA2t1tVxWJbyHmpzMt2OziTjcl9okyUh0kdGZNSzwzWRKyCfLsBrVvlY+9XevwosrgDLFUTXsYOVj7Veq+rhQXBjs0R+UYPwpoigBBwuaR1Lg8j5cHOvU9QI9ghcSkzMofrTvlH2RGWbD+1oMsgnPJ870IEiEwckxQSbI2JBb52aUm8dxqIbU+4a0n3GBHuBNhNwBXyewyog44aetLhp7TNYYNZosJHfAKbkpLHLVe/8osX7Kj8EkCqydsVa+xuXB8h4ZLPDvDXCM4NPSn/TqcqeK3kyQxIzRBB6cWVIpx4kwAKobUS5yhKmx5dypViqdZCR181L63y99awnpx6SfolXard7Qy8G8XVsrHiJpct+Q3mvXQHbRlyDQG5w6avjaYWa61Tf/StIQ8RCgKr+e6vVccMSlMT8LXGeOawE37gAazgo1EaePMoq9+2yvhdEfdW1K0hlZG1Ebr118gRLqsi8jgvuZXqLwHCItn6lHPq6g3q3pLerYwnj9TarAcGuMA3YeWCGdfL0NZVVxjup+nSm3niwWPKh6tPjroONOh00J6ZcjgmpA4IMDJDQTtYtmLgUs96ZtidV9HXIs6C5AqTtz8ejHmAcSyn6HnibIgcoMqVsBT4rP8vrmTw0YImsxF6Dxer19EgNuGHFQwGXuNaxtk6sNy955auVYqnsIfg9lw4IVKzebxxINTg2xH0gJaTIcpJwQfesN68cMBMxDDWnj7Rc6h3cmXJKOQShB4+gKmIMAOnHoboeII3qcXysJm8LRRdZjSy3vvusXijqvVYC5TDked65SJlrL9K3q98VWIHCHdhKAah8+NCQBcwAyj5C/pzIT1KA1YB9QtUvx/B0GAdQc8KSO0g/IK1W1PomCU1OVg19Z/Uo7os6aVqJP+SVunv+uEInH4tVxHKJgPZGtEABK2PK8t9jIc06/xMhKh85EjewvGGREvW6S8fuyj/9mWmZ8hWLXtmyH8A/MbKhBwHy6WsDMpd9+GFbquFitdUNCKLnwzyIlDMy+ZRnquqYOJmzBTUQTN7stk37g6QVAdzQU4uzSkSuVGd9lEATqkEntIStMhvSCRCgLiNTJA/4B+9Xx5pYAs2Ucwjc1x/WB8h/aeJPglgN4AISJJvZWKpXAIYqsLoZ9daqfn35e07k1SGx/+2SHIDyRF/C1BEADXQlHQ5+ryCXZCX0rRywDFkHwyvYM9ggWx06VpNWrgPyeNzv7KcFJmSs0pZZAWd9As56Q9bAXhC9hx9XGx1nNQKWhdAv3jIuP3h4ZLiGab8qwIJpFwHUGvMdkm9WGj9YgGtQyhssiWeNQEHVwQYSlCMF+OiC/VZZ+0cnuTaI6oRlK1RH1Vqx5YQcKQehLScCPWUVB4uVPK3Xl326BKBWwMiBmoAHuaxUVruh3ZXfuQMfGGAzNWQdU17A23f/7r37y0+99Rw9ickitTfgF4aCyevt/tLXYt+vPmS18SpcjeUKcuwxF1koswtzMUTKEWOuBi2op6fnl/E1+mJPc1gXZs9ty13pGA5K03Lj7Eha6zwAIFaQS6DRkVyRx+MlcAmVdaktV6ktFNAVcAJdtVw2Y77+9VK+8ugyXG40+VCjvWsNqis/+bc3yq/96iXlLX/xUPXpGozcA98Q8G9g1fEpFaiZVqZK5/rZ4kxxt42zUdlReWc2VtSzmNLdXaU17ig9ObmwHPzgbfqGQCdBc1gXtr+jj3Mru75+tbxOoQctZeX95Y0O0131qzo1TJxO6knIkwEMP4jQhroaE1LUy4okZ1PFcj1dXbCxKB/5wEg/gmOPM/pwqkP0VqwMN1MCA5jp9wo7x+dl59Rc+6bqUP0JqdqTSld5+1hS5E5DbuuqfVnZnUpPLw67Q5ulu3yfVgxSACqRua6Exz98b7ni4d+THpNVZfaHXptfardXRbuOBRoQ6Fd5UoNGXmNfl2Xu0ugSZYkjwdA/V1eeeqaUD//mvPyTn9MeqC5N2gE0oZLSp4PGxophos2EiT712W/vXOv+PJI6D72sjauAPuGBvIbF89vl6fv/uLxC33K18h5o6p7BMSuyp1TQOhYgrTX3QNXGKwRSReslUGSC6jcAtHceyJKp7hztB/7Xz5Xyykt1yf8EW8wD2MznUDwRtVmaEOV1YS85uuvq1smy3wbu0Tu+XK4ayRrQb+RWTVYUXJ+dqqKtc33Wab6CM7MvxeJ0mfRrWuXTEr0yoCwdfDDv/fubmKyUR1Tvr9Z0qhEc3JiX//ix7fKpO3ndwaWr9oqrY2E8a6G44s/4Z+3Bmj5Vf+qB75ajX7yvXDA+FVdRsiHN2DeRoJdlpkk5nqIuwBmrgl1g2TqV+sZkQACM2Mq43AEckGWh1tWNx6nKgo4l75fpnyu4H/3t0+Xff3C7bOmr4z3B9gOvk2nLf9b8WeDOjp0q99z+ufLqze/pKKFoFwUrQjLDbaXMFU1dlp3WBt1iF7A7aaW+tNUJkHrQQESm6H8i1ADRqVB1B6eOZ39/FiTrzCXTOTLlQ4qfv2e7vPMfHC//6/5dLeBXRrhSXBrnyymcBeC6bk7e+0T53C/dWa7UT4kvHfGrVwUv3TR3zae/B1RWAXnlIFkXrdu/O931710cUyeH7UfVIR1kxwBL/+t/naKW7UuBzyVe/SswuYNzclh/+oMJUslniqe2dIfWIvzKS0blnX/3QPmRv6DHW36IsQp2tdwO92x16J2tvtbN9Qr8sU8+Ur5+98PlgunJ8sbNo97UscF6suqHlCCOZ/xjFLD1jcga8QdZw1w34ye6H/7ni28I5Kt8hgSFNgarNC3Vn1NSV+uBiU7AzLRaqtr5QzLB5JHU76EMeFZO7XZlW2vSkQAD/PpXTsrNb9xXrnrFpJx3mVYEh0ZlrLXmSDvmfKjmsXqOLLEUnI+58JdlVxuSR8q4OhZ6CJk/u1VeOPp8+c79j5ZvPfRNbV3Oy1XTZ8pr5ALYg+2hcBBDU78VlI0YH5YBuePysUMWSvKx32B360nN22AZGPAYL5aXgEkDsiyUY6psqMjV2FaLtdpiI/WXLerQj6WCyKuTC+UWOnW0pVGw+vm/j+2Uo4+ekO/V46xftdQ3BHo84ifxU8n9WaXK/hW3FqGctHxpyIcZ+fLQbxE0cL+iMWGNVQP1ulRy1syUL5xslesmT5ZLxic0T+BAiUlFQtbK1EnmrjRPA04dqVjQWi7tCOiU7ik2uo/Zn9KPOki45L04R6bIzhJ1RLb86JP63hUIMDr+WEIg/R5KEHoZ9dLHRZyjHW5ALgRZTex32fVnogEOoAGZN7D5LVa+4naZR15FwPqYau9jKmUtrc5Crsnt00+Ozh2dLpeNny/ndqfNjel7A8dwKjESPeEFBKV0Q1/6v5O8+yInpC7tCMiJo3KMt7SPGSgggVg74fJ3GblkRD4OTtiGWmEmYFsvsNV7As5Jx3M/EIAXEPjB8FTPzlMtO/LzoPj+ijexfIQRcuoiH1+8WBeZwQb4gEy/vGTkFQ3zU1mTw2pjH4BZQ0EpUJgUIocqd6I/nHFAYqo+UUrEgua933VbNxi6oMmiPMYDwtcMs4LlQD1U+nYULKDqYOgGSA1aeayQcr+9BzisxlYLZCyVCYeciXIC3I6JS97HelL4zMePsKoLP6oDEUj6eWTN4GlDS2VR5cZab/K1HUSkke0z7QUcoAqd6E+r31aL1dngjrruqxON4QE/GEh5sFbBq2UAcKYMto7Ll7fyvaUCB1hKgeofYzgPcEBGyiXqevR7qAE3HiICZF5xzC/nE3SqQAACosrKkAcmYNyDiSKNcir5t7a2xAotQZLSHJApo2yrriIlPhCQ9H/cp+G6HZVkCNSPHhy98sZyRLrPAs+Xui0zwNpCWcc2PpW1quV2FQFN/+pvAANivVHZauUn7R6wWoNEv0YNYIAbVluxaIjgGQL5KEeO6RPiNFSZYMIlZFFvk7WydEirCZtfHiHNWvP3UVLP7SRCTsxypmjDrCmj0y26Z8tbbjwy+l39xxPk5u6Km1AFqiO7DFQAqoGtE3mNWGK4gbDUkAuaAaZetWJgVhcQ9ehJp4lYbAs2EQXQYfRDbsCfp8GpFVRnC45eAmj0NMBrYCU4UgJ9ADwP5nyWM7WmoRtwLWoMd3W33KLNTAXtrt2e9A0RoOrUl6dBVsAVcvhHhsilDSDVOwaskAU8dADItAJkppItwYz+0CNkGqUz/+ach5raQhXUqesIaZGpmOWst5y22X6PI7vTrFPatidfT8qoG99OlwZ77691943m3T2GWV2Bb2BAVYOwWuXVQW9lttiAx40q7/SGSp0tV/q2Vtqiq0ifBq28riPbXQu4zVuvnYFGrGJKpFo16CXlmpLhpUyp5mDdbAhEN2gAZQeps1oPrSVZ07bWjWbdPd2vv/8+igZLRq9P3mMfq0HYUu1DAVOhqFPnJQ9LDqgBirt4dQkGmgBXZRywttMo4yTFCiCt2aBVN/iunCmjVHAxtNLGQ0MT5TQlMyvnH4RRn3BcxMqyAaoWKuWmRaeOTR6dpTbZLxUK4/F7ItOA/eKHuy/o1cpHmdCZfhWowAJKWCfvsXroyDSK3udyMlyWvjoM+MiGZRSyAWLkGXUiY1agIGQapZhv5jPlLUS0RlJ7XvKzapewUEmIyDiCU2UBR1gHPGpCN9tbVz3ov+bR/cb7v5AqvcVasH90myZ81Je8/SmWU8FUWGFZyAAdsNLyAjqyqGd6fZ1023J8YxXwKgbpBpIcHDMw1Jz0UOGce1Rd2nxW929t+8nXU5Pltj/yLifcTJHvkedAtKmWrd2No+WcjdsQZ1gC+/kPdU9tTsZv1T7BcUMTjLDCAJQW2ddpSnlpUxcLe6ZZ5V4J8CEw7ZFFP0yTvEH75ESewVKXJ4C8BaR9sNQl86gtEEQvUZ9vatGJKLkyy9BrX7683WX8aYGmW6Cmlbus4S2643rmfmv3oX+lnz4OYQks4s98pHtEl/nbVdHDHaDgBgTHMBIgT1/KK+IOWlgBsroM1Q2A08bQH2Cm5dbpepRcMYEm/lIK9KEVc+VU1jLacgGh5wINFLLXmgK5l6naDVSXDVuIe+R1mONaU729+8gHHvEhmj9ngKXu05+Y/qE+x3yTDnM0rcyXPo+pmmi/2NcoDFUp8NPS3Kb3rcijrgXH9FzmpKh9ljk++ZhhztKCpT/JwVbkGrwsIVrX3qtsgNicp/CneQjS7DRl2Zfr1G/KBVr/O1q6jTd1n/jXf8hRV8NasCj93sc3Hzlvsu8NUvhY+tmcfIKgMfm0TPK2aKWrukN5mHLIEkW24ehtnvJyyPkhHfLtEbIHNJBnyHymyJv80Fk0aMvOS1epoH5MG8dv6D7+L8+w1NUjZXlt+tM//fyb9QXE+wTw5nALuQogxT3ErhVWTZm9SH4z5f1S11V53eLLrb7cGnSb1GfHyvnYEvTea9aRKvI7g9w6ZMOcL7n5bJ7jMT6njIVxVBkLBAwgnUa/wS05BiFfFnMPaxnKcK91+jbhHk3sPd0nh7v/WmA02atinfzWn3rqJp2ydwvg2zT48w2SidbB+zFXeX++XmGkjMnm1l6fao8BecJLef5WCzkAV/doAZvt/O2syj459cTRj68cyQGbvj/g8jsFJq47Vr1e+0+LAEhllQNUxWeV3iXZ7d3vxOJ/HZtV2csCm43v0L/z/8X//OQNi9nOjdpLfa1uXNdq7XtYm7sXa916UFZ1UL54Oul29Tuyuf6bAAE1Jt8AlrWF9VZLlB5vDfItAfr+50nzBPhkDRDjhKCvWK04QHIMrhrkabWCpNlSb/fln8foVyOjbkf8TmhHRa8yFk/KZz8hpUcVv6bGD5T5jx7pfvcWPeS/vPD/AUg2fXs/C6zNAAAAAElFTkSuQmCC";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        if (window.spotSolWallet) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    var _a2;
    return !!((_a2 = this._wallet) == null ? void 0 : _a2.isConnected);
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.spotSolWallet;
      try {
        await wallet.connect();
      } catch (error) {
        throw new WalletConnectionError(error == null ? void 0 : error.message, error);
      }
      if (!wallet.publicKey)
        throw new WalletAccountError();
      let publicKey;
      try {
        publicKey = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      wallet.on("disconnect", this._disconnected);
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.off("disconnect", this._disconnected);
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction);
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions);
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signature } = await wallet.signMessage(message);
        return signature;
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-tokenary/lib/esm/adapter.js
init_index_browser_esm();
var TokenaryWalletName = "Tokenary";
var TokenaryWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = TokenaryWalletName;
    this.url = "https://tokenary.io/get";
    this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMzRweCIgaGVpZ2h0PSIzNHB4IiB2aWV3Qm94PSIwIDAgMzQgMzQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8dGl0bGU+T3ZhbDwvdGl0bGU+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsIiBmaWxsPSIjMkM3Q0Y1IiBjeD0iMTciIGN5PSIxNyIgcj0iMTciPjwvY2lyY2xlPgogICAgPC9nPgo8L3N2Zz4=";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2;
        if ((_a2 = window.tokenarySolana) == null ? void 0 : _a2.isTokenary) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    var _a2;
    return !!((_a2 = this._wallet) == null ? void 0 : _a2.isConnected);
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.tokenarySolana;
      try {
        await wallet.connect();
      } catch (error) {
        throw new WalletConnectionError(error == null ? void 0 : error.message, error);
      }
      if (!wallet.publicKey)
        throw new WalletAccountError();
      let publicKey;
      try {
        publicKey = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      wallet.on("disconnect", this._disconnected);
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.off("disconnect", this._disconnected);
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async sendTransaction(transaction, connection, options = {}) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signers, ...sendOptions } = options;
        transaction = await this.prepareTransaction(transaction, connection, sendOptions);
        (signers == null ? void 0 : signers.length) && transaction.partialSign(...signers);
        sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
        const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);
        return signature;
      } catch (error) {
        if (error instanceof WalletError)
          throw error;
        throw new WalletSendTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signature } = await wallet.signMessage(message);
        return signature;
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-tokenpocket/lib/esm/adapter.js
init_index_browser_esm();
var TokenPocketWalletName = "TokenPocket";
var TokenPocketWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = TokenPocketWalletName;
    this.url = "https://tokenpocket.pro";
    this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwIiBoZWlnaHQ9IjEyMCIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGc+CjxwYXRoIGQ9Ik0xMDQxLjUyIDBILTI3VjEwMjRIMTA0MS41MlYwWiIgZmlsbD0iIzI5ODBGRSIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfNDA4XzIyNSkiPgo8cGF0aCBkPSJNNDA2Ljc5NiA0MzguNjQzSDQwNi45MjdDNDA2Ljc5NiA0MzcuODU3IDQwNi43OTYgNDM2Ljk0IDQwNi43OTYgNDM2LjE1NFY0MzguNjQzWiIgZmlsbD0iIzI5QUVGRiIvPgo8cGF0aCBkPSJNNjY3LjYwMiA0NjMuNTMzSDUyMy4yNDlWNzI0LjA3NkM1MjMuMjQ5IDczNi4zODkgNTMzLjIwNCA3NDYuMzQ1IDU0NS41MTcgNzQ2LjM0NUg2NDUuMzMzQzY1Ny42NDcgNzQ2LjM0NSA2NjcuNjAyIDczNi4zODkgNjY3LjYwMiA3MjQuMDc2VjQ2My41MzNaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNNDUzLjU2MyAyNzdINDQ4LjcxNkgxOTAuMjY5QzE3Ny45NTUgMjc3IDE2OCAyODYuOTU1IDE2OCAyOTkuMjY5VjM4OS42NTNDMTY4IDQwMS45NjcgMTc3Ljk1NSA0MTEuOTIyIDE5MC4yNjkgNDExLjkyMkgyNTAuOTE4SDI3NS4wMjFWNDM4LjY0NFY3MjQuNzMxQzI3NS4wMjEgNzM3LjA0NSAyODQuOTc2IDc0NyAyOTcuMjg5IDc0N0gzOTIuMTI4QzQwNC40NDEgNzQ3IDQxNC4zOTYgNzM3LjA0NSA0MTQuMzk2IDcyNC43MzFWNDM4LjY0NFY0MzYuMTU2VjQxMS45MjJINDM4LjQ5OUg0NDguMzIzSDQ1My4xN0M0OTAuMzcyIDQxMS45MjIgNTIwLjYzMSAzODEuNjYzIDUyMC42MzEgMzQ0LjQ2MUM1MjEuMDI0IDMwNy4yNTkgNDkwLjc2NSAyNzcgNDUzLjU2MyAyNzdaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNNjY3LjczNSA0NjMuNTMzVjY0NS4zNUM2NzIuNzEzIDY0Ni41MjkgNjc3LjgyMSA2NDcuNDQ2IDY4My4wNjEgNjQ4LjIzMkM2OTAuMzk3IDY0OS4yOCA2OTcuOTk0IDY0OS45MzUgNzA1LjU5MiA2NTAuMDY2QzcwNS45ODUgNjUwLjA2NiA3MDYuMzc4IDY1MC4wNjYgNzA2LjkwMiA2NTAuMDY2VjUwNS40NUM2ODUuMDI2IDUwNC4wMDkgNjY3LjczNSA0ODUuODAxIDY2Ny43MzUgNDYzLjUzM1oiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl80MDhfMjI1KSIvPgo8cGF0aCBkPSJNNzA5Ljc4MSAyNzdDNjA2LjgyMiAyNzcgNTIzLjI0OSAzNjAuNTczIDUyMy4yNDkgNDYzLjUzM0M1MjMuMjQ5IDU1Mi4wODQgNTg0Ljk0NiA2MjYuMjI1IDY2Ny43MzMgNjQ1LjM1VjQ2My41MzNDNjY3LjczMyA0NDAuMzQ3IDY4Ni41OTYgNDIxLjQ4NCA3MDkuNzgxIDQyMS40ODRDNzMyLjk2NyA0MjEuNDg0IDc1MS44MyA0NDAuMzQ3IDc1MS44MyA0NjMuNTMzQzc1MS44MyA0ODMuMDUxIDczOC42IDQ5OS40MjUgNzIwLjUyMyA1MDQuMTRDNzE3LjExNyA1MDUuMDU3IDcxMy40NDkgNTA1LjU4MSA3MDkuNzgxIDUwNS41ODFWNjUwLjA2NkM3MTMuNDQ5IDY1MC4wNjYgNzE2Ljk4NiA2NDkuOTM1IDcyMC41MjMgNjQ5LjgwNEM4MTguNTA1IDY0NC4xNzEgODk2LjMxNCA1NjIuOTU2IDg5Ni4zMTQgNDYzLjUzM0M4OTYuNDQ1IDM2MC41NzMgODEyLjg3MiAyNzcgNzA5Ljc4MSAyNzdaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNNzA5Ljc4IDY1MC4wNjZWNTA1LjU4MUM3MDguNzMzIDUwNS41ODEgNzA3LjgxNiA1MDUuNTgxIDcwNi43NjggNTA1LjQ1VjY1MC4wNjZDNzA3LjgxNiA2NTAuMDY2IDcwOC44NjQgNjUwLjA2NiA3MDkuNzggNjUwLjA2NloiIGZpbGw9IndoaXRlIi8+CjwvZz4KPC9nPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzQwOF8yMjUiIHgxPSI3MDkuODQ0IiB5MT0iNTU2LjgyNyIgeDI9IjY2Ny43NTMiIHkyPSI1NTYuODI3IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IndoaXRlIi8+CjxzdG9wIG9mZnNldD0iMC45NjY3IiBzdG9wLWNvbG9yPSJ3aGl0ZSIgc3RvcC1vcGFjaXR5PSIwLjMyMzMiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSJ3aGl0ZSIgc3RvcC1vcGFjaXR5PSIwLjMiLz4KPC9saW5lYXJHcmFkaWVudD4KPGNsaXBQYXRoIGlkPSJjbGlwMF80MDhfMjI1Ij4KPHJlY3Qgd2lkdGg9IjcyOC40NDgiIGhlaWdodD0iNDcwIiBmaWxsPSJ3aGl0ZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTY4IDI3NykiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2;
        if ((_a2 = window.solana) == null ? void 0 : _a2.isTokenPocket) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    var _a2;
    return !!((_a2 = this._wallet) == null ? void 0 : _a2.isConnected);
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.solana;
      try {
        await wallet.connect();
      } catch (error) {
        throw new WalletConnectionError(error == null ? void 0 : error.message, error);
      }
      if (!wallet.publicKey)
        throw new WalletAccountError();
      let publicKey;
      try {
        publicKey = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      wallet.on("disconnect", this._disconnected);
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.off("disconnect", this._disconnected);
      this._wallet = null;
      this._publicKey = null;
      this.emit("disconnect");
    }
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signature } = await wallet.signMessage(message);
        return signature;
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-torus/lib/esm/adapter.js
init_index_browser_esm();
var TorusWalletName = "Torus";
var TorusWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor({ params = { showTorusButton: false } } = { params: { showTorusButton: false } }) {
    super();
    this.name = TorusWalletName;
    this.url = "https://tor.us";
    this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzMiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMyAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTYuNSIgY3k9IjE2IiByPSIxNiIgZmlsbD0iIzAzNjRGRiIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjIxODYgOS40OTIxOUMxMC40NTM5IDkuNDkyMTkgOS44MzM5OCAxMC4xMTIxIDkuODMzOTggMTAuODc2OFYxMi40ODk4QzkuODMzOTggMTMuMjU0NSAxMC40NTM5IDEzLjg3NDQgMTEuMjE4NiAxMy44NzQ0SDEzLjY2ODRWMjIuODk3NkMxMy42Njg0IDIzLjY2MjMgMTQuMjg4MyAyNC4yODIyIDE1LjA1MyAyNC4yODIySDE2LjY2NkMxNy40MzA3IDI0LjI4MjIgMTguMDUwNiAyMy42NjIzIDE4LjA1MDYgMjIuODk3NlYxMi41MDE1QzE4LjA1MDYgMTIuNDk3NiAxOC4wNTA2IDEyLjQ5MzcgMTguMDUwNiAxMi40ODk4VjEwLjg3NjhDMTguMDUwNiAxMC4xMTIxIDE3LjQzMDcgOS40OTIxOSAxNi42NjYgOS40OTIxOUgxNS4wNTNIMTEuMjE4NloiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0yMS4zMzc2IDEzLjg3NDRDMjIuNTQ3NyAxMy44NzQ0IDIzLjUyODcgMTIuODkzNCAyMy41Mjg3IDExLjY4MzNDMjMuNTI4NyAxMC40NzMyIDIyLjU0NzcgOS40OTIxOSAyMS4zMzc2IDkuNDkyMTlDMjAuMTI3NSA5LjQ5MjE5IDE5LjE0NjUgMTAuNDczMiAxOS4xNDY1IDExLjY4MzNDMTkuMTQ2NSAxMi44OTM0IDIwLjEyNzUgMTMuODc0NCAyMS4zMzc2IDEzLjg3NDRaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    this._params = params;
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    var _a2;
    return !!((_a2 = this._wallet) == null ? void 0 : _a2.isLoggedIn);
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Loadable)
        throw new WalletNotReadyError();
      this._connecting = true;
      let TorusClass;
      try {
        TorusClass = (await import("./solanaEmbed.esm-N2N2JVV6.js")).default;
      } catch (error) {
        throw new WalletLoadError(error == null ? void 0 : error.message, error);
      }
      let wallet;
      try {
        wallet = window.torus || new TorusClass();
      } catch (error) {
        throw new WalletConfigError(error == null ? void 0 : error.message, error);
      }
      if (!wallet.isInitialized) {
        try {
          await wallet.init(this._params);
        } catch (error) {
          throw new WalletConnectionError(error == null ? void 0 : error.message, error);
        }
      }
      let accounts;
      try {
        accounts = await wallet.login();
      } catch (error) {
        throw new WalletAccountError(error == null ? void 0 : error.message, error);
      }
      let publicKey;
      try {
        publicKey = new PublicKey(accounts[0]);
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      this._wallet = null;
      this._publicKey = null;
      try {
        if (wallet.isLoggedIn)
          await wallet.cleanUp();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async sendTransaction(transaction, connection, options = {}) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signers, ...sendOptions } = options;
        transaction = await this.prepareTransaction(transaction, connection, sendOptions);
        (signers == null ? void 0 : signers.length) && transaction.partialSign(...signers);
        sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
        const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);
        return signature;
      } catch (error) {
        if (error instanceof WalletError)
          throw error;
        throw new WalletSendTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signMessage(message);
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-trezor/lib/esm/adapter.js
init_index_browser_esm();

// node_modules/@solana/wallet-adapter-trezor/lib/esm/polyfills/Buffer.js
var import_buffer4 = __toESM(require_buffer(), 1);
if (typeof window !== "undefined" && window.Buffer === void 0) {
  window.Buffer = import_buffer4.Buffer;
}

// node_modules/@solana/wallet-adapter-trezor/lib/esm/adapter.js
var TrezorWalletName = "Trezor";
var TrezorWalletAdapter = class extends BaseSignerWalletAdapter {
  constructor(config = {}) {
    var _a2;
    super();
    this.name = TrezorWalletName;
    this.url = "https://trezor.io";
    this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTA4IiBoZWlnaHQ9IjEwOCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyBjbGlwLXBhdGg9InVybCgjYSkiPjxwYXRoIGQ9Ik01NCAwYzI5LjgyNCAwIDU0IDI0LjE3NiA1NCA1NHMtMjQuMTc2IDU0LTU0IDU0UzAgODMuODI0IDAgNTQgMjQuMTc2IDAgNTQgMHoiIGZpbGw9IiNmZmYiLz48cGF0aCBkPSJNNzUuMjUgMzMuMzA1Qzc1LjI1IDIyLjIwNSA2NS42NjIgMTMgNTQgMTNjLTExLjY3MiAwLTIxLjI1OCA5LjIxMi0yMS4yNTggMjAuMzA1djYuNDlIMjR2NDYuNjgzTDUzLjk5IDEwMC41IDg0IDg2LjQ3NXYtNDYuNDdoLTguNzQ1bC0uMDA3LTYuNjk4LjAwMi0uMDAyem0tMzEuNjcgMGMwLTUuMjMyIDQuNTg1LTkuNDIgMTAuNDE4LTkuNDIgNS44MzUgMCAxMC40MTcgNC4xODggMTAuNDE3IDkuNDJ2Ni40OUg0My41OHYtNi40OXptMjguMzM1IDQ1LjYzN0w1My45OSA4Ny4zMmwtMTcuOTItOC4zNzJWNTAuODloMzUuODQ1djI4LjA1MnoiIGZpbGw9IiMxNzE3MTciLz48L2c+PGRlZnM+PGNsaXBQYXRoIGlkPSJhIj48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMCAwaDEwOHYxMDhIMHoiLz48L2NsaXBQYXRoPjwvZGVmcz48L3N2Zz4=";
    this.supportedTransactionVersions = /* @__PURE__ */ new Set(["legacy", 0]);
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
    this._onDeviceEvent = (event) => {
      if (event.type === "device-disconnect") {
        this._disconnected();
      }
    };
    this._disconnected = async () => {
      const wallet = this._wallet;
      if (wallet) {
        this._wallet = null;
        this._publicKey = null;
        try {
          wallet.off("DEVICE_EVENT", this._onDeviceEvent);
          wallet.dispose();
        } catch (error) {
          this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
        }
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._derivationPath = config.derivationPath || `m/44'/501'/0'/0'`;
    this._wallet = null;
    this._connectUrl = (_a2 = config.connectUrl) == null ? void 0 : _a2.replace(/\/*$/, "/");
    this._connecting = false;
    this._publicKey = null;
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    var _a2;
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Loadable)
        throw new WalletNotReadyError();
      this._connecting = true;
      let wallet;
      try {
        const { default: TrezorConnect } = await import("./lib-DPX5TZEE.js");
        wallet = TrezorConnect.default;
      } catch (error) {
        throw new WalletLoadError(error == null ? void 0 : error.message, error);
      }
      try {
        await wallet.init({
          manifest: {
            email: "gabriel.kerekes@vacuumlabs.com",
            appUrl: window.location.href
          },
          lazyLoad: true,
          ...this._connectUrl ? {
            connectSrc: this._connectUrl,
            iframeSrc: this._connectUrl
          } : {}
        });
      } catch (error) {
        throw new WalletConfigError(error == null ? void 0 : error.message, error);
      }
      let result;
      try {
        result = await wallet.solanaGetPublicKey({ path: this._derivationPath });
      } catch (error) {
        throw new WalletAccountError(error == null ? void 0 : error.message, error);
      }
      if (!result.success) {
        throw new WalletAccountError((_a2 = result.payload) == null ? void 0 : _a2.error, result.payload);
      }
      let publicKey;
      try {
        publicKey = new PublicKey(Buffer.from(result.payload.publicKey, "hex"));
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      wallet.on("DEVICE_EVENT", this._onDeviceEvent);
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      this._wallet = null;
      this._publicKey = null;
      try {
        wallet.off("DEVICE_EVENT", this._onDeviceEvent);
        await wallet.dispose();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
      this.emit("disconnect");
    }
  }
  async signTransaction(transaction) {
    var _a2;
    try {
      const wallet = this._wallet;
      const publicKey = this._publicKey;
      if (!wallet || !publicKey)
        throw new WalletNotConnectedError();
      const serializedTransaction = isVersionedTransaction(transaction) ? transaction.message.serialize() : transaction.serializeMessage();
      let result;
      try {
        result = await wallet.solanaSignTransaction({
          path: this._derivationPath,
          serializedTx: Buffer.from(serializedTransaction).toString("hex")
        });
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
      if (!result.success) {
        throw new WalletSignTransactionError((_a2 = result.payload) == null ? void 0 : _a2.error, result.payload);
      }
      try {
        const signature = Buffer.from(result.payload.signature, "hex");
        transaction.addSignature(publicKey, signature);
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
      return transaction;
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-trust/lib/esm/adapter.js
init_index_browser_esm();
var TrustWalletName = "Trust";
var TrustWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = TrustWalletName;
    this.url = "https://trustwallet.com";
    this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTkyMCAxMDgwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6dXJsKCNsaW5lYXItZ3JhZGllbnQpO30uY2xzLTJ7ZmlsbDojMDUwMGZmO308L3N0eWxlPjxsaW5lYXJHcmFkaWVudCBpZD0ibGluZWFyLWdyYWRpZW50IiB4MT0iMTEyMy4yNiIgeTE9IjE4NjUuNzgiIHgyPSI5NTQuNjEiIHkyPSIxMzM3LjUiIGdyYWRpZW50VHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAyMTgyKSBzY2FsZSgxIC0xKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iLjAyIiBzdG9wLWNvbG9yPSJibHVlIi8+PHN0b3Agb2Zmc2V0PSIuMDgiIHN0b3AtY29sb3I9IiMwMDk0ZmYiLz48c3RvcCBvZmZzZXQ9Ii4xNiIgc3RvcC1jb2xvcj0iIzQ4ZmY5MSIvPjxzdG9wIG9mZnNldD0iLjQyIiBzdG9wLWNvbG9yPSIjMDA5NGZmIi8+PHN0b3Agb2Zmc2V0PSIuNjgiIHN0b3AtY29sb3I9IiMwMDM4ZmYiLz48c3RvcCBvZmZzZXQ9Ii45IiBzdG9wLWNvbG9yPSIjMDUwMGZmIi8+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJtNzM4LjcxLDQyMy40MWwyMjEuNDUtNzIuM3Y1MDAuNTJjLTE1OC4xOC02Ni43NC0yMjEuNDUtMTk0LjY1LTIyMS40NS0yNjYuOTR2LTE2MS4yOFoiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Im0xMTgxLjYyLDQyMy40MWwtMjIxLjQ1LTcyLjN2NTAwLjUyYzE1OC4xOC02Ni43NCwyMjEuNDUtMTk0LjY1LDIyMS40NS0yNjYuOTR2LTE2MS4yOFoiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Im04MjUuOTEsMjMwLjg1aDMwLjl2MTcuMzFjMTAuMTMtMTUuNTYsMjEuNzgtMTcuMzEsMzguODQtMTcuMzF2MzAuNmgtNy43N2MtMjAuNDQsMC0zMC4yMyw5LjYyLTMwLjIzLDI4LjY3djMyLjUyaC0zMS43NXYtOTEuNzlaIi8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJtOTk4Ljc4LDMyMi42M2gtMzEuNzV2LTguNzVjLTYuOTMsOC4wNS0xNi4zOCwxMS41NC0yOC4wMywxMS41NC0yMi4xMiwwLTM0LjYyLTEzLjExLTM0LjYyLTM3LjI0di01Ny4zNGgzMS43NXY1MC4xOGMwLDExLjM2LDUuNTcsMTgsMTUuMDIsMThzMTUuODgtNi40NywxNS44OC0xNy40OHYtNTAuN2gzMS43NXY5MS43OVoiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Im0xMDA2LjU0LDI5NC4zaDI5LjczYzEuMzYsNi42NCw1LjkxLDkuNDMsMTYuODgsOS40Myw4Ljk1LDAsMTQuMTktMi4wOSwxNC4xOS01Ljk0LDAtMi45OC0yLjU0LTQuOS05Ljc5LTYuNDdsLTIzLjk4LTUuNDJjLTE2LjA0LTMuNjYtMjQuMTUtMTIuOTMtMjQuMTUtMjcuOCwwLTE5LjU5LDE0LjM1LTI5LjczLDQyLjIxLTI5LjczczQxLjU0LDkuODgsNDMuOTEsMzEuMDRoLTI5LjU1Yy0uNS01LjU5LTYuMjUtOS4wMS0xNS43LTkuMDEtNy41OSwwLTEyLjQ5LDIuNDQtMTIuNDksNi4xMiwwLDMuMTQsMy4yLDUuNTksOS42Myw3LjE4bDI1LjE2LDYuMTJjMTYuNTQsNC4wMSwyNC40OSwxMi40MSwyNC40OSwyNi4wNSwwLDE4Ljg5LTE2LjM4LDMwLjA4LTQ0LjIzLDMwLjA4cy00Ni4yNy0xMi4wNi00Ni4yNy0zMS42NWgtLjAzWiIvPjxwYXRoIGNsYXNzPSJjbHMtMiIgZD0ibTExODEuNjIsMjU5LjR2LTI4LjU1aC03OC4zNXYyOC41NmgyMy4zOHY2My4yMmgzMS41OHYtNjMuMjRoMjMuMzlaIi8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJtODE3LjA4LDI1OS40di0yOC41NWgtNzguMzV2MjguNTZoMjMuMzh2NjMuMjJoMzEuNTh2LTYzLjI0aDIzLjM4WiIvPjwvc3ZnPg==";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2, _b;
        if ((_b = (_a2 = window.trustwallet) == null ? void 0 : _a2.solana) == null ? void 0 : _b.isTrust) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    var _a2;
    return !!((_a2 = this._wallet) == null ? void 0 : _a2.isConnected);
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.trustwallet.solana;
      if (!wallet.isConnected) {
        try {
          await wallet.connect();
        } catch (error) {
          throw new WalletConnectionError(error == null ? void 0 : error.message, error);
        }
      }
      if (!wallet.publicKey)
        throw new WalletAccountError();
      let publicKey;
      try {
        publicKey = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      wallet.on("disconnect", this._disconnected);
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.off("disconnect", this._disconnected);
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async sendTransaction(transaction, connection, options = {}) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signers, ...sendOptions } = options;
        transaction = await this.prepareTransaction(transaction, connection, sendOptions);
        (signers == null ? void 0 : signers.length) && transaction.partialSign(...signers);
        sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
        const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);
        return signature;
      } catch (error) {
        if (error instanceof WalletError)
          throw error;
        throw new WalletSendTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signature } = await wallet.signMessage(message);
        return signature;
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-unsafe-burner/lib/esm/adapter.js
init_ed25519();
init_index_browser_esm();
var UnsafeBurnerWalletName = "Burner Wallet";
var UnsafeBurnerWalletAdapter = class extends BaseSignInMessageSignerWalletAdapter {
  constructor() {
    super();
    this.name = UnsafeBurnerWalletName;
    this.url = "https://github.com/anza-xyz/wallet-adapter#usage";
    this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzQiIGhlaWdodD0iMzAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0zNCAxMC42djIuN2wtOS41IDE2LjVoLTQuNmw2LTEwLjVhMi4xIDIuMSAwIDEgMCAyLTMuNGw0LjgtOC4zYTQgNCAwIDAgMSAxLjMgM1ptLTQuMyAxOS4xaC0uNmw0LjktOC40djQuMmMwIDIuMy0yIDQuMy00LjMgNC4zWm0yLTI4LjRjLS4zLS44LTEtMS4zLTItMS4zaC0xLjlsLTIuNCA0LjNIMzBsMS43LTNabS0zIDVoLTQuNkwxMC42IDI5LjhoNC43TDI4LjggNi40Wk0xOC43IDBoNC42bC0yLjUgNC4zaC00LjZMMTguNiAwWk0xNSA2LjRoNC42TDYgMjkuOEg0LjJjLS44IDAtMS43LS4zLTIuNC0uOEwxNSA2LjRaTTE0IDBIOS40TDcgNC4zaDQuNkwxNCAwWm0tMy42IDYuNEg1LjdMMCAxNi4ydjhMMTAuMyA2LjRaTTQuMyAwaC40TDAgOC4ydi00QzAgMiAxLjkgMCA0LjMgMFoiIGZpbGw9IiM5OTQ1RkYiLz48L3N2Zz4=";
    this.supportedTransactionVersions = /* @__PURE__ */ new Set(["legacy", 0]);
    this._keypair = null;
    console.warn("Your application is presently configured to use the `UnsafeBurnerWalletAdapter`. Find and remove it, then replace it with a list of adapters for wallets you would like your application to support. See https://github.com/anza-xyz/wallet-adapter#usage for an example.");
  }
  get connecting() {
    return false;
  }
  get publicKey() {
    return this._keypair && this._keypair.publicKey;
  }
  get readyState() {
    return WalletReadyState.Loadable;
  }
  async connect() {
    this._keypair = new Keypair();
    this.emit("connect", this._keypair.publicKey);
  }
  async disconnect() {
    this._keypair = null;
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    if (!this._keypair)
      throw new WalletNotConnectedError();
    if (isVersionedTransaction(transaction)) {
      transaction.sign([this._keypair]);
    } else {
      transaction.partialSign(this._keypair);
    }
    return transaction;
  }
  async signMessage(message) {
    if (!this._keypair)
      throw new WalletNotConnectedError();
    return ed25519.sign(message, this._keypair.secretKey.slice(0, 32));
  }
  async signIn(input = {}) {
    const { publicKey, secretKey } = this._keypair || (this._keypair = new Keypair());
    const domain = input.domain || window.location.host;
    const address = input.address || publicKey.toBase58();
    const signedMessage = createSignInMessage({
      ...input,
      domain,
      address
    });
    const signature = ed25519.sign(signedMessage, secretKey.slice(0, 32));
    this.emit("connect", publicKey);
    return {
      account: {
        address,
        publicKey: publicKey.toBytes(),
        chains: [],
        features: []
      },
      signedMessage,
      signature
    };
  }
};

// node_modules/@walletconnect/solana-adapter/dist/constants.js
var WalletConnectChainID;
(function(WalletConnectChainID2) {
  WalletConnectChainID2["Mainnet"] = "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp";
  WalletConnectChainID2["Devnet"] = "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1";
  WalletConnectChainID2["Deprecated_Mainnet"] = "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ";
  WalletConnectChainID2["Deprecated_Devnet"] = "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K";
})(WalletConnectChainID || (WalletConnectChainID = {}));
var WalletConnectRPCMethods;
(function(WalletConnectRPCMethods2) {
  WalletConnectRPCMethods2["signTransaction"] = "solana_signTransaction";
  WalletConnectRPCMethods2["signMessage"] = "solana_signMessage";
  WalletConnectRPCMethods2["signAndSendTransaction"] = "solana_signAndSendTransaction";
  WalletConnectRPCMethods2["signAndSendAllTransactions"] = "solana_signAndSendAllTransactions";
  WalletConnectRPCMethods2["signAllTransactions"] = "solana_signAllTransactions";
})(WalletConnectRPCMethods || (WalletConnectRPCMethods = {}));
var SolanaChainIDs = {
  Mainnet: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  Devnet: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  Deprecated_Mainnet: "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ",
  Deprecated_Devnet: "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"
};

// node_modules/@walletconnect/solana-adapter/dist/core.js
init_index_browser_esm();

// node_modules/@walletconnect/core/dist/index.es.js
var import_events3 = __toESM(require_events());

// node_modules/@walletconnect/core/node_modules/unstorage/dist/shared/unstorage.CoCt7NXC.mjs
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
var BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  return BASE64_PREFIX + base64Encode(value);
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  return base64Decode(value.slice(BASE64_PREFIX.length));
}
function base64Decode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c6) => c6.codePointAt(0)
  );
}
function base64Encode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}
function normalizeKey(key) {
  var _a2;
  if (!key) {
    return "";
  }
  return ((_a2 = key.split("?")[0]) == null ? void 0 : _a2.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || "";
}
function joinKeys(...keys2) {
  return normalizeKey(keys2.join(":"));
}
function normalizeBaseKey(base5) {
  base5 = normalizeKey(base5);
  return base5 ? base5 + ":" : "";
}
function filterKeyByDepth(key, depth) {
  if (depth === void 0) {
    return true;
  }
  let substrCount = 0;
  let index = key.indexOf(":");
  while (index > -1) {
    substrCount++;
    index = key.indexOf(":", index + 1);
  }
  return substrCount <= depth;
}
function filterKeyByBase(key, base5) {
  if (base5) {
    return key.startsWith(base5) && key[key.length - 1] !== "$";
  }
  return key[key.length - 1] !== "$";
}

// node_modules/@walletconnect/core/node_modules/unstorage/dist/index.mjs
function defineDriver(factory) {
  return factory;
}
var DRIVER_NAME = "memory";
var memory = defineDriver(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    getInstance: () => data,
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base5 of context.mountpoints) {
      if (key.startsWith(base5)) {
        return {
          base: base5,
          relativeKey: key.slice(base5.length),
          driver: context.mounts[base5]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base5, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base5) || includeParent && base5.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base5.length > mountpoint.length ? base5.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r2) => r2.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r2) => r2.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base5, opts = {}) {
      var _a2;
      base5 = normalizeBaseKey(base5);
      const mounts = getMounts(base5, true);
      let maskedMounts = [];
      const allKeys = [];
      let allMountsSupportMaxDepth = true;
      for (const mount of mounts) {
        if (!((_a2 = mount.driver.flags) == null ? void 0 : _a2.maxDepth)) {
          allMountsSupportMaxDepth = false;
        }
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey(key);
          if (!maskedMounts.some((p6) => fullKey.startsWith(p6))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p6) => !p6.startsWith(mount.mountpoint))
        ];
      }
      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;
      return allKeys.filter(
        (key) => (!shouldFilterByDepth || filterKeyByDepth(key, opts.maxDepth)) && filterKeyByBase(key, base5)
      );
    },
    // Utils
    async clear(base5, opts = {}) {
      base5 = normalizeBaseKey(base5);
      await Promise.all(
        getMounts(base5, false).map(async (m3) => {
          if (m3.driver.clear) {
            return asyncCall(m3.driver.clear, m3.relativeBase, opts);
          }
          if (m3.driver.removeItem) {
            const keys2 = await m3.driver.getKeys(m3.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key) => m3.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base5, driver) {
      base5 = normalizeBaseKey(base5);
      if (base5 && context.mounts[base5]) {
        throw new Error(`already mounted at ${base5}`);
      }
      if (base5) {
        context.mountpoints.push(base5);
        context.mountpoints.sort((a2, b4) => b4.length - a2.length);
      }
      context.mounts[base5] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base5)).then((unwatcher) => {
          context.unwatch[base5] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base5, _dispose = true) {
      var _a2, _b;
      base5 = normalizeBaseKey(base5);
      if (!base5 || !context.mounts[base5]) {
        return;
      }
      if (context.watching && base5 in context.unwatch) {
        (_b = (_a2 = context.unwatch)[base5]) == null ? void 0 : _b.call(_a2);
        delete context.unwatch[base5];
      }
      if (_dispose) {
        await dispose(context.mounts[base5]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base5);
      delete context.mounts[base5];
    },
    getMount(key = "") {
      key = normalizeKey(key) + ":";
      const m3 = getMount(key);
      return {
        driver: m3.driver,
        base: m3.base
      };
    },
    getMounts(base5 = "", opts = {}) {
      base5 = normalizeKey(base5);
      const mounts = getMounts(base5, opts.parents);
      return mounts.map((m3) => ({
        driver: m3.driver,
        base: m3.mountpoint
      }));
    },
    // Aliases
    keys: (base5, opts = {}) => storage.getKeys(base5, opts),
    get: (key, opts = {}) => storage.getItem(key, opts),
    set: (key, value, opts = {}) => storage.setItem(key, value, opts),
    has: (key, opts = {}) => storage.hasItem(key, opts),
    del: (key, opts = {}) => storage.removeItem(key, opts),
    remove: (key, opts = {}) => storage.removeItem(key, opts)
  };
  return storage;
}
function watch(driver, onChange, base5) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base5 + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

// node_modules/@walletconnect/core/node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var x = "idb-keyval";
var z = (i3 = {}) => {
  const t = i3.base && i3.base.length > 0 ? `${i3.base}:` : "", e = (s) => t + s;
  let n3;
  return i3.dbName && i3.storeName && (n3 = createStore(i3.dbName, i3.storeName)), { name: x, options: i3, async hasItem(s) {
    return !(typeof await get(e(s), n3) > "u");
  }, async getItem(s) {
    return await get(e(s), n3) ?? null;
  }, setItem(s, a2) {
    return set(e(s), a2, n3);
  }, removeItem(s) {
    return del(e(s), n3);
  }, getKeys() {
    return keys(n3);
  }, clear() {
    return clear(n3);
  } };
};
var D = "WALLET_CONNECT_V2_INDEXED_DB";
var E2 = "keyvaluestorage";
var _ = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z({ dbName: D, storeName: E2 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const e = await this.indexedDb.getItem(t);
    if (e !== null) return e;
  }
  async setItem(t, e) {
    await this.indexedDb.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var l = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c = { exports: {} };
(function() {
  let i3;
  function t() {
  }
  i3 = t, i3.prototype.getItem = function(e) {
    return this.hasOwnProperty(e) ? String(this[e]) : null;
  }, i3.prototype.setItem = function(e, n3) {
    this[e] = String(n3);
  }, i3.prototype.removeItem = function(e) {
    delete this[e];
  }, i3.prototype.clear = function() {
    const e = this;
    Object.keys(e).forEach(function(n3) {
      e[n3] = void 0, delete e[n3];
    });
  }, i3.prototype.key = function(e) {
    return e = e || 0, Object.keys(this)[e];
  }, i3.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l < "u" && l.localStorage ? c.exports = l.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new t();
})();
function k2(i3) {
  var t;
  return [i3[0], safeJsonParse((t = i3[1]) != null ? t : "")];
}
var K = class {
  constructor() {
    this.localStorage = c.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k2);
  }
  async getItem(t) {
    const e = this.localStorage.getItem(t);
    if (e !== null) return safeJsonParse(e);
  }
  async setItem(t, e) {
    this.localStorage.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
var N = "wc_storage_version";
var y3 = 1;
var O2 = async (i3, t, e) => {
  const n3 = N, s = await t.getItem(n3);
  if (s && s >= y3) {
    e(t);
    return;
  }
  const a2 = await i3.getKeys();
  if (!a2.length) {
    e(t);
    return;
  }
  const m3 = [];
  for (; a2.length; ) {
    const r2 = a2.shift();
    if (!r2) continue;
    const o3 = r2.toLowerCase();
    if (o3.includes("wc@") || o3.includes("walletconnect") || o3.includes("wc_") || o3.includes("wallet_connect")) {
      const f10 = await i3.getItem(r2);
      await t.setItem(r2, f10), m3.push(r2);
    }
  }
  await t.setItem(n3, y3), e(t), j(i3, m3);
};
var j = async (i3, t) => {
  t.length && t.forEach(async (e) => {
    await i3.removeItem(e);
  });
};
var h2 = class {
  constructor() {
    this.initialized = false, this.setInitialized = (e) => {
      this.storage = e, this.initialized = true;
    };
    const t = new K();
    this.storage = t;
    try {
      const e = new _();
      O2(t, e, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, e) {
    return await this.initialize(), this.storage.setItem(t, e);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const e = setInterval(() => {
        this.initialized && (clearInterval(e), t());
      }, 20);
    });
  }
};

// node_modules/@walletconnect/core/node_modules/@walletconnect/types/dist/index.es.js
var import_events2 = __toESM(require_events());
var a = Object.defineProperty;
var u = (e, s, r2) => s in e ? a(e, s, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s] = r2;
var c2 = (e, s, r2) => u(e, typeof s != "symbol" ? s + "" : s, r2);
var h3 = class extends IEvents {
  constructor(s) {
    super(), this.opts = s, c2(this, "protocol", "wc"), c2(this, "version", 2);
  }
};
var p = Object.defineProperty;
var b = (e, s, r2) => s in e ? p(e, s, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s] = r2;
var v = (e, s, r2) => b(e, typeof s != "symbol" ? s + "" : s, r2);
var I2 = class extends IEvents {
  constructor(s, r2) {
    super(), this.core = s, this.logger = r2, v(this, "records", /* @__PURE__ */ new Map());
  }
};
var y4 = class {
  constructor(s, r2) {
    this.logger = s, this.core = r2;
  }
};
var m2 = class extends IEvents {
  constructor(s, r2) {
    super(), this.relayer = s, this.logger = r2;
  }
};
var d2 = class extends IEvents {
  constructor(s) {
    super();
  }
};
var f4 = class {
  constructor(s, r2, t, q5) {
    this.core = s, this.logger = r2, this.name = t;
  }
};
var P2 = class extends IEvents {
  constructor(s, r2) {
    super(), this.relayer = s, this.logger = r2;
  }
};
var S2 = class extends IEvents {
  constructor(s, r2) {
    super(), this.core = s, this.logger = r2;
  }
};
var M2 = class {
  constructor(s, r2, t) {
    this.core = s, this.logger = r2, this.store = t;
  }
};
var O3 = class {
  constructor(s, r2) {
    this.projectId = s, this.logger = r2;
  }
};
var R2 = class {
  constructor(s, r2, t) {
    this.core = s, this.logger = r2, this.telemetryEnabled = t;
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_time2 = __toESM(require_cjs());

// node_modules/@walletconnect/utils/dist/index.es.js
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());

// node_modules/@walletconnect/utils/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
function publicKeyToAddress(publicKey) {
  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26);
  return checksumAddress(`0x${address}`);
}

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverPublicKey.js
async function recoverPublicKey({ hash, signature }) {
  const hashHex = isHex(hash) ? hash : toHex(hash);
  const { secp256k1: secp256k13 } = await import("./secp256k1-IK6HZ7AH.js");
  const signature_ = (() => {
    if (typeof signature === "object" && "r" in signature && "s" in signature) {
      const { r: r2, s, v: v6, yParity } = signature;
      const yParityOrV2 = Number(yParity ?? v6);
      const recoveryBit2 = toRecoveryBit(yParityOrV2);
      return new secp256k13.Signature(hexToBigInt(r2), hexToBigInt(s)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex(signature) ? signature : toHex(signature);
    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit(yParityOrV);
    return secp256k13.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverAddress.js
async function recoverAddress({ hash, signature }) {
  return publicKeyToAddress(await recoverPublicKey({ hash, signature }));
}

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transaction.js
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction2(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction2 = defineFormatter("transaction", formatTransaction2);
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    contractAddress: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction2(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock2 = defineFormatter("block", formatBlock);

// node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/public/getTransactionCount.js
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]
  }, { dedupe: Boolean(blockNumber) });
  return hexToNumber(count);
}

// node_modules/@walletconnect/utils/node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/log.js
function formatLog2(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/wallet/sendTransaction.js
var supportsWalletNamespace = new LruMap(128);

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/promise/withDedupe.js
var promiseCache = new LruMap(8192);

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache = createIdStore();

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transactionReceipt.js
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog2(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt2 = defineFormatter("transactionReceipt", formatTransactionReceipt);

// node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/ripemd160.js
var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = new Uint8Array(new Array(16).fill(0).map((_7, i3) => i3));
var Pi = Id.map((i3) => (9 * i3 + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i3 = 0; i3 < 4; i3++)
  for (let j5 of [idxL, idxR])
    j5.push(j5[i3].map((k8) => Rho[k8]));
var shifts = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i3) => new Uint8Array(i3));
var shiftsL = idxL.map((idx, i3) => idx.map((j5) => shifts[i3][j5]));
var shiftsR = idxR.map((idx, i3) => idx.map((j5) => shifts[i3][j5]));
var Kl = new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr = new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f5(group, x9, y9, z9) {
  if (group === 0)
    return x9 ^ y9 ^ z9;
  else if (group === 1)
    return x9 & y9 | ~x9 & z9;
  else if (group === 2)
    return (x9 | ~y9) ^ z9;
  else if (group === 3)
    return x9 & z9 | y9 & ~z9;
  else
    return x9 ^ (y9 | ~z9);
}
var R_BUF = new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2: h22, h3: h32, h4: h42 } = this;
    return [h0, h1, h22, h32, h42];
  }
  set(h0, h1, h22, h32, h42) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h22 | 0;
    this.h3 = h32 | 0;
    this.h4 = h42 | 0;
  }
  process(view, offset) {
    for (let i3 = 0; i3 < 16; i3++, offset += 4)
      R_BUF[i3] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar6 = al, bl = this.h1 | 0, br6 = bl, cl = this.h2 | 0, cr6 = cl, dl = this.h3 | 0, dr6 = dl, el = this.h4 | 0, er6 = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr6 = idxR[group];
      const sl = shiftsL[group], sr6 = shiftsR[group];
      for (let i3 = 0; i3 < 16; i3++) {
        const tl = rotl(al + f5(group, bl, cl, dl) + R_BUF[rl[i3]] + hbl, sl[i3]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i3 = 0; i3 < 16; i3++) {
        const tr6 = rotl(ar6 + f5(rGroup, br6, cr6, dr6) + R_BUF[rr6[i3]] + hbr, sr6[i3]) + er6 | 0;
        ar6 = er6, er6 = dr6, dr6 = rotl(cr6, 10) | 0, cr6 = br6, br6 = tr6;
      }
    }
    this.set(this.h1 + cl + dr6 | 0, this.h2 + dl + er6 | 0, this.h3 + el + ar6 | 0, this.h4 + al + br6 | 0, this.h0 + bl + cr6 | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = wrapConstructor(() => new RIPEMD160());

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/nonceManager.js
function createNonceManager(parameters) {
  const { source } = parameters;
  const deltaMap = /* @__PURE__ */ new Map();
  const nonceMap = new LruMap(8192);
  const promiseMap = /* @__PURE__ */ new Map();
  const getKey = ({ address, chainId }) => `${address}.${chainId}`;
  return {
    async consume({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      const promise = this.get({ address, chainId, client });
      this.increment({ address, chainId });
      const nonce = await promise;
      await source.set({ address, chainId }, nonce);
      nonceMap.set(key, nonce);
      return nonce;
    },
    async increment({ address, chainId }) {
      const key = getKey({ address, chainId });
      const delta = deltaMap.get(key) ?? 0;
      deltaMap.set(key, delta + 1);
    },
    async get({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      let promise = promiseMap.get(key);
      if (!promise) {
        promise = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client });
            const previousNonce = nonceMap.get(key) ?? 0;
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1;
            nonceMap.delete(key);
            return nonce;
          } finally {
            this.reset({ address, chainId });
          }
        })();
        promiseMap.set(key, promise);
      }
      const delta = deltaMap.get(key) ?? 0;
      return delta + await promise;
    },
    reset({ address, chainId }) {
      const key = getKey({ address, chainId });
      deltaMap.delete(key);
      promiseMap.delete(key);
    }
  };
}
function jsonRpc() {
  return {
    async get(parameters) {
      const { address, client } = parameters;
      return getTransactionCount(client, {
        address,
        blockTag: "pending"
      });
    },
    set() {
    }
  };
}
var nonceManager = createNonceManager({
  source: jsonRpc()
});

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/version.js
var version = "0.1.1";

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/internal/errors.js
function getVersion() {
  return version;
}

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/Errors.js
var BaseError3 = class _BaseError extends Error {
  constructor(shortMessage, options = {}) {
    const details = (() => {
      var _a2;
      if (options.cause instanceof _BaseError) {
        if (options.cause.details)
          return options.cause.details;
        if (options.cause.shortMessage)
          return options.cause.shortMessage;
      }
      if ((_a2 = options.cause) == null ? void 0 : _a2.message)
        return options.cause.message;
      return options.details;
    })();
    const docsPath = (() => {
      if (options.cause instanceof _BaseError)
        return options.cause.docsPath || options.docsPath;
      return options.docsPath;
    })();
    const docsBaseUrl = "https://oxlib.sh";
    const docs = `${docsBaseUrl}${docsPath ?? ""}`;
    const message = [
      shortMessage || "An error occurred.",
      ...options.metaMessages ? ["", ...options.metaMessages] : [],
      ...details || docsPath ? [
        "",
        details ? `Details: ${details}` : void 0,
        docsPath ? `See: ${docs}` : void 0
      ] : []
    ].filter((x9) => typeof x9 === "string").join("\n");
    super(message, options.cause ? { cause: options.cause } : void 0);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseError"
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: `ox@${getVersion()}`
    });
    this.cause = options.cause;
    this.details = details;
    this.docs = docs;
    this.docsPath = docsPath;
    this.shortMessage = shortMessage;
  }
  walk(fn6) {
    return walk(this, fn6);
  }
};
function walk(err, fn6) {
  if (fn6 == null ? void 0 : fn6(err))
    return err;
  if (err && typeof err === "object" && "cause" in err && err.cause)
    return walk(err.cause, fn6);
  return fn6 ? null : err;
}

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/internal/bytes.js
function assertSize(bytes, size_) {
  if (size2(bytes) > size_)
    throw new SizeOverflowError({
      givenSize: size2(bytes),
      maxSize: size_
    });
}
var charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return void 0;
}
function pad3(bytes, options = {}) {
  const { dir, size: size7 = 32 } = options;
  if (size7 === 0)
    return bytes;
  if (bytes.length > size7)
    throw new SizeExceedsPaddingSizeError({
      size: bytes.length,
      targetSize: size7,
      type: "Bytes"
    });
  const paddedBytes = new Uint8Array(size7);
  for (let i3 = 0; i3 < size7; i3++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i3 : size7 - i3 - 1] = bytes[padEnd ? i3 : bytes.length - i3 - 1];
  }
  return paddedBytes;
}

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/internal/hex.js
function assertSize2(hex, size_) {
  if (size3(hex) > size_)
    throw new SizeOverflowError2({
      givenSize: size3(hex),
      maxSize: size_
    });
}
function pad4(hex_, options = {}) {
  const { dir, size: size7 = 32 } = options;
  if (size7 === 0)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size7 * 2)
    throw new SizeExceedsPaddingSizeError2({
      size: Math.ceil(hex.length / 2),
      targetSize: size7,
      type: "Hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size7 * 2, "0")}`;
}

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/Bytes.js
var decoder = new TextDecoder();
var encoder = new TextEncoder();
function from(value) {
  if (value instanceof Uint8Array)
    return value;
  if (typeof value === "string")
    return fromHex2(value);
  return fromArray(value);
}
function fromArray(value) {
  return value instanceof Uint8Array ? value : new Uint8Array(value);
}
function fromHex2(value, options = {}) {
  const { size: size7 } = options;
  let hex = value;
  if (size7) {
    assertSize2(value, size7);
    hex = padRight(value, size7);
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes = new Uint8Array(length);
  for (let index = 0, j5 = 0; index < length; index++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j5++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j5++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError3(`Invalid byte sequence ("${hexString[j5 - 2]}${hexString[j5 - 1]}" in "${hexString}").`);
    }
    bytes[index] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes;
}
function fromString2(value, options = {}) {
  const { size: size7 } = options;
  const bytes = encoder.encode(value);
  if (typeof size7 === "number") {
    assertSize(bytes, size7);
    return padRight2(bytes, size7);
  }
  return bytes;
}
function padRight2(value, size7) {
  return pad3(value, { dir: "right", size: size7 });
}
function size2(value) {
  return value.length;
}
var SizeOverflowError = class extends BaseError3 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Bytes.SizeOverflowError"
    });
  }
};
var SizeExceedsPaddingSizeError = class extends BaseError3 {
  constructor({ size: size7, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size7}\`) exceeds padding size (\`${targetSize}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Bytes.SizeExceedsPaddingSizeError"
    });
  }
};

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/Hex.js
var encoder2 = new TextEncoder();
var hexes = Array.from({ length: 256 }, (_v, i3) => i3.toString(16).padStart(2, "0"));
function concat3(...values) {
  return `0x${values.reduce((acc, x9) => acc + x9.replace("0x", ""), "")}`;
}
function fromBoolean(value, options = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof options.size === "number") {
    assertSize2(hex, options.size);
    return padLeft(hex, options.size);
  }
  return hex;
}
function fromBytes2(value, options = {}) {
  let string = "";
  for (let i3 = 0; i3 < value.length; i3++)
    string += hexes[value[i3]];
  const hex = `0x${string}`;
  if (typeof options.size === "number") {
    assertSize2(hex, options.size);
    return padRight(hex, options.size);
  }
  return hex;
}
function fromNumber(value, options = {}) {
  const { signed, size: size7 } = options;
  const value_ = BigInt(value);
  let maxValue;
  if (size7) {
    if (signed)
      maxValue = (1n << BigInt(size7) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size7) * 8n) - 1n;
  } else if (typeof value === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value_ > maxValue || value_ < minValue) {
    const suffix = typeof value === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue ? `${maxValue}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed,
      size: size7,
      value: `${value}${suffix}`
    });
  }
  const stringValue = (signed && value_ < 0 ? (1n << BigInt(size7 * 8)) + BigInt(value_) : value_).toString(16);
  const hex = `0x${stringValue}`;
  if (size7)
    return padLeft(hex, size7);
  return hex;
}
function fromString3(value, options = {}) {
  return fromBytes2(encoder2.encode(value), options);
}
function padLeft(value, size7) {
  return pad4(value, { dir: "left", size: size7 });
}
function padRight(value, size7) {
  return pad4(value, { dir: "right", size: size7 });
}
function size3(value) {
  return Math.ceil((value.length - 2) / 2);
}
var IntegerOutOfRangeError = class extends BaseError3 {
  constructor({ max, min, signed, size: size7, value }) {
    super(`Number \`${value}\` is not in safe${size7 ? ` ${size7 * 8}-bit` : ""}${signed ? " signed" : " unsigned"} integer range ${max ? `(\`${min}\` to \`${max}\`)` : `(above \`${min}\`)`}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.IntegerOutOfRangeError"
    });
  }
};
var SizeOverflowError2 = class extends BaseError3 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SizeOverflowError"
    });
  }
};
var SizeExceedsPaddingSizeError2 = class extends BaseError3 {
  constructor({ size: size7, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size7}\`) exceeds padding size (\`${targetSize}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SizeExceedsPaddingSizeError"
    });
  }
};

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/Hash.js
function keccak2563(value, options = {}) {
  const { as: as4 = typeof value === "string" ? "Hex" : "Bytes" } = options;
  const bytes = keccak_256(from(value));
  if (as4 === "Bytes")
    return bytes;
  return fromBytes2(bytes);
}

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/internal/lru.js
var LruMap3 = class extends Map {
  constructor(size7) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size7;
  }
  get(key) {
    const value = super.get(key);
    if (super.has(key) && value !== void 0) {
      this.delete(key);
      super.set(key, value);
    }
    return value;
  }
  set(key, value) {
    super.set(key, value);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
};

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/Caches.js
var caches = {
  checksum: new LruMap3(8192)
};
var checksum = caches.checksum;

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/Address.js
var addressRegex = /^0x[a-fA-F0-9]{40}$/;
function assert(value, options = {}) {
  const { strict = true } = options;
  if (!addressRegex.test(value))
    throw new InvalidAddressError3({
      address: value,
      cause: new InvalidInputError()
    });
  if (strict) {
    if (value.toLowerCase() === value)
      return;
    if (checksum2(value) !== value)
      throw new InvalidAddressError3({
        address: value,
        cause: new InvalidChecksumError()
      });
  }
}
function checksum2(address) {
  if (checksum.has(address))
    return checksum.get(address);
  assert(address, { strict: false });
  const hexAddress = address.substring(2).toLowerCase();
  const hash = keccak2563(fromString2(hexAddress), { as: "Bytes" });
  const characters = hexAddress.split("");
  for (let i3 = 0; i3 < 40; i3 += 2) {
    if (hash[i3 >> 1] >> 4 >= 8 && characters[i3]) {
      characters[i3] = characters[i3].toUpperCase();
    }
    if ((hash[i3 >> 1] & 15) >= 8 && characters[i3 + 1]) {
      characters[i3 + 1] = characters[i3 + 1].toUpperCase();
    }
  }
  const result = `0x${characters.join("")}`;
  checksum.set(address, result);
  return result;
}
var InvalidAddressError3 = class extends BaseError3 {
  constructor({ address, cause }) {
    super(`Address "${address}" is invalid.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidAddressError"
    });
  }
};
var InvalidInputError = class extends BaseError3 {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidInputError"
    });
  }
};
var InvalidChecksumError = class extends BaseError3 {
  constructor() {
    super("Address does not match its checksum counterpart.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidChecksumError"
    });
  }
};

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/Solidity.js
var arrayRegex2 = /^(.*)\[([0-9]*)\]$/;
var bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var maxInt8 = 2n ** (8n - 1n) - 1n;
var maxInt16 = 2n ** (16n - 1n) - 1n;
var maxInt24 = 2n ** (24n - 1n) - 1n;
var maxInt32 = 2n ** (32n - 1n) - 1n;
var maxInt40 = 2n ** (40n - 1n) - 1n;
var maxInt48 = 2n ** (48n - 1n) - 1n;
var maxInt56 = 2n ** (56n - 1n) - 1n;
var maxInt64 = 2n ** (64n - 1n) - 1n;
var maxInt72 = 2n ** (72n - 1n) - 1n;
var maxInt80 = 2n ** (80n - 1n) - 1n;
var maxInt88 = 2n ** (88n - 1n) - 1n;
var maxInt96 = 2n ** (96n - 1n) - 1n;
var maxInt104 = 2n ** (104n - 1n) - 1n;
var maxInt112 = 2n ** (112n - 1n) - 1n;
var maxInt120 = 2n ** (120n - 1n) - 1n;
var maxInt128 = 2n ** (128n - 1n) - 1n;
var maxInt136 = 2n ** (136n - 1n) - 1n;
var maxInt144 = 2n ** (144n - 1n) - 1n;
var maxInt152 = 2n ** (152n - 1n) - 1n;
var maxInt160 = 2n ** (160n - 1n) - 1n;
var maxInt168 = 2n ** (168n - 1n) - 1n;
var maxInt176 = 2n ** (176n - 1n) - 1n;
var maxInt184 = 2n ** (184n - 1n) - 1n;
var maxInt192 = 2n ** (192n - 1n) - 1n;
var maxInt200 = 2n ** (200n - 1n) - 1n;
var maxInt208 = 2n ** (208n - 1n) - 1n;
var maxInt216 = 2n ** (216n - 1n) - 1n;
var maxInt224 = 2n ** (224n - 1n) - 1n;
var maxInt232 = 2n ** (232n - 1n) - 1n;
var maxInt240 = 2n ** (240n - 1n) - 1n;
var maxInt248 = 2n ** (248n - 1n) - 1n;
var maxInt256 = 2n ** (256n - 1n) - 1n;
var minInt8 = -(2n ** (8n - 1n));
var minInt16 = -(2n ** (16n - 1n));
var minInt24 = -(2n ** (24n - 1n));
var minInt32 = -(2n ** (32n - 1n));
var minInt40 = -(2n ** (40n - 1n));
var minInt48 = -(2n ** (48n - 1n));
var minInt56 = -(2n ** (56n - 1n));
var minInt64 = -(2n ** (64n - 1n));
var minInt72 = -(2n ** (72n - 1n));
var minInt80 = -(2n ** (80n - 1n));
var minInt88 = -(2n ** (88n - 1n));
var minInt96 = -(2n ** (96n - 1n));
var minInt104 = -(2n ** (104n - 1n));
var minInt112 = -(2n ** (112n - 1n));
var minInt120 = -(2n ** (120n - 1n));
var minInt128 = -(2n ** (128n - 1n));
var minInt136 = -(2n ** (136n - 1n));
var minInt144 = -(2n ** (144n - 1n));
var minInt152 = -(2n ** (152n - 1n));
var minInt160 = -(2n ** (160n - 1n));
var minInt168 = -(2n ** (168n - 1n));
var minInt176 = -(2n ** (176n - 1n));
var minInt184 = -(2n ** (184n - 1n));
var minInt192 = -(2n ** (192n - 1n));
var minInt200 = -(2n ** (200n - 1n));
var minInt208 = -(2n ** (208n - 1n));
var minInt216 = -(2n ** (216n - 1n));
var minInt224 = -(2n ** (224n - 1n));
var minInt232 = -(2n ** (232n - 1n));
var minInt240 = -(2n ** (240n - 1n));
var minInt248 = -(2n ** (248n - 1n));
var minInt256 = -(2n ** (256n - 1n));
var maxUint8 = 2n ** 8n - 1n;
var maxUint162 = 2n ** 16n - 1n;
var maxUint24 = 2n ** 24n - 1n;
var maxUint32 = 2n ** 32n - 1n;
var maxUint40 = 2n ** 40n - 1n;
var maxUint48 = 2n ** 48n - 1n;
var maxUint56 = 2n ** 56n - 1n;
var maxUint64 = 2n ** 64n - 1n;
var maxUint72 = 2n ** 72n - 1n;
var maxUint80 = 2n ** 80n - 1n;
var maxUint88 = 2n ** 88n - 1n;
var maxUint96 = 2n ** 96n - 1n;
var maxUint104 = 2n ** 104n - 1n;
var maxUint112 = 2n ** 112n - 1n;
var maxUint120 = 2n ** 120n - 1n;
var maxUint128 = 2n ** 128n - 1n;
var maxUint136 = 2n ** 136n - 1n;
var maxUint144 = 2n ** 144n - 1n;
var maxUint152 = 2n ** 152n - 1n;
var maxUint160 = 2n ** 160n - 1n;
var maxUint168 = 2n ** 168n - 1n;
var maxUint176 = 2n ** 176n - 1n;
var maxUint184 = 2n ** 184n - 1n;
var maxUint192 = 2n ** 192n - 1n;
var maxUint200 = 2n ** 200n - 1n;
var maxUint208 = 2n ** 208n - 1n;
var maxUint216 = 2n ** 216n - 1n;
var maxUint224 = 2n ** 224n - 1n;
var maxUint232 = 2n ** 232n - 1n;
var maxUint240 = 2n ** 240n - 1n;
var maxUint248 = 2n ** 248n - 1n;
var maxUint2563 = 2n ** 256n - 1n;

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/internal/cursor.js
var staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError2({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position - offset;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position + offset;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length - 1);
    return this.bytes.subarray(position, position + length);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes) {
    this.assertPosition(this.position + bytes.length - 1);
    this.bytes.set(bytes, this.position);
    this.position += bytes.length;
  },
  pushUint8(value) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value;
    this.position++;
  },
  pushUint16(value) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value);
    this.position += 2;
  },
  pushUint24(value) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value >> 8);
    this.dataView.setUint8(this.position + 2, value & ~4294967040);
    this.position += 3;
  },
  pushUint32(value) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectByte();
    this.position++;
    return value;
  },
  readBytes(length, size7) {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectBytes(length);
    this.position += size7 ?? length;
    return value;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint8();
    this.position += 1;
    return value;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint16();
    this.position += 2;
    return value;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint24();
    this.position += 3;
    return value;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint32();
    this.position += 4;
    return value;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const count = this.getReadCount();
    this.positionReadCount.set(this.position, count + 1);
    if (count > 0)
      this.recursiveReadCount++;
  }
};
var NegativeOffsetError = class extends BaseError3 {
  constructor({ offset }) {
    super(`Offset \`${offset}\` cannot be negative.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.NegativeOffsetError"
    });
  }
};
var PositionOutOfBoundsError2 = class extends BaseError3 {
  constructor({ length, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.PositionOutOfBoundsError"
    });
  }
};
var RecursiveReadLimitExceededError = class extends BaseError3 {
  constructor({ count, limit }) {
    super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.RecursiveReadLimitExceededError"
    });
  }
};

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/AbiParameters.js
function encodePacked2(types, values) {
  if (types.length !== values.length)
    throw new LengthMismatchError({
      expectedLength: types.length,
      givenLength: values.length
    });
  const data = [];
  for (let i3 = 0; i3 < types.length; i3++) {
    const type = types[i3];
    const value = values[i3];
    data.push(encodePacked2.encode(type, value));
  }
  return concat3(...data);
}
(function(encodePacked5) {
  function encode7(type, value, isArray = false) {
    if (type === "address") {
      const address = value;
      assert(address);
      return padLeft(address.toLowerCase(), isArray ? 32 : 0);
    }
    if (type === "string")
      return fromString3(value);
    if (type === "bytes")
      return value;
    if (type === "bool")
      return padLeft(fromBoolean(value), isArray ? 32 : 1);
    const intMatch = type.match(integerRegex2);
    if (intMatch) {
      const [_type, baseType, bits = "256"] = intMatch;
      const size7 = Number.parseInt(bits) / 8;
      return fromNumber(value, {
        size: isArray ? 32 : size7,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type.match(bytesRegex2);
    if (bytesMatch) {
      const [_type, size7] = bytesMatch;
      if (Number.parseInt(size7) !== (value.length - 2) / 2)
        throw new BytesSizeMismatchError2({
          expectedSize: Number.parseInt(size7),
          value
        });
      return padRight(value, isArray ? 32 : 0);
    }
    const arrayMatch = type.match(arrayRegex2);
    if (arrayMatch && Array.isArray(value)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (let i3 = 0; i3 < value.length; i3++) {
        data.push(encode7(childType, value[i3], true));
      }
      if (data.length === 0)
        return "0x";
      return concat3(...data);
    }
    throw new InvalidTypeError(type);
  }
  encodePacked5.encode = encode7;
})(encodePacked2 || (encodePacked2 = {}));
var BytesSizeMismatchError2 = class extends BaseError3 {
  constructor({ expectedSize, value }) {
    super(`Size of bytes "${value}" (bytes${size3(value)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
};
var LengthMismatchError = class extends BaseError3 {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.LengthMismatchError"
    });
  }
};
var InvalidTypeError = class extends BaseError3 {
  constructor(type) {
    super(`Type \`${type}\` is not a valid ABI Type.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidTypeError"
    });
  }
};

// node_modules/@walletconnect/utils/dist/index.es.js
var import_elliptic = __toESM(require_elliptic());
var Pe = ":";
function Ye(e) {
  const [t, n3] = e.split(Pe);
  return { namespace: t, reference: n3 };
}
function Xe(e) {
  const [t, n3, r2] = e.split(Pe);
  return { namespace: t, reference: n3, address: r2 };
}
function Le(e, t) {
  return e.includes(":") ? [e] : t.chains || [];
}
var Ft = "ReactNative";
var H = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var Gt = "js";
function et() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function ne() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === Ft;
}
function Wr() {
  return ne() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android";
}
function zr() {
  return ne() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios";
}
function Ae() {
  return !et() && !!(0, import_window_getters.getNavigator)() && !!(0, import_window_getters.getDocument)();
}
function ue() {
  return ne() ? H.reactNative : et() ? H.node : Ae() ? H.browser : H.unknown;
}
function Jr() {
  var e;
  try {
    return ne() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e = global.Application) == null ? void 0 : e.applicationId : void 0;
  } catch {
    return;
  }
}
function Wt(e, t) {
  const n3 = new URLSearchParams(e);
  for (const r2 of Object.keys(t).sort()) if (t.hasOwnProperty(r2)) {
    const o3 = t[r2];
    o3 !== void 0 && n3.set(r2, o3);
  }
  return n3.toString();
}
function Yr() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function zt() {
  if (ue() === H.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: n3, Version: r2 } = global.Platform;
    return [n3, r2].join("-");
  }
  const e = detect();
  if (e === null) return "unknown";
  const t = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [t, e.name, e.version].join("-") : [t, e.version].join("-");
}
function Jt() {
  var e;
  const t = ue();
  return t === H.browser ? [t, ((e = (0, import_window_getters.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : t;
}
function Yt(e, t, n3) {
  const r2 = zt(), o3 = Jt();
  return [[e, t].join("-"), [Gt, n3].join("-"), r2, o3].join("/");
}
function Zr({ protocol: e, version: t, relayUrl: n3, sdkVersion: r2, auth: o3, projectId: s, useOnCloseEvent: i3, bundleId: c6, packageName: u3 }) {
  const a2 = n3.split("?"), l5 = Yt(e, t, r2), f10 = { auth: o3, ua: l5, projectId: s, useOnCloseEvent: i3 || void 0, packageName: u3 || void 0, bundleId: c6 || void 0 }, d5 = Wt(a2[1] || "", f10);
  return a2[0] + "?" + d5;
}
function re(e, t) {
  return e.filter((n3) => t.includes(n3)).length === e.length;
}
function no(e) {
  return Object.fromEntries(e.entries());
}
function ro(e) {
  return new Map(Object.entries(e));
}
function co(e = import_time.FIVE_MINUTES, t) {
  const n3 = (0, import_time.toMiliseconds)(e || import_time.FIVE_MINUTES);
  let r2, o3, s, i3;
  return { resolve: (c6) => {
    s && r2 && (clearTimeout(s), r2(c6), i3 = Promise.resolve(c6));
  }, reject: (c6) => {
    s && o3 && (clearTimeout(s), o3(c6));
  }, done: () => new Promise((c6, u3) => {
    if (i3) return c6(i3);
    s = setTimeout(() => {
      const a2 = new Error(t);
      i3 = Promise.reject(a2), u3(a2);
    }, n3), r2 = c6, o3 = u3;
  }) };
}
function ao(e, t, n3) {
  return new Promise(async (r2, o3) => {
    const s = setTimeout(() => o3(new Error(n3)), t);
    try {
      const i3 = await e;
      r2(i3);
    } catch (i3) {
      o3(i3);
    }
    clearTimeout(s);
  });
}
function tt(e, t) {
  if (typeof t == "string" && t.startsWith(`${e}:`)) return t;
  if (e.toLowerCase() === "topic") {
    if (typeof t != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${t}`;
  } else if (e.toLowerCase() === "id") {
    if (typeof t != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${t}`;
  }
  throw new Error(`Unknown expirer target type: ${e}`);
}
function uo(e) {
  return tt("topic", e);
}
function fo(e) {
  return tt("id", e);
}
function lo(e) {
  const [t, n3] = e.split(":"), r2 = { id: void 0, topic: void 0 };
  if (t === "topic" && typeof n3 == "string") r2.topic = n3;
  else if (t === "id" && Number.isInteger(Number(n3))) r2.id = Number(n3);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${n3}`);
  return r2;
}
function ho(e, t) {
  return (0, import_time.fromMiliseconds)((t || Date.now()) + (0, import_time.toMiliseconds)(e));
}
function po(e) {
  return Date.now() >= (0, import_time.toMiliseconds)(e);
}
function go(e, t) {
  return `${e}${t ? `:${t}` : ""}`;
}
function Q(e = [], t = []) {
  return [.../* @__PURE__ */ new Set([...e, ...t])];
}
async function yo({ id: e, topic: t, wcDeepLink: n3 }) {
  var r2;
  try {
    if (!n3) return;
    const o3 = typeof n3 == "string" ? JSON.parse(n3) : n3, s = o3 == null ? void 0 : o3.href;
    if (typeof s != "string") return;
    const i3 = en(s, e, t), c6 = ue();
    if (c6 === H.browser) {
      if (!((r2 = (0, import_window_getters.getDocument)()) != null && r2.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      tn(i3);
    } else c6 === H.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(i3);
  } catch (o3) {
    console.error(o3);
  }
}
function en(e, t, n3) {
  const r2 = `requestId=${t}&sessionTopic=${n3}`;
  e.endsWith("/") && (e = e.slice(0, -1));
  let o3 = `${e}`;
  if (e.startsWith("https://t.me")) {
    const s = e.includes("?") ? "&startapp=" : "?startapp=";
    o3 = `${o3}${s}${on(r2, true)}`;
  } else o3 = `${o3}/wc?${r2}`;
  return o3;
}
function tn(e) {
  let t = "_self";
  rn() ? t = "_top" : (nn() || e.startsWith("https://") || e.startsWith("http://")) && (t = "_blank"), window.open(e, t, "noreferrer noopener");
}
async function mo(e, t) {
  let n3 = "";
  try {
    if (Ae() && (n3 = localStorage.getItem(t), n3)) return n3;
    n3 = await e.getItem(t);
  } catch (r2) {
    console.error(r2);
  }
  return n3;
}
function bo(e, t) {
  if (!e.includes(t)) return null;
  const n3 = e.split(/([&,?,=])/), r2 = n3.indexOf(t);
  return n3[r2 + 2];
}
function wo() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e) => {
    const t = Math.random() * 16 | 0;
    return (e === "x" ? t : t & 3 | 8).toString(16);
  });
}
function Eo() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function nn() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function rn() {
  try {
    return window.self !== window.top;
  } catch {
    return false;
  }
}
function on(e, t = false) {
  const n3 = Buffer.from(e).toString("base64");
  return t ? n3.replace(/[=]/g, "") : n3;
}
function rt(e) {
  return Buffer.from(e, "base64").toString("utf-8");
}
function vo(e) {
  return new Promise((t) => setTimeout(t, e));
}
function Ne(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error("positive integer expected, got " + e);
}
function xo(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function je(e, ...t) {
  if (!xo(e)) throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length)) throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length);
}
function ot(e) {
  if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Ne(e.outputLen), Ne(e.blockLen);
}
function me(e, t = true) {
  if (e.destroyed) throw new Error("Hash instance has been destroyed");
  if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function sn2(e, t) {
  je(e);
  const n3 = t.outputLen;
  if (e.length < n3) throw new Error("digestInto() expects output buffer of length at least " + n3);
}
var Ce = BigInt(2 ** 32 - 1);
var cn = BigInt(32);
function Oo(e, t = false) {
  return t ? { h: Number(e & Ce), l: Number(e >> cn & Ce) } : { h: Number(e >> cn & Ce) | 0, l: Number(e & Ce) | 0 };
}
function Io(e, t = false) {
  let n3 = new Uint32Array(e.length), r2 = new Uint32Array(e.length);
  for (let o3 = 0; o3 < e.length; o3++) {
    const { h: s, l: i3 } = Oo(e[o3], t);
    [n3[o3], r2[o3]] = [s, i3];
  }
  return [n3, r2];
}
var Ao = (e, t, n3) => e << n3 | t >>> 32 - n3;
var No = (e, t, n3) => t << n3 | e >>> 32 - n3;
var So = (e, t, n3) => t << n3 - 32 | e >>> 64 - n3;
var Uo = (e, t, n3) => e << n3 - 32 | t >>> 64 - n3;
var be = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function _o(e) {
  return new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
}
function st(e) {
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function J2(e, t) {
  return e << 32 - t | e >>> t;
}
var an = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function To(e) {
  return e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;
}
function un(e) {
  for (let t = 0; t < e.length; t++) e[t] = To(e[t]);
}
function $o(e) {
  if (typeof e != "string") throw new Error("utf8ToBytes expected string, got " + typeof e);
  return new Uint8Array(new TextEncoder().encode(e));
}
function we(e) {
  return typeof e == "string" && (e = $o(e)), je(e), e;
}
var it = class {
  clone() {
    return this._cloneInto();
  }
};
function fn(e) {
  const t = (r2) => e().update(we(r2)).digest(), n3 = e();
  return t.outputLen = n3.outputLen, t.blockLen = n3.blockLen, t.create = () => e(), t;
}
function Se(e = 32) {
  if (be && typeof be.getRandomValues == "function") return be.getRandomValues(new Uint8Array(e));
  if (be && typeof be.randomBytes == "function") return be.randomBytes(e);
  throw new Error("crypto.getRandomValues must be defined");
}
var ln = [];
var dn = [];
var hn = [];
var Ro = BigInt(0);
var Ue = BigInt(1);
var Po2 = BigInt(2);
var Lo = BigInt(7);
var Bo = BigInt(256);
var jo = BigInt(113);
for (let e = 0, t = Ue, n3 = 1, r2 = 0; e < 24; e++) {
  [n3, r2] = [r2, (2 * n3 + 3 * r2) % 5], ln.push(2 * (5 * r2 + n3)), dn.push((e + 1) * (e + 2) / 2 % 64);
  let o3 = Ro;
  for (let s = 0; s < 7; s++) t = (t << Ue ^ (t >> Lo) * jo) % Bo, t & Po2 && (o3 ^= Ue << (Ue << BigInt(s)) - Ue);
  hn.push(o3);
}
var [Co, ko] = Io(hn, true);
var pn = (e, t, n3) => n3 > 32 ? So(e, t, n3) : Ao(e, t, n3);
var gn = (e, t, n3) => n3 > 32 ? Uo(e, t, n3) : No(e, t, n3);
function Do(e, t = 24) {
  const n3 = new Uint32Array(10);
  for (let r2 = 24 - t; r2 < 24; r2++) {
    for (let i3 = 0; i3 < 10; i3++) n3[i3] = e[i3] ^ e[i3 + 10] ^ e[i3 + 20] ^ e[i3 + 30] ^ e[i3 + 40];
    for (let i3 = 0; i3 < 10; i3 += 2) {
      const c6 = (i3 + 8) % 10, u3 = (i3 + 2) % 10, a2 = n3[u3], l5 = n3[u3 + 1], f10 = pn(a2, l5, 1) ^ n3[c6], d5 = gn(a2, l5, 1) ^ n3[c6 + 1];
      for (let g3 = 0; g3 < 50; g3 += 10) e[i3 + g3] ^= f10, e[i3 + g3 + 1] ^= d5;
    }
    let o3 = e[2], s = e[3];
    for (let i3 = 0; i3 < 24; i3++) {
      const c6 = dn[i3], u3 = pn(o3, s, c6), a2 = gn(o3, s, c6), l5 = ln[i3];
      o3 = e[l5], s = e[l5 + 1], e[l5] = u3, e[l5 + 1] = a2;
    }
    for (let i3 = 0; i3 < 50; i3 += 10) {
      for (let c6 = 0; c6 < 10; c6++) n3[c6] = e[i3 + c6];
      for (let c6 = 0; c6 < 10; c6++) e[i3 + c6] ^= ~n3[(c6 + 2) % 10] & n3[(c6 + 4) % 10];
    }
    e[0] ^= Co[r2], e[1] ^= ko[r2];
  }
  n3.fill(0);
}
var Bt = class _Bt extends it {
  constructor(t, n3, r2, o3 = false, s = 24) {
    if (super(), this.blockLen = t, this.suffix = n3, this.outputLen = r2, this.enableXOF = o3, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, Ne(r2), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = _o(this.state);
  }
  keccak() {
    an || un(this.state32), Do(this.state32, this.rounds), an || un(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    me(this);
    const { blockLen: n3, state: r2 } = this;
    t = we(t);
    const o3 = t.length;
    for (let s = 0; s < o3; ) {
      const i3 = Math.min(n3 - this.pos, o3 - s);
      for (let c6 = 0; c6 < i3; c6++) r2[this.pos++] ^= t[s++];
      this.pos === n3 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: t, suffix: n3, pos: r2, blockLen: o3 } = this;
    t[r2] ^= n3, (n3 & 128) !== 0 && r2 === o3 - 1 && this.keccak(), t[o3 - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    me(this, false), je(t), this.finish();
    const n3 = this.state, { blockLen: r2 } = this;
    for (let o3 = 0, s = t.length; o3 < s; ) {
      this.posOut >= r2 && this.keccak();
      const i3 = Math.min(r2 - this.posOut, s - o3);
      t.set(n3.subarray(this.posOut, this.posOut + i3), o3), this.posOut += i3, o3 += i3;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return Ne(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (sn2(t, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: n3, suffix: r2, outputLen: o3, rounds: s, enableXOF: i3 } = this;
    return t || (t = new _Bt(n3, r2, o3, i3, s)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = s, t.suffix = r2, t.outputLen = o3, t.enableXOF = i3, t.destroyed = this.destroyed, t;
  }
};
var Mo = (e, t, n3) => fn(() => new Bt(t, e, n3));
var Vo = Mo(1, 136, 256 / 8);
var Ho = "https://rpc.walletconnect.org/v1";
function ct(e) {
  const t = `Ethereum Signed Message:
${e.length}`, n3 = new TextEncoder().encode(t + e);
  return "0x" + Buffer.from(Vo(n3)).toString("hex");
}
async function yn(e, t, n3, r2, o3, s) {
  switch (n3.t) {
    case "eip191":
      return await mn(e, t, n3.s);
    case "eip1271":
      return await bn(e, t, n3.s, r2, o3, s);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n3.t}`);
  }
}
async function mn(e, t, n3) {
  return (await recoverAddress({ hash: ct(t), signature: n3 })).toLowerCase() === e.toLowerCase();
}
async function bn(e, t, n3, r2, o3, s) {
  const i3 = Ye(r2);
  if (!i3.namespace || !i3.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r2}`);
  try {
    const c6 = "0x1626ba7e", u3 = "0000000000000000000000000000000000000000000000000000000000000040", a2 = "0000000000000000000000000000000000000000000000000000000000000041", l5 = n3.substring(2), f10 = ct(t).substring(2), d5 = c6 + f10 + u3 + a2 + l5, g3 = await fetch(`${s || Ho}/?chainId=${r2}&projectId=${o3}`, { method: "POST", body: JSON.stringify({ id: Ko(), jsonrpc: "2.0", method: "eth_call", params: [{ to: e, data: d5 }, "latest"] }) }), { result: y9 } = await g3.json();
    return y9 ? y9.slice(0, c6.length).toLowerCase() === c6.toLowerCase() : false;
  } catch (c6) {
    return console.error("isValidEip1271Signature: ", c6), false;
  }
}
function Ko() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
var Fo = Object.defineProperty;
var qo = Object.defineProperties;
var Go = Object.getOwnPropertyDescriptors;
var wn = Object.getOwnPropertySymbols;
var Wo = Object.prototype.hasOwnProperty;
var zo = Object.prototype.propertyIsEnumerable;
var En = (e, t, n3) => t in e ? Fo(e, t, { enumerable: true, configurable: true, writable: true, value: n3 }) : e[t] = n3;
var at = (e, t) => {
  for (var n3 in t || (t = {})) Wo.call(t, n3) && En(e, n3, t[n3]);
  if (wn) for (var n3 of wn(t)) zo.call(t, n3) && En(e, n3, t[n3]);
  return e;
};
var vn = (e, t) => qo(e, Go(t));
var Jo = "did:pkh:";
var ke = (e) => e == null ? void 0 : e.split(":");
var xn = (e) => {
  const t = e && ke(e);
  if (t) return e.includes(Jo) ? t[3] : t[1];
};
var On = (e) => {
  const t = e && ke(e);
  if (t) return t[2] + ":" + t[3];
};
var ut = (e) => {
  const t = e && ke(e);
  if (t) return t.pop();
};
async function Yo(e) {
  const { cacao: t, projectId: n3 } = e, { s: r2, p: o3 } = t, s = In(o3, o3.iss), i3 = ut(o3.iss);
  return await yn(i3, s, r2, On(o3.iss), n3);
}
var In = (e, t) => {
  const n3 = `${e.domain} wants you to sign in with your Ethereum account:`, r2 = ut(t);
  if (!e.aud && !e.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let o3 = e.statement || void 0;
  const s = `URI: ${e.aud || e.uri}`, i3 = `Version: ${e.version}`, c6 = `Chain ID: ${xn(t)}`, u3 = `Nonce: ${e.nonce}`, a2 = `Issued At: ${e.iat}`, l5 = e.exp ? `Expiration Time: ${e.exp}` : void 0, f10 = e.nbf ? `Not Before: ${e.nbf}` : void 0, d5 = e.requestId ? `Request ID: ${e.requestId}` : void 0, g3 = e.resources ? `Resources:${e.resources.map((h6) => `
- ${h6}`).join("")}` : void 0, y9 = Me(e.resources);
  if (y9) {
    const h6 = oe(y9);
    o3 = dt(o3, h6);
  }
  return [n3, r2, "", o3, "", s, i3, c6, u3, a2, l5, f10, d5, g3].filter((h6) => h6 != null).join(`
`);
};
function Un(e) {
  return Buffer.from(JSON.stringify(e)).toString("base64");
}
function _n(e) {
  return JSON.parse(Buffer.from(e, "base64").toString("utf-8"));
}
function Y(e) {
  if (!e) throw new Error("No recap provided, value is undefined");
  if (!e.att) throw new Error("No `att` property found");
  const t = Object.keys(e.att);
  if (!(t != null && t.length)) throw new Error("No resources found in `att` property");
  t.forEach((n3) => {
    const r2 = e.att[n3];
    if (Array.isArray(r2)) throw new Error(`Resource must be an object: ${n3}`);
    if (typeof r2 != "object") throw new Error(`Resource must be an object: ${n3}`);
    if (!Object.keys(r2).length) throw new Error(`Resource object is empty: ${n3}`);
    Object.keys(r2).forEach((o3) => {
      const s = r2[o3];
      if (!Array.isArray(s)) throw new Error(`Ability limits ${o3} must be an array of objects, found: ${s}`);
      if (!s.length) throw new Error(`Value of ${o3} is empty array, must be an array with objects`);
      s.forEach((i3) => {
        if (typeof i3 != "object") throw new Error(`Ability limits (${o3}) must be an array of objects, found: ${i3}`);
      });
    });
  });
}
function Tn(e, t, n3, r2 = {}) {
  return n3 == null ? void 0 : n3.sort((o3, s) => o3.localeCompare(s)), { att: { [e]: ft(t, n3, r2) } };
}
function ft(e, t, n3 = {}) {
  t = t == null ? void 0 : t.sort((o3, s) => o3.localeCompare(s));
  const r2 = t.map((o3) => ({ [`${e}/${o3}`]: [n3] }));
  return Object.assign({}, ...r2);
}
function De(e) {
  return Y(e), `urn:recap:${Un(e).replace(/=/g, "")}`;
}
function oe(e) {
  const t = _n(e.replace("urn:recap:", ""));
  return Y(t), t;
}
function ts(e, t, n3) {
  const r2 = Tn(e, t, n3);
  return De(r2);
}
function lt(e) {
  return e && e.includes("urn:recap:");
}
function ns(e, t) {
  const n3 = oe(e), r2 = oe(t), o3 = Rn(n3, r2);
  return De(o3);
}
function Rn(e, t) {
  Y(e), Y(t);
  const n3 = Object.keys(e.att).concat(Object.keys(t.att)).sort((o3, s) => o3.localeCompare(s)), r2 = { att: {} };
  return n3.forEach((o3) => {
    var s, i3;
    Object.keys(((s = e.att) == null ? void 0 : s[o3]) || {}).concat(Object.keys(((i3 = t.att) == null ? void 0 : i3[o3]) || {})).sort((c6, u3) => c6.localeCompare(u3)).forEach((c6) => {
      var u3, a2;
      r2.att[o3] = vn(at({}, r2.att[o3]), { [c6]: ((u3 = e.att[o3]) == null ? void 0 : u3[c6]) || ((a2 = t.att[o3]) == null ? void 0 : a2[c6]) });
    });
  }), r2;
}
function dt(e = "", t) {
  Y(t);
  const n3 = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (e.includes(n3)) return e;
  const r2 = [];
  let o3 = 0;
  Object.keys(t.att).forEach((c6) => {
    const u3 = Object.keys(t.att[c6]).map((f10) => ({ ability: f10.split("/")[0], action: f10.split("/")[1] }));
    u3.sort((f10, d5) => f10.action.localeCompare(d5.action));
    const a2 = {};
    u3.forEach((f10) => {
      a2[f10.ability] || (a2[f10.ability] = []), a2[f10.ability].push(f10.action);
    });
    const l5 = Object.keys(a2).map((f10) => (o3++, `(${o3}) '${f10}': '${a2[f10].join("', '")}' for '${c6}'.`));
    r2.push(l5.join(", ").replace(".,", "."));
  });
  const s = r2.join(" "), i3 = `${n3}${s}`;
  return `${e ? e + " " : ""}${i3}`;
}
function rs(e) {
  var t;
  const n3 = oe(e);
  Y(n3);
  const r2 = (t = n3.att) == null ? void 0 : t.eip155;
  return r2 ? Object.keys(r2).map((o3) => o3.split("/")[1]) : [];
}
function os(e) {
  const t = oe(e);
  Y(t);
  const n3 = [];
  return Object.values(t.att).forEach((r2) => {
    Object.values(r2).forEach((o3) => {
      var s;
      (s = o3 == null ? void 0 : o3[0]) != null && s.chains && n3.push(o3[0].chains);
    });
  }), [...new Set(n3.flat())];
}
function Me(e) {
  if (!e) return;
  const t = e == null ? void 0 : e[e.length - 1];
  return lt(t) ? t : void 0;
}
function ht(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error("positive integer expected, got " + e);
}
function Ln(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function F(e, ...t) {
  if (!Ln(e)) throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length)) throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length);
}
function Bn(e, t = true) {
  if (e.destroyed) throw new Error("Hash instance has been destroyed");
  if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function ss(e, t) {
  F(e);
  const n3 = t.outputLen;
  if (e.length < n3) throw new Error("digestInto() expects output buffer of length at least " + n3);
}
function jn(e) {
  if (typeof e != "boolean") throw new Error(`boolean expected, not ${e}`);
}
var se = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
var is = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
var cs = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!cs) throw new Error("Non little-endian hardware is not supported");
function as(e) {
  if (typeof e != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(e));
}
function pt(e) {
  if (typeof e == "string") e = as(e);
  else if (Ln(e)) e = gt(e);
  else throw new Error("Uint8Array expected, got " + typeof e);
  return e;
}
function us(e, t) {
  if (t == null || typeof t != "object") throw new Error("options must be defined");
  return Object.assign(e, t);
}
function fs(e, t) {
  if (e.length !== t.length) return false;
  let n3 = 0;
  for (let r2 = 0; r2 < e.length; r2++) n3 |= e[r2] ^ t[r2];
  return n3 === 0;
}
var ls = (e, t) => {
  function n3(r2, ...o3) {
    if (F(r2), e.nonceLength !== void 0) {
      const l5 = o3[0];
      if (!l5) throw new Error("nonce / iv required");
      e.varSizeNonce ? F(l5) : F(l5, e.nonceLength);
    }
    const s = e.tagLength;
    s && o3[1] !== void 0 && F(o3[1]);
    const i3 = t(r2, ...o3), c6 = (l5, f10) => {
      if (f10 !== void 0) {
        if (l5 !== 2) throw new Error("cipher output not supported");
        F(f10);
      }
    };
    let u3 = false;
    return { encrypt(l5, f10) {
      if (u3) throw new Error("cannot encrypt() twice with same key + nonce");
      return u3 = true, F(l5), c6(i3.encrypt.length, f10), i3.encrypt(l5, f10);
    }, decrypt(l5, f10) {
      if (F(l5), s && l5.length < s) throw new Error("invalid ciphertext length: smaller than tagLength=" + s);
      return c6(i3.decrypt.length, f10), i3.decrypt(l5, f10);
    } };
  }
  return Object.assign(n3, e), n3;
};
function Cn(e, t, n3 = true) {
  if (t === void 0) return new Uint8Array(e);
  if (t.length !== e) throw new Error("invalid output length, expected " + e + ", got: " + t.length);
  if (n3 && !ds(t)) throw new Error("invalid output, must be aligned");
  return t;
}
function kn(e, t, n3, r2) {
  if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, n3, r2);
  const o3 = BigInt(32), s = BigInt(4294967295), i3 = Number(n3 >> o3 & s), c6 = Number(n3 & s), u3 = r2 ? 4 : 0, a2 = r2 ? 0 : 4;
  e.setUint32(t + u3, i3, r2), e.setUint32(t + a2, c6, r2);
}
function ds(e) {
  return e.byteOffset % 4 === 0;
}
function gt(e) {
  return Uint8Array.from(e);
}
function Ee(...e) {
  for (let t = 0; t < e.length; t++) e[t].fill(0);
}
var Dn = (e) => Uint8Array.from(e.split("").map((t) => t.charCodeAt(0)));
var hs = Dn("expand 16-byte k");
var ps = Dn("expand 32-byte k");
var gs = se(hs);
var ys = se(ps);
function x2(e, t) {
  return e << t | e >>> 32 - t;
}
function yt(e) {
  return e.byteOffset % 4 === 0;
}
var Ve = 64;
var ms = 16;
var Mn = 2 ** 32 - 1;
var Vn = new Uint32Array();
function bs(e, t, n3, r2, o3, s, i3, c6) {
  const u3 = o3.length, a2 = new Uint8Array(Ve), l5 = se(a2), f10 = yt(o3) && yt(s), d5 = f10 ? se(o3) : Vn, g3 = f10 ? se(s) : Vn;
  for (let y9 = 0; y9 < u3; i3++) {
    if (e(t, n3, r2, l5, i3, c6), i3 >= Mn) throw new Error("arx: counter overflow");
    const h6 = Math.min(Ve, u3 - y9);
    if (f10 && h6 === Ve) {
      const m3 = y9 / 4;
      if (y9 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let B5 = 0, b4; B5 < ms; B5++) b4 = m3 + B5, g3[b4] = d5[b4] ^ l5[B5];
      y9 += Ve;
      continue;
    }
    for (let m3 = 0, B5; m3 < h6; m3++) B5 = y9 + m3, s[B5] = o3[B5] ^ a2[m3];
    y9 += h6;
  }
}
function ws(e, t) {
  const { allowShortKeys: n3, extendNonceFn: r2, counterLength: o3, counterRight: s, rounds: i3 } = us({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, t);
  if (typeof e != "function") throw new Error("core must be a function");
  return ht(o3), ht(i3), jn(s), jn(n3), (c6, u3, a2, l5, f10 = 0) => {
    F(c6), F(u3), F(a2);
    const d5 = a2.length;
    if (l5 === void 0 && (l5 = new Uint8Array(d5)), F(l5), ht(f10), f10 < 0 || f10 >= Mn) throw new Error("arx: counter overflow");
    if (l5.length < d5) throw new Error(`arx: output (${l5.length}) is shorter than data (${d5})`);
    const g3 = [];
    let y9 = c6.length, h6, m3;
    if (y9 === 32) g3.push(h6 = gt(c6)), m3 = ys;
    else if (y9 === 16 && n3) h6 = new Uint8Array(32), h6.set(c6), h6.set(c6, 16), m3 = gs, g3.push(h6);
    else throw new Error(`arx: invalid 32-byte key, got length=${y9}`);
    yt(u3) || g3.push(u3 = gt(u3));
    const B5 = se(h6);
    if (r2) {
      if (u3.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r2(m3, B5, se(u3.subarray(0, 16)), B5), u3 = u3.subarray(16);
    }
    const b4 = 16 - o3;
    if (b4 !== u3.length) throw new Error(`arx: nonce must be ${b4} or 16 bytes`);
    if (b4 !== 12) {
      const I5 = new Uint8Array(12);
      I5.set(u3, s ? 0 : 12 - u3.length), u3 = I5, g3.push(u3);
    }
    const _7 = se(u3);
    return bs(e, m3, B5, _7, a2, l5, f10, i3), Ee(...g3), l5;
  };
}
var M3 = (e, t) => e[t++] & 255 | (e[t++] & 255) << 8;
var Es = class {
  constructor(t) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, t = pt(t), F(t, 32);
    const n3 = M3(t, 0), r2 = M3(t, 2), o3 = M3(t, 4), s = M3(t, 6), i3 = M3(t, 8), c6 = M3(t, 10), u3 = M3(t, 12), a2 = M3(t, 14);
    this.r[0] = n3 & 8191, this.r[1] = (n3 >>> 13 | r2 << 3) & 8191, this.r[2] = (r2 >>> 10 | o3 << 6) & 7939, this.r[3] = (o3 >>> 7 | s << 9) & 8191, this.r[4] = (s >>> 4 | i3 << 12) & 255, this.r[5] = i3 >>> 1 & 8190, this.r[6] = (i3 >>> 14 | c6 << 2) & 8191, this.r[7] = (c6 >>> 11 | u3 << 5) & 8065, this.r[8] = (u3 >>> 8 | a2 << 8) & 8191, this.r[9] = a2 >>> 5 & 127;
    for (let l5 = 0; l5 < 8; l5++) this.pad[l5] = M3(t, 16 + 2 * l5);
  }
  process(t, n3, r2 = false) {
    const o3 = r2 ? 0 : 2048, { h: s, r: i3 } = this, c6 = i3[0], u3 = i3[1], a2 = i3[2], l5 = i3[3], f10 = i3[4], d5 = i3[5], g3 = i3[6], y9 = i3[7], h6 = i3[8], m3 = i3[9], B5 = M3(t, n3 + 0), b4 = M3(t, n3 + 2), _7 = M3(t, n3 + 4), I5 = M3(t, n3 + 6), k8 = M3(t, n3 + 8), E9 = M3(t, n3 + 10), L5 = M3(t, n3 + 12), j5 = M3(t, n3 + 14);
    let v6 = s[0] + (B5 & 8191), O8 = s[1] + ((B5 >>> 13 | b4 << 3) & 8191), w4 = s[2] + ((b4 >>> 10 | _7 << 6) & 8191), R6 = s[3] + ((_7 >>> 7 | I5 << 9) & 8191), A6 = s[4] + ((I5 >>> 4 | k8 << 12) & 8191), T4 = s[5] + (k8 >>> 1 & 8191), N7 = s[6] + ((k8 >>> 14 | E9 << 2) & 8191), S7 = s[7] + ((E9 >>> 11 | L5 << 5) & 8191), U3 = s[8] + ((L5 >>> 8 | j5 << 8) & 8191), $7 = s[9] + (j5 >>> 5 | o3), p6 = 0, C7 = p6 + v6 * c6 + O8 * (5 * m3) + w4 * (5 * h6) + R6 * (5 * y9) + A6 * (5 * g3);
    p6 = C7 >>> 13, C7 &= 8191, C7 += T4 * (5 * d5) + N7 * (5 * f10) + S7 * (5 * l5) + U3 * (5 * a2) + $7 * (5 * u3), p6 += C7 >>> 13, C7 &= 8191;
    let D6 = p6 + v6 * u3 + O8 * c6 + w4 * (5 * m3) + R6 * (5 * h6) + A6 * (5 * y9);
    p6 = D6 >>> 13, D6 &= 8191, D6 += T4 * (5 * g3) + N7 * (5 * d5) + S7 * (5 * f10) + U3 * (5 * l5) + $7 * (5 * a2), p6 += D6 >>> 13, D6 &= 8191;
    let P6 = p6 + v6 * a2 + O8 * u3 + w4 * c6 + R6 * (5 * m3) + A6 * (5 * h6);
    p6 = P6 >>> 13, P6 &= 8191, P6 += T4 * (5 * y9) + N7 * (5 * g3) + S7 * (5 * d5) + U3 * (5 * f10) + $7 * (5 * l5), p6 += P6 >>> 13, P6 &= 8191;
    let G5 = p6 + v6 * l5 + O8 * a2 + w4 * u3 + R6 * c6 + A6 * (5 * m3);
    p6 = G5 >>> 13, G5 &= 8191, G5 += T4 * (5 * h6) + N7 * (5 * y9) + S7 * (5 * g3) + U3 * (5 * d5) + $7 * (5 * f10), p6 += G5 >>> 13, G5 &= 8191;
    let X2 = p6 + v6 * f10 + O8 * l5 + w4 * a2 + R6 * u3 + A6 * c6;
    p6 = X2 >>> 13, X2 &= 8191, X2 += T4 * (5 * m3) + N7 * (5 * h6) + S7 * (5 * y9) + U3 * (5 * g3) + $7 * (5 * d5), p6 += X2 >>> 13, X2 &= 8191;
    let Z4 = p6 + v6 * d5 + O8 * f10 + w4 * l5 + R6 * a2 + A6 * u3;
    p6 = Z4 >>> 13, Z4 &= 8191, Z4 += T4 * c6 + N7 * (5 * m3) + S7 * (5 * h6) + U3 * (5 * y9) + $7 * (5 * g3), p6 += Z4 >>> 13, Z4 &= 8191;
    let he5 = p6 + v6 * g3 + O8 * d5 + w4 * f10 + R6 * l5 + A6 * a2;
    p6 = he5 >>> 13, he5 &= 8191, he5 += T4 * u3 + N7 * c6 + S7 * (5 * m3) + U3 * (5 * h6) + $7 * (5 * y9), p6 += he5 >>> 13, he5 &= 8191;
    let pe5 = p6 + v6 * y9 + O8 * g3 + w4 * d5 + R6 * f10 + A6 * l5;
    p6 = pe5 >>> 13, pe5 &= 8191, pe5 += T4 * a2 + N7 * u3 + S7 * c6 + U3 * (5 * m3) + $7 * (5 * h6), p6 += pe5 >>> 13, pe5 &= 8191;
    let ge3 = p6 + v6 * h6 + O8 * y9 + w4 * g3 + R6 * d5 + A6 * f10;
    p6 = ge3 >>> 13, ge3 &= 8191, ge3 += T4 * l5 + N7 * a2 + S7 * u3 + U3 * c6 + $7 * (5 * m3), p6 += ge3 >>> 13, ge3 &= 8191;
    let ye5 = p6 + v6 * m3 + O8 * h6 + w4 * y9 + R6 * g3 + A6 * d5;
    p6 = ye5 >>> 13, ye5 &= 8191, ye5 += T4 * f10 + N7 * l5 + S7 * a2 + U3 * u3 + $7 * c6, p6 += ye5 >>> 13, ye5 &= 8191, p6 = (p6 << 2) + p6 | 0, p6 = p6 + C7 | 0, C7 = p6 & 8191, p6 = p6 >>> 13, D6 += p6, s[0] = C7, s[1] = D6, s[2] = P6, s[3] = G5, s[4] = X2, s[5] = Z4, s[6] = he5, s[7] = pe5, s[8] = ge3, s[9] = ye5;
  }
  finalize() {
    const { h: t, pad: n3 } = this, r2 = new Uint16Array(10);
    let o3 = t[1] >>> 13;
    t[1] &= 8191;
    for (let c6 = 2; c6 < 10; c6++) t[c6] += o3, o3 = t[c6] >>> 13, t[c6] &= 8191;
    t[0] += o3 * 5, o3 = t[0] >>> 13, t[0] &= 8191, t[1] += o3, o3 = t[1] >>> 13, t[1] &= 8191, t[2] += o3, r2[0] = t[0] + 5, o3 = r2[0] >>> 13, r2[0] &= 8191;
    for (let c6 = 1; c6 < 10; c6++) r2[c6] = t[c6] + o3, o3 = r2[c6] >>> 13, r2[c6] &= 8191;
    r2[9] -= 8192;
    let s = (o3 ^ 1) - 1;
    for (let c6 = 0; c6 < 10; c6++) r2[c6] &= s;
    s = ~s;
    for (let c6 = 0; c6 < 10; c6++) t[c6] = t[c6] & s | r2[c6];
    t[0] = (t[0] | t[1] << 13) & 65535, t[1] = (t[1] >>> 3 | t[2] << 10) & 65535, t[2] = (t[2] >>> 6 | t[3] << 7) & 65535, t[3] = (t[3] >>> 9 | t[4] << 4) & 65535, t[4] = (t[4] >>> 12 | t[5] << 1 | t[6] << 14) & 65535, t[5] = (t[6] >>> 2 | t[7] << 11) & 65535, t[6] = (t[7] >>> 5 | t[8] << 8) & 65535, t[7] = (t[8] >>> 8 | t[9] << 5) & 65535;
    let i3 = t[0] + n3[0];
    t[0] = i3 & 65535;
    for (let c6 = 1; c6 < 8; c6++) i3 = (t[c6] + n3[c6] | 0) + (i3 >>> 16) | 0, t[c6] = i3 & 65535;
    Ee(r2);
  }
  update(t) {
    Bn(this);
    const { buffer: n3, blockLen: r2 } = this;
    t = pt(t);
    const o3 = t.length;
    for (let s = 0; s < o3; ) {
      const i3 = Math.min(r2 - this.pos, o3 - s);
      if (i3 === r2) {
        for (; r2 <= o3 - s; s += r2) this.process(t, s);
        continue;
      }
      n3.set(t.subarray(s, s + i3), this.pos), this.pos += i3, s += i3, this.pos === r2 && (this.process(n3, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Ee(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(t) {
    Bn(this), ss(t, this), this.finished = true;
    const { buffer: n3, h: r2 } = this;
    let { pos: o3 } = this;
    if (o3) {
      for (n3[o3++] = 1; o3 < 16; o3++) n3[o3] = 0;
      this.process(n3, 0, true);
    }
    this.finalize();
    let s = 0;
    for (let i3 = 0; i3 < 8; i3++) t[s++] = r2[i3] >>> 0, t[s++] = r2[i3] >>> 8;
    return t;
  }
  digest() {
    const { buffer: t, outputLen: n3 } = this;
    this.digestInto(t);
    const r2 = t.slice(0, n3);
    return this.destroy(), r2;
  }
};
function vs(e) {
  const t = (r2, o3) => e(o3).update(pt(r2)).digest(), n3 = e(new Uint8Array(32));
  return t.outputLen = n3.outputLen, t.blockLen = n3.blockLen, t.create = (r2) => e(r2), t;
}
var xs = vs((e) => new Es(e));
function Os(e, t, n3, r2, o3, s = 20) {
  let i3 = e[0], c6 = e[1], u3 = e[2], a2 = e[3], l5 = t[0], f10 = t[1], d5 = t[2], g3 = t[3], y9 = t[4], h6 = t[5], m3 = t[6], B5 = t[7], b4 = o3, _7 = n3[0], I5 = n3[1], k8 = n3[2], E9 = i3, L5 = c6, j5 = u3, v6 = a2, O8 = l5, w4 = f10, R6 = d5, A6 = g3, T4 = y9, N7 = h6, S7 = m3, U3 = B5, $7 = b4, p6 = _7, C7 = I5, D6 = k8;
  for (let G5 = 0; G5 < s; G5 += 2) E9 = E9 + O8 | 0, $7 = x2($7 ^ E9, 16), T4 = T4 + $7 | 0, O8 = x2(O8 ^ T4, 12), E9 = E9 + O8 | 0, $7 = x2($7 ^ E9, 8), T4 = T4 + $7 | 0, O8 = x2(O8 ^ T4, 7), L5 = L5 + w4 | 0, p6 = x2(p6 ^ L5, 16), N7 = N7 + p6 | 0, w4 = x2(w4 ^ N7, 12), L5 = L5 + w4 | 0, p6 = x2(p6 ^ L5, 8), N7 = N7 + p6 | 0, w4 = x2(w4 ^ N7, 7), j5 = j5 + R6 | 0, C7 = x2(C7 ^ j5, 16), S7 = S7 + C7 | 0, R6 = x2(R6 ^ S7, 12), j5 = j5 + R6 | 0, C7 = x2(C7 ^ j5, 8), S7 = S7 + C7 | 0, R6 = x2(R6 ^ S7, 7), v6 = v6 + A6 | 0, D6 = x2(D6 ^ v6, 16), U3 = U3 + D6 | 0, A6 = x2(A6 ^ U3, 12), v6 = v6 + A6 | 0, D6 = x2(D6 ^ v6, 8), U3 = U3 + D6 | 0, A6 = x2(A6 ^ U3, 7), E9 = E9 + w4 | 0, D6 = x2(D6 ^ E9, 16), S7 = S7 + D6 | 0, w4 = x2(w4 ^ S7, 12), E9 = E9 + w4 | 0, D6 = x2(D6 ^ E9, 8), S7 = S7 + D6 | 0, w4 = x2(w4 ^ S7, 7), L5 = L5 + R6 | 0, $7 = x2($7 ^ L5, 16), U3 = U3 + $7 | 0, R6 = x2(R6 ^ U3, 12), L5 = L5 + R6 | 0, $7 = x2($7 ^ L5, 8), U3 = U3 + $7 | 0, R6 = x2(R6 ^ U3, 7), j5 = j5 + A6 | 0, p6 = x2(p6 ^ j5, 16), T4 = T4 + p6 | 0, A6 = x2(A6 ^ T4, 12), j5 = j5 + A6 | 0, p6 = x2(p6 ^ j5, 8), T4 = T4 + p6 | 0, A6 = x2(A6 ^ T4, 7), v6 = v6 + O8 | 0, C7 = x2(C7 ^ v6, 16), N7 = N7 + C7 | 0, O8 = x2(O8 ^ N7, 12), v6 = v6 + O8 | 0, C7 = x2(C7 ^ v6, 8), N7 = N7 + C7 | 0, O8 = x2(O8 ^ N7, 7);
  let P6 = 0;
  r2[P6++] = i3 + E9 | 0, r2[P6++] = c6 + L5 | 0, r2[P6++] = u3 + j5 | 0, r2[P6++] = a2 + v6 | 0, r2[P6++] = l5 + O8 | 0, r2[P6++] = f10 + w4 | 0, r2[P6++] = d5 + R6 | 0, r2[P6++] = g3 + A6 | 0, r2[P6++] = y9 + T4 | 0, r2[P6++] = h6 + N7 | 0, r2[P6++] = m3 + S7 | 0, r2[P6++] = B5 + U3 | 0, r2[P6++] = b4 + $7 | 0, r2[P6++] = _7 + p6 | 0, r2[P6++] = I5 + C7 | 0, r2[P6++] = k8 + D6 | 0;
}
var Is = ws(Os, { counterRight: false, counterLength: 4, allowShortKeys: false });
var As = new Uint8Array(16);
var Hn = (e, t) => {
  e.update(t);
  const n3 = t.length % 16;
  n3 && e.update(As.subarray(n3));
};
var Ns = new Uint8Array(32);
function Kn(e, t, n3, r2, o3) {
  const s = e(t, n3, Ns), i3 = xs.create(s);
  o3 && Hn(i3, o3), Hn(i3, r2);
  const c6 = new Uint8Array(16), u3 = is(c6);
  kn(u3, 0, BigInt(o3 ? o3.length : 0), true), kn(u3, 8, BigInt(r2.length), true), i3.update(c6);
  const a2 = i3.digest();
  return Ee(s, c6), a2;
}
var Ss = (e) => (t, n3, r2) => ({ encrypt(s, i3) {
  const c6 = s.length;
  i3 = Cn(c6 + 16, i3, false), i3.set(s);
  const u3 = i3.subarray(0, -16);
  e(t, n3, u3, u3, 1);
  const a2 = Kn(e, t, n3, u3, r2);
  return i3.set(a2, c6), Ee(a2), i3;
}, decrypt(s, i3) {
  i3 = Cn(s.length - 16, i3, false);
  const c6 = s.subarray(0, -16), u3 = s.subarray(-16), a2 = Kn(e, t, n3, c6, r2);
  if (!fs(u3, a2)) throw new Error("invalid tag");
  return i3.set(s.subarray(0, -16)), e(t, n3, i3, i3, 1), Ee(a2), i3;
} });
var Fn = ls({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Ss(Is));
var qn = class extends it {
  constructor(t, n3) {
    super(), this.finished = false, this.destroyed = false, ot(t);
    const r2 = we(n3);
    if (this.iHash = t.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o3 = this.blockLen, s = new Uint8Array(o3);
    s.set(r2.length > o3 ? t.create().update(r2).digest() : r2);
    for (let i3 = 0; i3 < s.length; i3++) s[i3] ^= 54;
    this.iHash.update(s), this.oHash = t.create();
    for (let i3 = 0; i3 < s.length; i3++) s[i3] ^= 106;
    this.oHash.update(s), s.fill(0);
  }
  update(t) {
    return me(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    me(this), je(t, this.outputLen), this.finished = true, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n3, iHash: r2, finished: o3, destroyed: s, blockLen: i3, outputLen: c6 } = this;
    return t = t, t.finished = o3, t.destroyed = s, t.blockLen = i3, t.outputLen = c6, t.oHash = n3._cloneInto(t.oHash), t.iHash = r2._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var mt = (e, t, n3) => new qn(e, t).update(n3).digest();
mt.create = (e, t) => new qn(e, t);
function Us(e, t, n3) {
  return ot(e), n3 === void 0 && (n3 = new Uint8Array(e.outputLen)), mt(e, we(n3), we(t));
}
var bt = new Uint8Array([0]);
var Gn = new Uint8Array();
function _s(e, t, n3, r2 = 32) {
  if (ot(e), Ne(r2), r2 > 255 * e.outputLen) throw new Error("Length should be <= 255*HashLen");
  const o3 = Math.ceil(r2 / e.outputLen);
  n3 === void 0 && (n3 = Gn);
  const s = new Uint8Array(o3 * e.outputLen), i3 = mt.create(e, t), c6 = i3._cloneInto(), u3 = new Uint8Array(i3.outputLen);
  for (let a2 = 0; a2 < o3; a2++) bt[0] = a2 + 1, c6.update(a2 === 0 ? Gn : u3).update(n3).update(bt).digestInto(u3), s.set(u3, e.outputLen * a2), i3._cloneInto(c6);
  return i3.destroy(), c6.destroy(), u3.fill(0), bt.fill(0), s.slice(0, r2);
}
var Ts = (e, t, n3, r2, o3) => _s(e, Us(e, t, n3), r2, o3);
function $s(e, t, n3, r2) {
  if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, n3, r2);
  const o3 = BigInt(32), s = BigInt(4294967295), i3 = Number(n3 >> o3 & s), c6 = Number(n3 & s), u3 = r2 ? 4 : 0, a2 = r2 ? 0 : 4;
  e.setUint32(t + u3, i3, r2), e.setUint32(t + a2, c6, r2);
}
function Rs(e, t, n3) {
  return e & t ^ ~e & n3;
}
function Ps(e, t, n3) {
  return e & t ^ e & n3 ^ t & n3;
}
var Ls = class extends it {
  constructor(t, n3, r2, o3) {
    super(), this.blockLen = t, this.outputLen = n3, this.padOffset = r2, this.isLE = o3, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t), this.view = st(this.buffer);
  }
  update(t) {
    me(this);
    const { view: n3, buffer: r2, blockLen: o3 } = this;
    t = we(t);
    const s = t.length;
    for (let i3 = 0; i3 < s; ) {
      const c6 = Math.min(o3 - this.pos, s - i3);
      if (c6 === o3) {
        const u3 = st(t);
        for (; o3 <= s - i3; i3 += o3) this.process(u3, i3);
        continue;
      }
      r2.set(t.subarray(i3, i3 + c6), this.pos), this.pos += c6, i3 += c6, this.pos === o3 && (this.process(n3, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    me(this), sn2(t, this), this.finished = true;
    const { buffer: n3, view: r2, blockLen: o3, isLE: s } = this;
    let { pos: i3 } = this;
    n3[i3++] = 128, this.buffer.subarray(i3).fill(0), this.padOffset > o3 - i3 && (this.process(r2, 0), i3 = 0);
    for (let f10 = i3; f10 < o3; f10++) n3[f10] = 0;
    $s(r2, o3 - 8, BigInt(this.length * 8), s), this.process(r2, 0);
    const c6 = st(t), u3 = this.outputLen;
    if (u3 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const a2 = u3 / 4, l5 = this.get();
    if (a2 > l5.length) throw new Error("_sha2: outputLen bigger than state");
    for (let f10 = 0; f10 < a2; f10++) c6.setUint32(4 * f10, l5[f10], s);
  }
  digest() {
    const { buffer: t, outputLen: n3 } = this;
    this.digestInto(t);
    const r2 = t.slice(0, n3);
    return this.destroy(), r2;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n3, buffer: r2, length: o3, finished: s, destroyed: i3, pos: c6 } = this;
    return t.length = o3, t.pos = c6, t.finished = s, t.destroyed = i3, o3 % n3 && t.buffer.set(r2), t;
  }
};
var Bs = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var ie = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var ce = new Uint32Array(64);
var js = class extends Ls {
  constructor() {
    super(64, 32, 8, false), this.A = ie[0] | 0, this.B = ie[1] | 0, this.C = ie[2] | 0, this.D = ie[3] | 0, this.E = ie[4] | 0, this.F = ie[5] | 0, this.G = ie[6] | 0, this.H = ie[7] | 0;
  }
  get() {
    const { A: t, B: n3, C: r2, D: o3, E: s, F: i3, G: c6, H: u3 } = this;
    return [t, n3, r2, o3, s, i3, c6, u3];
  }
  set(t, n3, r2, o3, s, i3, c6, u3) {
    this.A = t | 0, this.B = n3 | 0, this.C = r2 | 0, this.D = o3 | 0, this.E = s | 0, this.F = i3 | 0, this.G = c6 | 0, this.H = u3 | 0;
  }
  process(t, n3) {
    for (let f10 = 0; f10 < 16; f10++, n3 += 4) ce[f10] = t.getUint32(n3, false);
    for (let f10 = 16; f10 < 64; f10++) {
      const d5 = ce[f10 - 15], g3 = ce[f10 - 2], y9 = J2(d5, 7) ^ J2(d5, 18) ^ d5 >>> 3, h6 = J2(g3, 17) ^ J2(g3, 19) ^ g3 >>> 10;
      ce[f10] = h6 + ce[f10 - 7] + y9 + ce[f10 - 16] | 0;
    }
    let { A: r2, B: o3, C: s, D: i3, E: c6, F: u3, G: a2, H: l5 } = this;
    for (let f10 = 0; f10 < 64; f10++) {
      const d5 = J2(c6, 6) ^ J2(c6, 11) ^ J2(c6, 25), g3 = l5 + d5 + Rs(c6, u3, a2) + Bs[f10] + ce[f10] | 0, h6 = (J2(r2, 2) ^ J2(r2, 13) ^ J2(r2, 22)) + Ps(r2, o3, s) | 0;
      l5 = a2, a2 = u3, u3 = c6, c6 = i3 + g3 | 0, i3 = s, s = o3, o3 = r2, r2 = g3 + h6 | 0;
    }
    r2 = r2 + this.A | 0, o3 = o3 + this.B | 0, s = s + this.C | 0, i3 = i3 + this.D | 0, c6 = c6 + this.E | 0, u3 = u3 + this.F | 0, a2 = a2 + this.G | 0, l5 = l5 + this.H | 0, this.set(r2, o3, s, i3, c6, u3, a2, l5);
  }
  roundClean() {
    ce.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var He = fn(() => new js());
var Wn = BigInt(0);
function wt(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function zn(e) {
  if (!wt(e)) throw new Error("Uint8Array expected");
}
var Cs = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function ks(e) {
  zn(e);
  let t = "";
  for (let n3 = 0; n3 < e.length; n3++) t += Cs[e[n3]];
  return t;
}
function Ds(e) {
  if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
  return e === "" ? Wn : BigInt("0x" + e);
}
var ee = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Jn(e) {
  if (e >= ee._0 && e <= ee._9) return e - ee._0;
  if (e >= ee.A && e <= ee.F) return e - (ee.A - 10);
  if (e >= ee.a && e <= ee.f) return e - (ee.a - 10);
}
function Yn(e) {
  if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
  const t = e.length, n3 = t / 2;
  if (t % 2) throw new Error("hex string expected, got unpadded hex of length " + t);
  const r2 = new Uint8Array(n3);
  for (let o3 = 0, s = 0; o3 < n3; o3++, s += 2) {
    const i3 = Jn(e.charCodeAt(s)), c6 = Jn(e.charCodeAt(s + 1));
    if (i3 === void 0 || c6 === void 0) {
      const u3 = e[s] + e[s + 1];
      throw new Error('hex string expected, got non-hex character "' + u3 + '" at index ' + s);
    }
    r2[o3] = i3 * 16 + c6;
  }
  return r2;
}
function Xn(e) {
  return zn(e), Ds(ks(Uint8Array.from(e).reverse()));
}
function Ms(e, t) {
  return Yn(e.toString(16).padStart(t * 2, "0"));
}
function Vs(e, t) {
  return Ms(e, t).reverse();
}
function Zn(e, t, n3) {
  let r2;
  if (typeof t == "string") try {
    r2 = Yn(t);
  } catch (s) {
    throw new Error(e + " must be hex string or Uint8Array, cause: " + s);
  }
  else if (wt(t)) r2 = Uint8Array.from(t);
  else throw new Error(e + " must be hex string or Uint8Array");
  const o3 = r2.length;
  if (typeof n3 == "number" && o3 !== n3) throw new Error(e + " of length " + n3 + " expected, got " + o3);
  return r2;
}
var Et = (e) => typeof e == "bigint" && Wn <= e;
function Hs(e, t, n3) {
  return Et(e) && Et(t) && Et(n3) && t <= e && e < n3;
}
function Qn(e, t, n3, r2) {
  if (!Hs(t, n3, r2)) throw new Error("expected valid " + e + ": " + n3 + " <= n < " + r2 + ", got " + t);
}
var Ks = { bigint: (e) => typeof e == "bigint", function: (e) => typeof e == "function", boolean: (e) => typeof e == "boolean", string: (e) => typeof e == "string", stringOrUint8Array: (e) => typeof e == "string" || wt(e), isSafeInteger: (e) => Number.isSafeInteger(e), array: (e) => Array.isArray(e), field: (e, t) => t.Fp.isValid(e), hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen) };
function Fs(e, t, n3 = {}) {
  const r2 = (o3, s, i3) => {
    const c6 = Ks[s];
    if (typeof c6 != "function") throw new Error("invalid validator function");
    const u3 = e[o3];
    if (!(i3 && u3 === void 0) && !c6(u3, e)) throw new Error("param " + String(o3) + " is invalid. Expected " + s + ", got " + u3);
  };
  for (const [o3, s] of Object.entries(t)) r2(o3, s, false);
  for (const [o3, s] of Object.entries(n3)) r2(o3, s, true);
  return e;
}
var ve = BigInt(0);
var Ke = BigInt(1);
function er(e, t) {
  const n3 = e % t;
  return n3 >= ve ? n3 : t + n3;
}
function qs(e, t, n3) {
  if (t < ve) throw new Error("invalid exponent, negatives unsupported");
  if (n3 <= ve) throw new Error("invalid modulus");
  if (n3 === Ke) return ve;
  let r2 = Ke;
  for (; t > ve; ) t & Ke && (r2 = r2 * e % n3), e = e * e % n3, t >>= Ke;
  return r2;
}
function z2(e, t, n3) {
  let r2 = e;
  for (; t-- > ve; ) r2 *= r2, r2 %= n3;
  return r2;
}
BigInt(0), BigInt(1), BigInt(0), BigInt(1), BigInt(2), BigInt(8);
var xe = BigInt(0);
var vt = BigInt(1);
function Gs(e) {
  return Fs(e, { a: "bigint" }, { montgomeryBits: "isSafeInteger", nByteLength: "isSafeInteger", adjustScalarBytes: "function", domain: "function", powPminus2: "function", Gu: "bigint" }), Object.freeze({ ...e });
}
function Ws(e) {
  const t = Gs(e), { P: n3 } = t, r2 = (b4) => er(b4, n3), o3 = t.montgomeryBits, s = Math.ceil(o3 / 8), i3 = t.nByteLength, c6 = t.adjustScalarBytes || ((b4) => b4), u3 = t.powPminus2 || ((b4) => qs(b4, n3 - BigInt(2), n3));
  function a2(b4, _7, I5) {
    const k8 = r2(b4 * (_7 - I5));
    return _7 = r2(_7 - k8), I5 = r2(I5 + k8), [_7, I5];
  }
  const l5 = (t.a - BigInt(2)) / BigInt(4);
  function f10(b4, _7) {
    Qn("u", b4, xe, n3), Qn("scalar", _7, xe, n3);
    const I5 = _7, k8 = b4;
    let E9 = vt, L5 = xe, j5 = b4, v6 = vt, O8 = xe, w4;
    for (let A6 = BigInt(o3 - 1); A6 >= xe; A6--) {
      const T4 = I5 >> A6 & vt;
      O8 ^= T4, w4 = a2(O8, E9, j5), E9 = w4[0], j5 = w4[1], w4 = a2(O8, L5, v6), L5 = w4[0], v6 = w4[1], O8 = T4;
      const N7 = E9 + L5, S7 = r2(N7 * N7), U3 = E9 - L5, $7 = r2(U3 * U3), p6 = S7 - $7, C7 = j5 + v6, D6 = j5 - v6, P6 = r2(D6 * N7), G5 = r2(C7 * U3), X2 = P6 + G5, Z4 = P6 - G5;
      j5 = r2(X2 * X2), v6 = r2(k8 * r2(Z4 * Z4)), E9 = r2(S7 * $7), L5 = r2(p6 * (S7 + r2(l5 * p6)));
    }
    w4 = a2(O8, E9, j5), E9 = w4[0], j5 = w4[1], w4 = a2(O8, L5, v6), L5 = w4[0], v6 = w4[1];
    const R6 = u3(L5);
    return r2(E9 * R6);
  }
  function d5(b4) {
    return Vs(r2(b4), s);
  }
  function g3(b4) {
    const _7 = Zn("u coordinate", b4, s);
    return i3 === 32 && (_7[31] &= 127), Xn(_7);
  }
  function y9(b4) {
    const _7 = Zn("scalar", b4), I5 = _7.length;
    if (I5 !== s && I5 !== i3) {
      let k8 = "" + s + " or " + i3;
      throw new Error("invalid scalar, expected " + k8 + " bytes, got " + I5);
    }
    return Xn(c6(_7));
  }
  function h6(b4, _7) {
    const I5 = g3(_7), k8 = y9(b4), E9 = f10(I5, k8);
    if (E9 === xe) throw new Error("invalid private or public key received");
    return d5(E9);
  }
  const m3 = d5(t.Gu);
  function B5(b4) {
    return h6(b4, m3);
  }
  return { scalarMult: h6, scalarMultBase: B5, getSharedSecret: (b4, _7) => h6(b4, _7), getPublicKey: (b4) => B5(b4), utils: { randomPrivateKey: () => t.randomBytes(t.nByteLength) }, GuBytes: m3 };
}
var xt = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
BigInt(0);
var zs = BigInt(1);
var tr = BigInt(2);
var Js = BigInt(3);
var Ys = BigInt(5);
BigInt(8);
function Xs(e) {
  const t = BigInt(10), n3 = BigInt(20), r2 = BigInt(40), o3 = BigInt(80), s = xt, c6 = e * e % s * e % s, u3 = z2(c6, tr, s) * c6 % s, a2 = z2(u3, zs, s) * e % s, l5 = z2(a2, Ys, s) * a2 % s, f10 = z2(l5, t, s) * l5 % s, d5 = z2(f10, n3, s) * f10 % s, g3 = z2(d5, r2, s) * d5 % s, y9 = z2(g3, o3, s) * g3 % s, h6 = z2(y9, o3, s) * g3 % s, m3 = z2(h6, t, s) * l5 % s;
  return { pow_p_5_8: z2(m3, tr, s) * e % s, b2: c6 };
}
function Zs(e) {
  return e[0] &= 248, e[31] &= 127, e[31] |= 64, e;
}
var Ot = Ws({ P: xt, a: BigInt(486662), montgomeryBits: 255, nByteLength: 32, Gu: BigInt(9), powPminus2: (e) => {
  const t = xt, { pow_p_5_8: n3, b2: r2 } = Xs(e);
  return er(z2(n3, Js, t) * r2, t);
}, adjustScalarBytes: Zs, randomBytes: Se });
var It = "base10";
var V2 = "base16";
var At = "base64pad";
var Qs = "base64url";
var Oe = "utf8";
var Nt = 0;
var Ie = 1;
var _e = 2;
var ei = 0;
var nr = 1;
var Te = 12;
var St = 32;
function ti() {
  const e = Ot.utils.randomPrivateKey(), t = Ot.getPublicKey(e);
  return { privateKey: toString(e, V2), publicKey: toString(t, V2) };
}
function ni() {
  const e = Se(St);
  return toString(e, V2);
}
function ri(e, t) {
  const n3 = Ot.getSharedSecret(fromString(e, V2), fromString(t, V2)), r2 = Ts(He, n3, void 0, void 0, St);
  return toString(r2, V2);
}
function oi(e) {
  const t = He(fromString(e, V2));
  return toString(t, V2);
}
function si(e) {
  const t = He(fromString(e, Oe));
  return toString(t, V2);
}
function Ut(e) {
  return fromString(`${e}`, It);
}
function fe(e) {
  return Number(toString(e, It));
}
function ii(e) {
  const t = Ut(typeof e.type < "u" ? e.type : Nt);
  if (fe(t) === Ie && typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const n3 = typeof e.senderPublicKey < "u" ? fromString(e.senderPublicKey, V2) : void 0, r2 = typeof e.iv < "u" ? fromString(e.iv, V2) : Se(Te), o3 = fromString(e.symKey, V2), s = Fn(o3, r2).encrypt(fromString(e.message, Oe));
  return _t({ type: t, sealed: s, iv: r2, senderPublicKey: n3, encoding: e.encoding });
}
function ci(e) {
  const t = fromString(e.symKey, V2), { sealed: n3, iv: r2 } = Fe(e), o3 = Fn(t, r2).decrypt(n3);
  if (o3 === null) throw new Error("Failed to decrypt");
  return toString(o3, Oe);
}
function ai(e, t) {
  const n3 = Ut(_e), r2 = Se(Te), o3 = fromString(e, Oe);
  return _t({ type: n3, sealed: o3, iv: r2, encoding: t });
}
function ui(e, t) {
  const { sealed: n3 } = Fe({ encoded: e, encoding: t });
  return toString(n3, Oe);
}
function _t(e) {
  const { encoding: t = At } = e;
  if (fe(e.type) === _e) return toString(concat([e.type, e.sealed]), t);
  if (fe(e.type) === Ie) {
    if (typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e.type, e.senderPublicKey, e.iv, e.sealed]), t);
  }
  return toString(concat([e.type, e.iv, e.sealed]), t);
}
function Fe(e) {
  const { encoded: t, encoding: n3 = At } = e, r2 = fromString(t, n3), o3 = r2.slice(ei, nr), s = nr;
  if (fe(o3) === Ie) {
    const a2 = s + St, l5 = a2 + Te, f10 = r2.slice(s, a2), d5 = r2.slice(a2, l5), g3 = r2.slice(l5);
    return { type: o3, sealed: g3, iv: d5, senderPublicKey: f10 };
  }
  if (fe(o3) === _e) {
    const a2 = r2.slice(s), l5 = Se(Te);
    return { type: o3, sealed: a2, iv: l5 };
  }
  const i3 = s + Te, c6 = r2.slice(s, i3), u3 = r2.slice(i3);
  return { type: o3, sealed: u3, iv: c6 };
}
function fi(e, t) {
  const n3 = Fe({ encoded: e, encoding: t == null ? void 0 : t.encoding });
  return rr({ type: fe(n3.type), senderPublicKey: typeof n3.senderPublicKey < "u" ? toString(n3.senderPublicKey, V2) : void 0, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey });
}
function rr(e) {
  const t = (e == null ? void 0 : e.type) || Nt;
  if (t === Ie) {
    if (typeof (e == null ? void 0 : e.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: t, senderPublicKey: e == null ? void 0 : e.senderPublicKey, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey };
}
function li(e) {
  return e.type === Ie && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
function di(e) {
  return e.type === _e;
}
function or(e) {
  return new import_elliptic.ec("p256").keyFromPublic({ x: Buffer.from(e.x, "base64").toString("hex"), y: Buffer.from(e.y, "base64").toString("hex") }, "hex");
}
function hi(e) {
  let t = e.replace(/-/g, "+").replace(/_/g, "/");
  const n3 = t.length % 4;
  return n3 > 0 && (t += "=".repeat(4 - n3)), t;
}
function pi(e) {
  return Buffer.from(hi(e), "base64");
}
function gi(e, t) {
  const [n3, r2, o3] = e.split("."), s = pi(o3);
  if (s.length !== 64) throw new Error("Invalid signature length");
  const i3 = s.slice(0, 32).toString("hex"), c6 = s.slice(32, 64).toString("hex"), u3 = `${n3}.${r2}`, a2 = He(u3), l5 = or(t), f10 = toString(a2, V2);
  if (!l5.verify(f10, { r: i3, s: c6 })) throw new Error("Invalid signature");
  return sn(e).payload;
}
var sr = "irn";
function yi(e) {
  return (e == null ? void 0 : e.relay) || { protocol: sr };
}
function mi(e) {
  const t = C[e];
  if (typeof t > "u") throw new Error(`Relay Protocol not supported: ${e}`);
  return t;
}
function ir(e, t = "-") {
  const n3 = {}, r2 = "relay" + t;
  return Object.keys(e).forEach((o3) => {
    if (o3.startsWith(r2)) {
      const s = o3.replace(r2, ""), i3 = e[o3];
      n3[s] = i3;
    }
  }), n3;
}
function bi(e) {
  if (!e.includes("wc:")) {
    const a2 = rt(e);
    a2 != null && a2.includes("wc:") && (e = a2);
  }
  e = e.includes("wc://") ? e.replace("wc://", "") : e, e = e.includes("wc:") ? e.replace("wc:", "") : e;
  const t = e.indexOf(":"), n3 = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r2 = e.substring(0, t), o3 = e.substring(t + 1, n3).split("@"), s = typeof n3 < "u" ? e.substring(n3) : "", i3 = new URLSearchParams(s), c6 = {};
  i3.forEach((a2, l5) => {
    c6[l5] = a2;
  });
  const u3 = typeof c6.methods == "string" ? c6.methods.split(",") : void 0;
  return { protocol: r2, topic: cr(o3[0]), version: parseInt(o3[1], 10), symKey: c6.symKey, relay: ir(c6), methods: u3, expiryTimestamp: c6.expiryTimestamp ? parseInt(c6.expiryTimestamp, 10) : void 0 };
}
function cr(e) {
  return e.startsWith("//") ? e.substring(2) : e;
}
function ar(e, t = "-") {
  const n3 = "relay", r2 = {};
  return Object.keys(e).forEach((o3) => {
    const s = o3, i3 = n3 + t + s;
    e[s] && (r2[i3] = e[s]);
  }), r2;
}
function wi(e) {
  const t = new URLSearchParams(), n3 = ar(e.relay);
  Object.keys(n3).sort().forEach((o3) => {
    t.set(o3, n3[o3]);
  }), t.set("symKey", e.symKey), e.expiryTimestamp && t.set("expiryTimestamp", e.expiryTimestamp.toString()), e.methods && t.set("methods", e.methods.join(","));
  const r2 = t.toString();
  return `${e.protocol}:${e.topic}@${e.version}?${r2}`;
}
function Ei(e, t, n3) {
  return `${e}?wc_ev=${n3}&topic=${t}`;
}
function le(e) {
  const t = [];
  return e.forEach((n3) => {
    const [r2, o3] = n3.split(":");
    t.push(`${r2}:${o3}`);
  }), t;
}
function lr(e) {
  const t = [];
  return Object.values(e).forEach((n3) => {
    t.push(...le(n3.accounts));
  }), t;
}
function dr(e, t) {
  const n3 = [];
  return Object.values(e).forEach((r2) => {
    le(r2.accounts).includes(t) && n3.push(...r2.methods);
  }), n3;
}
function hr(e, t) {
  const n3 = [];
  return Object.values(e).forEach((r2) => {
    le(r2.accounts).includes(t) && n3.push(...r2.events);
  }), n3;
}
function Tt(e) {
  return e.includes(":");
}
function pr(e) {
  return Tt(e) ? e.split(":")[0] : e;
}
function gr(e) {
  const t = {};
  return e == null ? void 0 : e.forEach((n3) => {
    var r2;
    const [o3, s] = n3.split(":");
    t[o3] || (t[o3] = { accounts: [], chains: [], events: [], methods: [] }), t[o3].accounts.push(n3), (r2 = t[o3].chains) == null || r2.push(`${o3}:${s}`);
  }), t;
}
function Ti(e, t) {
  t = t.map((r2) => r2.replace("did:pkh:", ""));
  const n3 = gr(t);
  for (const [r2, o3] of Object.entries(n3)) o3.methods ? o3.methods = Q(o3.methods, e) : o3.methods = e, o3.events = ["chainChanged", "accountsChanged"];
  return n3;
}
var yr = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var mr = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function te(e, t) {
  const { message: n3, code: r2 } = mr[e];
  return { message: t ? `${n3} ${t}` : n3, code: r2 };
}
function de(e, t) {
  const { message: n3, code: r2 } = yr[e];
  return { message: t ? `${n3} ${t}` : n3, code: r2 };
}
function $e(e, t) {
  return Array.isArray(e) ? typeof t < "u" && e.length ? e.every(t) : true : false;
}
function qe(e) {
  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;
}
function ae(e) {
  return typeof e > "u";
}
function q(e, t) {
  return t && ae(e) ? true : typeof e == "string" && !!e.trim().length;
}
function Ge(e, t) {
  return t && ae(e) ? true : typeof e == "number" && !isNaN(e);
}
function $i(e, t) {
  const { requiredNamespaces: n3 } = t, r2 = Object.keys(e.namespaces), o3 = Object.keys(n3);
  let s = true;
  return re(o3, r2) ? (r2.forEach((i3) => {
    const { accounts: c6, methods: u3, events: a2 } = e.namespaces[i3], l5 = le(c6), f10 = n3[i3];
    (!re(Le(i3, f10), l5) || !re(f10.methods, u3) || !re(f10.events, a2)) && (s = false);
  }), s) : false;
}
function Re(e) {
  return q(e, false) && e.includes(":") ? e.split(":").length === 2 : false;
}
function br(e) {
  if (q(e, false) && e.includes(":")) {
    const t = e.split(":");
    if (t.length === 3) {
      const n3 = t[0] + ":" + t[1];
      return !!t[2] && Re(n3);
    }
  }
  return false;
}
function Ri(e) {
  function t(n3) {
    try {
      return typeof new URL(n3) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (q(e, false)) {
      if (t(e)) return true;
      const n3 = rt(e);
      return t(n3);
    }
  } catch {
  }
  return false;
}
function Pi2(e) {
  var t;
  return (t = e == null ? void 0 : e.proposer) == null ? void 0 : t.publicKey;
}
function Li(e) {
  return e == null ? void 0 : e.topic;
}
function Bi(e, t) {
  let n3 = null;
  return q(e == null ? void 0 : e.publicKey, false) || (n3 = te("MISSING_OR_INVALID", `${t} controller public key should be a string`)), n3;
}
function Rt(e) {
  let t = true;
  return $e(e) ? e.length && (t = e.every((n3) => q(n3, false))) : t = false, t;
}
function wr(e, t, n3) {
  let r2 = null;
  return $e(t) && t.length ? t.forEach((o3) => {
    r2 || Re(o3) || (r2 = de("UNSUPPORTED_CHAINS", `${n3}, chain ${o3} should be a string and conform to "namespace:chainId" format`));
  }) : Re(e) || (r2 = de("UNSUPPORTED_CHAINS", `${n3}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r2;
}
function Er(e, t, n3) {
  let r2 = null;
  return Object.entries(e).forEach(([o3, s]) => {
    if (r2) return;
    const i3 = wr(o3, Le(o3, s), `${t} ${n3}`);
    i3 && (r2 = i3);
  }), r2;
}
function vr(e, t) {
  let n3 = null;
  return $e(e) ? e.forEach((r2) => {
    n3 || br(r2) || (n3 = de("UNSUPPORTED_ACCOUNTS", `${t}, account ${r2} should be a string and conform to "namespace:chainId:address" format`));
  }) : n3 = de("UNSUPPORTED_ACCOUNTS", `${t}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), n3;
}
function xr(e, t) {
  let n3 = null;
  return Object.values(e).forEach((r2) => {
    if (n3) return;
    const o3 = vr(r2 == null ? void 0 : r2.accounts, `${t} namespace`);
    o3 && (n3 = o3);
  }), n3;
}
function Or(e, t) {
  let n3 = null;
  return Rt(e == null ? void 0 : e.methods) ? Rt(e == null ? void 0 : e.events) || (n3 = de("UNSUPPORTED_EVENTS", `${t}, events should be an array of strings or empty array for no events`)) : n3 = de("UNSUPPORTED_METHODS", `${t}, methods should be an array of strings or empty array for no methods`), n3;
}
function Pt(e, t) {
  let n3 = null;
  return Object.values(e).forEach((r2) => {
    if (n3) return;
    const o3 = Or(r2, `${t}, namespace`);
    o3 && (n3 = o3);
  }), n3;
}
function ji(e, t, n3) {
  let r2 = null;
  if (e && qe(e)) {
    const o3 = Pt(e, t);
    o3 && (r2 = o3);
    const s = Er(e, t, n3);
    s && (r2 = s);
  } else r2 = te("MISSING_OR_INVALID", `${t}, ${n3} should be an object with data`);
  return r2;
}
function Ir(e, t) {
  let n3 = null;
  if (e && qe(e)) {
    const r2 = Pt(e, t);
    r2 && (n3 = r2);
    const o3 = xr(e, t);
    o3 && (n3 = o3);
  } else n3 = te("MISSING_OR_INVALID", `${t}, namespaces should be an object with data`);
  return n3;
}
function Ar(e) {
  return q(e.protocol, true);
}
function Ci(e, t) {
  let n3 = false;
  return t && !e ? n3 = true : e && $e(e) && e.length && e.forEach((r2) => {
    n3 = Ar(r2);
  }), n3;
}
function ki(e) {
  return typeof e == "number";
}
function Di(e) {
  return typeof e < "u" && typeof e !== null;
}
function Mi(e) {
  return !(!e || typeof e != "object" || !e.code || !Ge(e.code, false) || !e.message || !q(e.message, false));
}
function Vi(e) {
  return !(ae(e) || !q(e.method, false));
}
function Hi(e) {
  return !(ae(e) || ae(e.result) && ae(e.error) || !Ge(e.id, false) || !q(e.jsonrpc, false));
}
function Ki(e) {
  return !(ae(e) || !q(e.name, false));
}
function Fi(e, t) {
  return !(!Re(t) || !lr(e).includes(t));
}
function qi(e, t, n3) {
  return q(n3, false) ? dr(e, t).includes(n3) : false;
}
function Gi(e, t, n3) {
  return q(n3, false) ? hr(e, t).includes(n3) : false;
}
function Nr(e, t, n3) {
  let r2 = null;
  const o3 = Wi(e), s = zi(t), i3 = Object.keys(o3), c6 = Object.keys(s), u3 = Sr(Object.keys(e)), a2 = Sr(Object.keys(t)), l5 = u3.filter((f10) => !a2.includes(f10));
  return l5.length && (r2 = te("NON_CONFORMING_NAMESPACES", `${n3} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l5.toString()}
      Received: ${Object.keys(t).toString()}`)), re(i3, c6) || (r2 = te("NON_CONFORMING_NAMESPACES", `${n3} namespaces chains don't satisfy required namespaces.
      Required: ${i3.toString()}
      Approved: ${c6.toString()}`)), Object.keys(t).forEach((f10) => {
    if (!f10.includes(":") || r2) return;
    const d5 = le(t[f10].accounts);
    d5.includes(f10) || (r2 = te("NON_CONFORMING_NAMESPACES", `${n3} namespaces accounts don't satisfy namespace accounts for ${f10}
        Required: ${f10}
        Approved: ${d5.toString()}`));
  }), i3.forEach((f10) => {
    r2 || (re(o3[f10].methods, s[f10].methods) ? re(o3[f10].events, s[f10].events) || (r2 = te("NON_CONFORMING_NAMESPACES", `${n3} namespaces events don't satisfy namespace events for ${f10}`)) : r2 = te("NON_CONFORMING_NAMESPACES", `${n3} namespaces methods don't satisfy namespace methods for ${f10}`));
  }), r2;
}
function Wi(e) {
  const t = {};
  return Object.keys(e).forEach((n3) => {
    var r2;
    n3.includes(":") ? t[n3] = e[n3] : (r2 = e[n3].chains) == null || r2.forEach((o3) => {
      t[o3] = { methods: e[n3].methods, events: e[n3].events };
    });
  }), t;
}
function Sr(e) {
  return [...new Set(e.map((t) => t.includes(":") ? t.split(":")[0] : t))];
}
function zi(e) {
  const t = {};
  return Object.keys(e).forEach((n3) => {
    if (n3.includes(":")) t[n3] = e[n3];
    else {
      const r2 = le(e[n3].accounts);
      r2 == null ? void 0 : r2.forEach((o3) => {
        t[o3] = { accounts: e[n3].accounts.filter((s) => s.includes(`${o3}:`)), methods: e[n3].methods, events: e[n3].events };
      });
    }
  }), t;
}
function Ji(e, t) {
  return Ge(e, false) && e <= t.max && e >= t.min;
}
function Yi() {
  const e = ue();
  return new Promise((t) => {
    switch (e) {
      case H.browser:
        t(Ur());
        break;
      case H.reactNative:
        t(_r());
        break;
      case H.node:
        t(Tr());
        break;
      default:
        t(true);
    }
  });
}
function Ur() {
  return Ae() && (navigator == null ? void 0 : navigator.onLine);
}
async function _r() {
  if (ne() && typeof global < "u" && global != null && global.NetInfo) {
    const e = await (global == null ? void 0 : global.NetInfo.fetch());
    return e == null ? void 0 : e.isConnected;
  }
  return true;
}
function Tr() {
  return true;
}
function Xi(e) {
  switch (ue()) {
    case H.browser:
      $r(e);
      break;
    case H.reactNative:
      Rr(e);
      break;
    case H.node:
      break;
  }
}
function $r(e) {
  !ne() && Ae() && (window.addEventListener("online", () => e(true)), window.addEventListener("offline", () => e(false)));
}
function Rr(e) {
  ne() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((t) => e(t == null ? void 0 : t.isConnected)));
}
var Lt = {};
var Zi = class {
  static get(t) {
    return Lt[t];
  }
  static set(t, n3) {
    Lt[t] = n3;
  }
  static delete(t) {
    delete Lt[t];
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_lodash = __toESM(require_lodash());
var import_window_getters2 = __toESM(require_cjs2());
var xe2 = "wc";
var Oe2 = 2;
var he = "core";
var B = `${xe2}@2:${he}:`;
var mt2 = { name: he, logger: "error" };
var vt2 = { database: ":memory:" };
var ft2 = "crypto";
var Ae2 = "client_ed25519_seed";
var _t2 = import_time2.ONE_DAY;
var Et2 = "keychain";
var wt2 = "0.3";
var It2 = "messages";
var Tt2 = "0.3";
var Ne2 = import_time2.SIX_HOURS;
var Ct2 = "publisher";
var Pt2 = "irn";
var St2 = "error";
var $e2 = "wss://relay.walletconnect.org";
var Rt2 = "relayer";
var T = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var xt2 = "_subscription";
var L = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var Ot2 = 0.1;
var me2 = "2.19.0";
var Q2 = { link_mode: "link_mode", relay: "relay" };
var At2 = "0.3";
var Nt2 = "WALLETCONNECT_CLIENT_ID";
var ze2 = "WALLETCONNECT_LINK_MODE_APPS";
var $ = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var $t = "subscription";
var zt2 = "0.3";
var Lt2 = import_time2.FIVE_SECONDS * 1e3;
var kt2 = "pairing";
var Ut2 = "0.3";
var ie2 = { wc_pairingDelete: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 } } };
var se2 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var F2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var Ft2 = "history";
var Mt = "0.3";
var Kt = "expirer";
var M4 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var Bt2 = "0.3";
var jt2 = "verify-api";
var js2 = "https://verify.walletconnect.com";
var Vt = "https://verify.walletconnect.org";
var le2 = Vt;
var qt = `${le2}/v3`;
var Gt2 = [js2, Vt];
var Ht = "echo";
var Yt2 = "https://echo.walletconnect.com";
var q2 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var J3 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var qs2 = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" };
var Gs2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" };
var Hs2 = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" };
var Ys2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
var Jt2 = 0.1;
var Xt = "event-client";
var Wt2 = 86400;
var Zt = "https://pulse.walletconnect.org/batch";
function Js2(n3, e) {
  if (n3.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), s = 0; s < t.length; s++) t[s] = 255;
  for (var i3 = 0; i3 < n3.length; i3++) {
    var r2 = n3.charAt(i3), o3 = r2.charCodeAt(0);
    if (t[o3] !== 255) throw new TypeError(r2 + " is ambiguous");
    t[o3] = i3;
  }
  var a2 = n3.length, c6 = n3.charAt(0), h6 = Math.log(a2) / Math.log(256), u3 = Math.log(256) / Math.log(a2);
  function g3(l5) {
    if (l5 instanceof Uint8Array || (ArrayBuffer.isView(l5) ? l5 = new Uint8Array(l5.buffer, l5.byteOffset, l5.byteLength) : Array.isArray(l5) && (l5 = Uint8Array.from(l5))), !(l5 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (l5.length === 0) return "";
    for (var y9 = 0, O8 = 0, w4 = 0, v6 = l5.length; w4 !== v6 && l5[w4] === 0; ) w4++, y9++;
    for (var k8 = (v6 - w4) * u3 + 1 >>> 0, I5 = new Uint8Array(k8); w4 !== v6; ) {
      for (var V8 = l5[w4], X2 = 0, K7 = k8 - 1; (V8 !== 0 || X2 < O8) && K7 !== -1; K7--, X2++) V8 += 256 * I5[K7] >>> 0, I5[K7] = V8 % a2 >>> 0, V8 = V8 / a2 >>> 0;
      if (V8 !== 0) throw new Error("Non-zero carry");
      O8 = X2, w4++;
    }
    for (var Y6 = k8 - O8; Y6 !== k8 && I5[Y6] === 0; ) Y6++;
    for (var ge3 = c6.repeat(y9); Y6 < k8; ++Y6) ge3 += n3.charAt(I5[Y6]);
    return ge3;
  }
  function m3(l5) {
    if (typeof l5 != "string") throw new TypeError("Expected String");
    if (l5.length === 0) return new Uint8Array();
    var y9 = 0;
    if (l5[y9] !== " ") {
      for (var O8 = 0, w4 = 0; l5[y9] === c6; ) O8++, y9++;
      for (var v6 = (l5.length - y9) * h6 + 1 >>> 0, k8 = new Uint8Array(v6); l5[y9]; ) {
        var I5 = t[l5.charCodeAt(y9)];
        if (I5 === 255) return;
        for (var V8 = 0, X2 = v6 - 1; (I5 !== 0 || V8 < w4) && X2 !== -1; X2--, V8++) I5 += a2 * k8[X2] >>> 0, k8[X2] = I5 % 256 >>> 0, I5 = I5 / 256 >>> 0;
        if (I5 !== 0) throw new Error("Non-zero carry");
        w4 = V8, y9++;
      }
      if (l5[y9] !== " ") {
        for (var K7 = v6 - w4; K7 !== v6 && k8[K7] === 0; ) K7++;
        for (var Y6 = new Uint8Array(O8 + (v6 - K7)), ge3 = O8; K7 !== v6; ) Y6[ge3++] = k8[K7++];
        return Y6;
      }
    }
  }
  function A6(l5) {
    var y9 = m3(l5);
    if (y9) return y9;
    throw new Error(`Non-${e} character`);
  }
  return { encode: g3, decodeUnsafe: m3, decode: A6 };
}
var Xs2 = Js2;
var Ws2 = Xs2;
var Qt = (n3) => {
  if (n3 instanceof Uint8Array && n3.constructor.name === "Uint8Array") return n3;
  if (n3 instanceof ArrayBuffer) return new Uint8Array(n3);
  if (ArrayBuffer.isView(n3)) return new Uint8Array(n3.buffer, n3.byteOffset, n3.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Zs2 = (n3) => new TextEncoder().encode(n3);
var Qs2 = (n3) => new TextDecoder().decode(n3);
var er2 = class {
  constructor(e, t, s) {
    this.name = e, this.prefix = t, this.baseEncode = s;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var tr2 = class {
  constructor(e, t, s) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return ei2(this, e);
  }
};
var ir2 = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return ei2(this, e);
  }
  decode(e) {
    const t = e[0], s = this.decoders[t];
    if (s) return s.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ei2 = (n3, e) => new ir2({ ...n3.decoders || { [n3.prefix]: n3 }, ...e.decoders || { [e.prefix]: e } });
var sr2 = class {
  constructor(e, t, s, i3) {
    this.name = e, this.prefix = t, this.baseEncode = s, this.baseDecode = i3, this.encoder = new er2(e, t, s), this.decoder = new tr2(e, t, i3);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var ve2 = ({ name: n3, prefix: e, encode: t, decode: s }) => new sr2(n3, e, t, s);
var ue2 = ({ prefix: n3, name: e, alphabet: t }) => {
  const { encode: s, decode: i3 } = Ws2(t, e);
  return ve2({ prefix: n3, name: e, encode: s, decode: (r2) => Qt(i3(r2)) });
};
var rr2 = (n3, e, t, s) => {
  const i3 = {};
  for (let u3 = 0; u3 < e.length; ++u3) i3[e[u3]] = u3;
  let r2 = n3.length;
  for (; n3[r2 - 1] === "="; ) --r2;
  const o3 = new Uint8Array(r2 * t / 8 | 0);
  let a2 = 0, c6 = 0, h6 = 0;
  for (let u3 = 0; u3 < r2; ++u3) {
    const g3 = i3[n3[u3]];
    if (g3 === void 0) throw new SyntaxError(`Non-${s} character`);
    c6 = c6 << t | g3, a2 += t, a2 >= 8 && (a2 -= 8, o3[h6++] = 255 & c6 >> a2);
  }
  if (a2 >= t || 255 & c6 << 8 - a2) throw new SyntaxError("Unexpected end of data");
  return o3;
};
var nr2 = (n3, e, t) => {
  const s = e[e.length - 1] === "=", i3 = (1 << t) - 1;
  let r2 = "", o3 = 0, a2 = 0;
  for (let c6 = 0; c6 < n3.length; ++c6) for (a2 = a2 << 8 | n3[c6], o3 += 8; o3 > t; ) o3 -= t, r2 += e[i3 & a2 >> o3];
  if (o3 && (r2 += e[i3 & a2 << t - o3]), s) for (; r2.length * t & 7; ) r2 += "=";
  return r2;
};
var C2 = ({ name: n3, prefix: e, bitsPerChar: t, alphabet: s }) => ve2({ prefix: e, name: n3, encode(i3) {
  return nr2(i3, s, t);
}, decode(i3) {
  return rr2(i3, s, t, n3);
} });
var or2 = ve2({ prefix: "\0", name: "identity", encode: (n3) => Qs2(n3), decode: (n3) => Zs2(n3) });
var ar2 = Object.freeze({ __proto__: null, identity: or2 });
var cr2 = C2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var hr2 = Object.freeze({ __proto__: null, base2: cr2 });
var lr2 = C2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var ur = Object.freeze({ __proto__: null, base8: lr2 });
var dr2 = ue2({ prefix: "9", name: "base10", alphabet: "0123456789" });
var pr2 = Object.freeze({ __proto__: null, base10: dr2 });
var gr2 = C2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var yr2 = C2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var br2 = Object.freeze({ __proto__: null, base16: gr2, base16upper: yr2 });
var Dr = C2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var mr2 = C2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var vr2 = C2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var fr = C2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var _r2 = C2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var Er2 = C2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var wr2 = C2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Ir2 = C2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var Tr2 = C2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Cr = Object.freeze({ __proto__: null, base32: Dr, base32upper: mr2, base32pad: vr2, base32padupper: fr, base32hex: _r2, base32hexupper: Er2, base32hexpad: wr2, base32hexpadupper: Ir2, base32z: Tr2 });
var Pr = ue2({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Sr2 = ue2({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Rr2 = Object.freeze({ __proto__: null, base36: Pr, base36upper: Sr2 });
var xr2 = ue2({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Or2 = ue2({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Ar2 = Object.freeze({ __proto__: null, base58btc: xr2, base58flickr: Or2 });
var Nr2 = C2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var $r2 = C2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var zr2 = C2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Lr2 = C2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var kr2 = Object.freeze({ __proto__: null, base64: Nr2, base64pad: $r2, base64url: zr2, base64urlpad: Lr2 });
var ti2 = Array.from("");
var Ur2 = ti2.reduce((n3, e, t) => (n3[t] = e, n3), []);
var Fr = ti2.reduce((n3, e, t) => (n3[e.codePointAt(0)] = t, n3), []);
function Mr(n3) {
  return n3.reduce((e, t) => (e += Ur2[t], e), "");
}
function Kr2(n3) {
  const e = [];
  for (const t of n3) {
    const s = Fr[t.codePointAt(0)];
    if (s === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(s);
  }
  return new Uint8Array(e);
}
var Br2 = ve2({ prefix: "", name: "base256emoji", encode: Mr, decode: Kr2 });
var jr = Object.freeze({ __proto__: null, base256emoji: Br2 });
var Vr = si2;
var ii2 = 128;
var qr = 127;
var Gr = ~qr;
var Hr = Math.pow(2, 31);
function si2(n3, e, t) {
  e = e || [], t = t || 0;
  for (var s = t; n3 >= Hr; ) e[t++] = n3 & 255 | ii2, n3 /= 128;
  for (; n3 & Gr; ) e[t++] = n3 & 255 | ii2, n3 >>>= 7;
  return e[t] = n3 | 0, si2.bytes = t - s + 1, e;
}
var Yr2 = Le2;
var Jr2 = 128;
var ri2 = 127;
function Le2(n3, s) {
  var t = 0, s = s || 0, i3 = 0, r2 = s, o3, a2 = n3.length;
  do {
    if (r2 >= a2) throw Le2.bytes = 0, new RangeError("Could not decode varint");
    o3 = n3[r2++], t += i3 < 28 ? (o3 & ri2) << i3 : (o3 & ri2) * Math.pow(2, i3), i3 += 7;
  } while (o3 >= Jr2);
  return Le2.bytes = r2 - s, t;
}
var Xr = Math.pow(2, 7);
var Wr2 = Math.pow(2, 14);
var Zr2 = Math.pow(2, 21);
var Qr = Math.pow(2, 28);
var en2 = Math.pow(2, 35);
var tn2 = Math.pow(2, 42);
var sn3 = Math.pow(2, 49);
var rn2 = Math.pow(2, 56);
var nn2 = Math.pow(2, 63);
var on2 = function(n3) {
  return n3 < Xr ? 1 : n3 < Wr2 ? 2 : n3 < Zr2 ? 3 : n3 < Qr ? 4 : n3 < en2 ? 5 : n3 < tn2 ? 6 : n3 < sn3 ? 7 : n3 < rn2 ? 8 : n3 < nn2 ? 9 : 10;
};
var an2 = { encode: Vr, decode: Yr2, encodingLength: on2 };
var ni2 = an2;
var oi2 = (n3, e, t = 0) => (ni2.encode(n3, e, t), e);
var ai2 = (n3) => ni2.encodingLength(n3);
var ke2 = (n3, e) => {
  const t = e.byteLength, s = ai2(n3), i3 = s + ai2(t), r2 = new Uint8Array(i3 + t);
  return oi2(n3, r2, 0), oi2(t, r2, s), r2.set(e, i3), new cn2(n3, t, e, r2);
};
var cn2 = class {
  constructor(e, t, s, i3) {
    this.code = e, this.size = t, this.digest = s, this.bytes = i3;
  }
};
var ci2 = ({ name: n3, code: e, encode: t }) => new hn2(n3, e, t);
var hn2 = class {
  constructor(e, t, s) {
    this.name = e, this.code = t, this.encode = s;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? ke2(this.code, t) : t.then((s) => ke2(this.code, s));
    } else throw Error("Unknown type, must be binary type");
  }
};
var hi2 = (n3) => async (e) => new Uint8Array(await crypto.subtle.digest(n3, e));
var ln2 = ci2({ name: "sha2-256", code: 18, encode: hi2("SHA-256") });
var un2 = ci2({ name: "sha2-512", code: 19, encode: hi2("SHA-512") });
var dn2 = Object.freeze({ __proto__: null, sha256: ln2, sha512: un2 });
var li2 = 0;
var pn2 = "identity";
var ui2 = Qt;
var gn2 = (n3) => ke2(li2, ui2(n3));
var yn2 = { code: li2, name: pn2, encode: ui2, digest: gn2 };
var bn2 = Object.freeze({ __proto__: null, identity: yn2 });
new TextEncoder(), new TextDecoder();
var di2 = { ...ar2, ...hr2, ...ur, ...pr2, ...br2, ...Cr, ...Rr2, ...Ar2, ...kr2, ...jr };
({ ...dn2, ...bn2 });
function Dn2(n3 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(n3) : new Uint8Array(n3);
}
function pi2(n3, e, t, s) {
  return { name: n3, prefix: e, encoder: { name: n3, prefix: e, encode: t }, decoder: { decode: s } };
}
var gi2 = pi2("utf8", "u", (n3) => "u" + new TextDecoder("utf8").decode(n3), (n3) => new TextEncoder().encode(n3.substring(1)));
var Ue2 = pi2("ascii", "a", (n3) => {
  let e = "a";
  for (let t = 0; t < n3.length; t++) e += String.fromCharCode(n3[t]);
  return e;
}, (n3) => {
  n3 = n3.substring(1);
  const e = Dn2(n3.length);
  for (let t = 0; t < n3.length; t++) e[t] = n3.charCodeAt(t);
  return e;
});
var mn2 = { utf8: gi2, "utf-8": gi2, hex: di2.base16, latin1: Ue2, ascii: Ue2, binary: Ue2, ...di2 };
function vn2(n3, e = "utf8") {
  const t = mn2[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(n3, "utf8") : t.decoder.decode(`${t.prefix}${n3}`);
}
var fn2 = Object.defineProperty;
var _n2 = (n3, e, t) => e in n3 ? fn2(n3, e, { enumerable: true, configurable: true, writable: true, value: t }) : n3[e] = t;
var G = (n3, e, t) => _n2(n3, typeof e != "symbol" ? e + "" : e, t);
var yi2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, G(this, "keychain", /* @__PURE__ */ new Map()), G(this, "name", Et2), G(this, "version", wt2), G(this, "initialized", false), G(this, "storagePrefix", B), G(this, "init", async () => {
      if (!this.initialized) {
        const s = await this.getKeyChain();
        typeof s < "u" && (this.keychain = s), this.initialized = true;
      }
    }), G(this, "has", (s) => (this.isInitialized(), this.keychain.has(s))), G(this, "set", async (s, i3) => {
      this.isInitialized(), this.keychain.set(s, i3), await this.persist();
    }), G(this, "get", (s) => {
      this.isInitialized();
      const i3 = this.keychain.get(s);
      if (typeof i3 > "u") {
        const { message: r2 } = te("NO_MATCHING_KEY", `${this.name}: ${s}`);
        throw new Error(r2);
      }
      return i3;
    }), G(this, "del", async (s) => {
      this.isInitialized(), this.keychain.delete(s), await this.persist();
    }), this.core = e, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, no(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? ro(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var En2 = Object.defineProperty;
var wn2 = (n3, e, t) => e in n3 ? En2(n3, e, { enumerable: true, configurable: true, writable: true, value: t }) : n3[e] = t;
var P3 = (n3, e, t) => wn2(n3, typeof e != "symbol" ? e + "" : e, t);
var bi2 = class {
  constructor(e, t, s) {
    this.core = e, this.logger = t, P3(this, "name", ft2), P3(this, "keychain"), P3(this, "randomSessionIdentifier", ni()), P3(this, "initialized", false), P3(this, "init", async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }), P3(this, "hasKeys", (i3) => (this.isInitialized(), this.keychain.has(i3))), P3(this, "getClientId", async () => {
      this.isInitialized();
      const i3 = await this.getClientSeed(), r2 = Po(i3);
      return Qe(r2.publicKey);
    }), P3(this, "generateKeyPair", () => {
      this.isInitialized();
      const i3 = ti();
      return this.setPrivateKey(i3.publicKey, i3.privateKey);
    }), P3(this, "signJWT", async (i3) => {
      this.isInitialized();
      const r2 = await this.getClientSeed(), o3 = Po(r2), a2 = this.randomSessionIdentifier, c6 = _t2;
      return await Qo(a2, i3, c6, o3);
    }), P3(this, "generateSharedKey", (i3, r2, o3) => {
      this.isInitialized();
      const a2 = this.getPrivateKey(i3), c6 = ri(a2, r2);
      return this.setSymKey(c6, o3);
    }), P3(this, "setSymKey", async (i3, r2) => {
      this.isInitialized();
      const o3 = r2 || oi(i3);
      return await this.keychain.set(o3, i3), o3;
    }), P3(this, "deleteKeyPair", async (i3) => {
      this.isInitialized(), await this.keychain.del(i3);
    }), P3(this, "deleteSymKey", async (i3) => {
      this.isInitialized(), await this.keychain.del(i3);
    }), P3(this, "encode", async (i3, r2, o3) => {
      this.isInitialized();
      const a2 = rr(o3), c6 = safeJsonStringify(r2);
      if (di(a2)) return ai(c6, o3 == null ? void 0 : o3.encoding);
      if (li(a2)) {
        const m3 = a2.senderPublicKey, A6 = a2.receiverPublicKey;
        i3 = await this.generateSharedKey(m3, A6);
      }
      const h6 = this.getSymKey(i3), { type: u3, senderPublicKey: g3 } = a2;
      return ii({ type: u3, symKey: h6, message: c6, senderPublicKey: g3, encoding: o3 == null ? void 0 : o3.encoding });
    }), P3(this, "decode", async (i3, r2, o3) => {
      this.isInitialized();
      const a2 = fi(r2, o3);
      if (di(a2)) {
        const c6 = ui(r2, o3 == null ? void 0 : o3.encoding);
        return safeJsonParse(c6);
      }
      if (li(a2)) {
        const c6 = a2.receiverPublicKey, h6 = a2.senderPublicKey;
        i3 = await this.generateSharedKey(c6, h6);
      }
      try {
        const c6 = this.getSymKey(i3), h6 = ci({ symKey: c6, encoded: r2, encoding: o3 == null ? void 0 : o3.encoding });
        return safeJsonParse(h6);
      } catch (c6) {
        this.logger.error(`Failed to decode message from topic: '${i3}', clientId: '${await this.getClientId()}'`), this.logger.error(c6);
      }
    }), P3(this, "getPayloadType", (i3, r2 = At) => {
      const o3 = Fe({ encoded: i3, encoding: r2 });
      return fe(o3.type);
    }), P3(this, "getPayloadSenderPublicKey", (i3, r2 = At) => {
      const o3 = Fe({ encoded: i3, encoding: r2 });
      return o3.senderPublicKey ? toString(o3.senderPublicKey, V2) : void 0;
    }), this.core = e, this.logger = E(t, this.name), this.keychain = s || new yi2(this.core, this.logger);
  }
  get context() {
    return y(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(Ae2);
    } catch {
      e = ni(), await this.keychain.set(Ae2, e);
    }
    return vn2(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var In2 = Object.defineProperty;
var Tn2 = (n3, e, t) => e in n3 ? In2(n3, e, { enumerable: true, configurable: true, writable: true, value: t }) : n3[e] = t;
var H2 = (n3, e, t) => Tn2(n3, typeof e != "symbol" ? e + "" : e, t);
var Di2 = class extends y4 {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, H2(this, "messages", /* @__PURE__ */ new Map()), H2(this, "name", It2), H2(this, "version", Tt2), H2(this, "initialized", false), H2(this, "storagePrefix", B), H2(this, "init", async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const s = await this.getRelayerMessages();
          typeof s < "u" && (this.messages = s), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (s) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s);
        } finally {
          this.initialized = true;
        }
      }
    }), H2(this, "set", async (s, i3) => {
      this.isInitialized();
      const r2 = si(i3);
      let o3 = this.messages.get(s);
      return typeof o3 > "u" && (o3 = {}), typeof o3[r2] < "u" || (o3[r2] = i3, this.messages.set(s, o3), await this.persist()), r2;
    }), H2(this, "get", (s) => {
      this.isInitialized();
      let i3 = this.messages.get(s);
      return typeof i3 > "u" && (i3 = {}), i3;
    }), H2(this, "has", (s, i3) => {
      this.isInitialized();
      const r2 = this.get(s), o3 = si(i3);
      return typeof r2[o3] < "u";
    }), H2(this, "del", async (s) => {
      this.isInitialized(), this.messages.delete(s), await this.persist();
    }), this.logger = E(e, this.name), this.core = t;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, no(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? ro(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Cn2 = Object.defineProperty;
var Pn = Object.defineProperties;
var Sn = Object.getOwnPropertyDescriptors;
var mi2 = Object.getOwnPropertySymbols;
var Rn2 = Object.prototype.hasOwnProperty;
var xn2 = Object.prototype.propertyIsEnumerable;
var Fe2 = (n3, e, t) => e in n3 ? Cn2(n3, e, { enumerable: true, configurable: true, writable: true, value: t }) : n3[e] = t;
var fe2 = (n3, e) => {
  for (var t in e || (e = {})) Rn2.call(e, t) && Fe2(n3, t, e[t]);
  if (mi2) for (var t of mi2(e)) xn2.call(e, t) && Fe2(n3, t, e[t]);
  return n3;
};
var Me2 = (n3, e) => Pn(n3, Sn(e));
var j2 = (n3, e, t) => Fe2(n3, typeof e != "symbol" ? e + "" : e, t);
var On2 = class extends m2 {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, j2(this, "events", new import_events3.EventEmitter()), j2(this, "name", Ct2), j2(this, "queue", /* @__PURE__ */ new Map()), j2(this, "publishTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE)), j2(this, "initialPublishTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), j2(this, "needsTransportRestart", false), j2(this, "publish", async (s, i3, r2) => {
      var o3;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: s, message: i3, opts: r2 } });
      const a2 = (r2 == null ? void 0 : r2.ttl) || Ne2, c6 = yi(r2), h6 = (r2 == null ? void 0 : r2.prompt) || false, u3 = (r2 == null ? void 0 : r2.tag) || 0, g3 = (r2 == null ? void 0 : r2.id) || getBigIntRpcId().toString(), m3 = { topic: s, message: i3, opts: { ttl: a2, relay: c6, prompt: h6, tag: u3, id: g3, attestation: r2 == null ? void 0 : r2.attestation, tvf: r2 == null ? void 0 : r2.tvf } }, A6 = `Failed to publish payload, please try again. id:${g3} tag:${u3}`;
      try {
        const l5 = new Promise(async (y9) => {
          const O8 = ({ id: v6 }) => {
            m3.opts.id === v6 && (this.removeRequestFromQueue(v6), this.relayer.events.removeListener(T.publish, O8), y9(m3));
          };
          this.relayer.events.on(T.publish, O8);
          const w4 = ao(new Promise((v6, k8) => {
            this.rpcPublish({ topic: s, message: i3, ttl: a2, prompt: h6, tag: u3, id: g3, attestation: r2 == null ? void 0 : r2.attestation, tvf: r2 == null ? void 0 : r2.tvf }).then(v6).catch((I5) => {
              this.logger.warn(I5, I5 == null ? void 0 : I5.message), k8(I5);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${g3} tag:${u3}`);
          try {
            await w4, this.events.removeListener(T.publish, O8);
          } catch (v6) {
            this.queue.set(g3, Me2(fe2({}, m3), { attempt: 1 })), this.logger.warn(v6, v6 == null ? void 0 : v6.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: g3, topic: s, message: i3, opts: r2 } }), await ao(l5, this.publishTimeout, A6);
      } catch (l5) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(l5), (o3 = r2 == null ? void 0 : r2.internal) != null && o3.throwOnFailedPublish) throw l5;
      } finally {
        this.queue.delete(g3);
      }
    }), j2(this, "on", (s, i3) => {
      this.events.on(s, i3);
    }), j2(this, "once", (s, i3) => {
      this.events.once(s, i3);
    }), j2(this, "off", (s, i3) => {
      this.events.off(s, i3);
    }), j2(this, "removeListener", (s, i3) => {
      this.events.removeListener(s, i3);
    }), this.relayer = e, this.logger = E(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y(this.logger);
  }
  async rpcPublish(e) {
    var t, s, i3, r2;
    const { topic: o3, message: a2, ttl: c6 = Ne2, prompt: h6, tag: u3, id: g3, attestation: m3, tvf: A6 } = e, l5 = { method: mi(yi().protocol).publish, params: fe2({ topic: o3, message: a2, ttl: c6, prompt: h6, tag: u3, attestation: m3 }, A6), id: g3 };
    ae((t = l5.params) == null ? void 0 : t.prompt) && ((s = l5.params) == null || delete s.prompt), ae((i3 = l5.params) == null ? void 0 : i3.tag) && ((r2 = l5.params) == null || delete r2.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: l5 });
    const y9 = await this.relayer.request(l5);
    return this.relayer.events.emit(T.publish, e), this.logger.debug("Successfully Published Payload"), y9;
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e, t) => {
      const s = e.attempt + 1;
      this.queue.set(t, Me2(fe2({}, e), { attempt: s }));
      const { topic: i3, message: r2, opts: o3, attestation: a2 } = e;
      this.logger.warn({}, `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${s}`), await this.rpcPublish(Me2(fe2({}, e), { topic: i3, message: r2, ttl: o3.ttl, prompt: o3.prompt, tag: o3.tag, id: o3.id, attestation: a2, tvf: o3.tvf })), this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(T.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(T.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var An = Object.defineProperty;
var Nn = (n3, e, t) => e in n3 ? An(n3, e, { enumerable: true, configurable: true, writable: true, value: t }) : n3[e] = t;
var re2 = (n3, e, t) => Nn(n3, typeof e != "symbol" ? e + "" : e, t);
var $n = class {
  constructor() {
    re2(this, "map", /* @__PURE__ */ new Map()), re2(this, "set", (e, t) => {
      const s = this.get(e);
      this.exists(e, t) || this.map.set(e, [...s, t]);
    }), re2(this, "get", (e) => this.map.get(e) || []), re2(this, "exists", (e, t) => this.get(e).includes(t)), re2(this, "delete", (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e)) return;
      const s = this.get(e);
      if (!this.exists(e, t)) return;
      const i3 = s.filter((r2) => r2 !== t);
      if (!i3.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, i3);
    }), re2(this, "clear", () => {
      this.map.clear();
    });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var zn2 = Object.defineProperty;
var Ln2 = Object.defineProperties;
var kn2 = Object.getOwnPropertyDescriptors;
var vi = Object.getOwnPropertySymbols;
var Un2 = Object.prototype.hasOwnProperty;
var Fn2 = Object.prototype.propertyIsEnumerable;
var Ke2 = (n3, e, t) => e in n3 ? zn2(n3, e, { enumerable: true, configurable: true, writable: true, value: t }) : n3[e] = t;
var de2 = (n3, e) => {
  for (var t in e || (e = {})) Un2.call(e, t) && Ke2(n3, t, e[t]);
  if (vi) for (var t of vi(e)) Fn2.call(e, t) && Ke2(n3, t, e[t]);
  return n3;
};
var Be = (n3, e) => Ln2(n3, kn2(e));
var D2 = (n3, e, t) => Ke2(n3, typeof e != "symbol" ? e + "" : e, t);
var fi2 = class extends P2 {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, D2(this, "subscriptions", /* @__PURE__ */ new Map()), D2(this, "topicMap", new $n()), D2(this, "events", new import_events3.EventEmitter()), D2(this, "name", $t), D2(this, "version", zt2), D2(this, "pending", /* @__PURE__ */ new Map()), D2(this, "cached", []), D2(this, "initialized", false), D2(this, "pendingSubscriptionWatchLabel", "pending_sub_watch_label"), D2(this, "pollingInterval", 20), D2(this, "storagePrefix", B), D2(this, "subscribeTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE)), D2(this, "initialSubscribeTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), D2(this, "clientId"), D2(this, "batchSubscribeTopicsLimit", 500), D2(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = true;
    }), D2(this, "subscribe", async (s, i3) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s, opts: i3 } });
      try {
        const r2 = yi(i3), o3 = { topic: s, relay: r2, transportType: i3 == null ? void 0 : i3.transportType };
        this.pending.set(s, o3);
        const a2 = await this.rpcSubscribe(s, r2, i3);
        return typeof a2 == "string" && (this.onSubscribe(a2, o3), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s, opts: i3 } })), a2;
      } catch (r2) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(r2), r2;
      }
    }), D2(this, "unsubscribe", async (s, i3) => {
      this.isInitialized(), typeof (i3 == null ? void 0 : i3.id) < "u" ? await this.unsubscribeById(s, i3.id, i3) : await this.unsubscribeByTopic(s, i3);
    }), D2(this, "isSubscribed", async (s) => {
      if (this.topics.includes(s)) return true;
      const i3 = `${this.pendingSubscriptionWatchLabel}_${s}`;
      return await new Promise((r2, o3) => {
        const a2 = new import_time2.Watch();
        a2.start(i3);
        const c6 = setInterval(() => {
          (!this.pending.has(s) && this.topics.includes(s) || this.cached.some((h6) => h6.topic === s)) && (clearInterval(c6), a2.stop(i3), r2(true)), a2.elapsed(i3) >= Lt2 && (clearInterval(c6), a2.stop(i3), o3(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => false);
    }), D2(this, "on", (s, i3) => {
      this.events.on(s, i3);
    }), D2(this, "once", (s, i3) => {
      this.events.once(s, i3);
    }), D2(this, "off", (s, i3) => {
      this.events.off(s, i3);
    }), D2(this, "removeListener", (s, i3) => {
      this.events.removeListener(s, i3);
    }), D2(this, "start", async () => {
      await this.onConnect();
    }), D2(this, "stop", async () => {
      await this.onDisconnect();
    }), D2(this, "restart", async () => {
      await this.restore(), await this.onRestart();
    }), D2(this, "checkPending", async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
      const s = [];
      this.pending.forEach((i3) => {
        s.push(i3);
      }), await this.batchSubscribe(s);
    }), D2(this, "registerEventListeners", () => {
      this.relayer.core.heartbeat.on(r.pulse, async () => {
        await this.checkPending();
      }), this.events.on($.created, async (s) => {
        const i3 = $.created;
        this.logger.info(`Emitting ${i3}`), this.logger.debug({ type: "event", event: i3, data: s }), await this.persist();
      }), this.events.on($.deleted, async (s) => {
        const i3 = $.deleted;
        this.logger.info(`Emitting ${i3}`), this.logger.debug({ type: "event", event: i3, data: s }), await this.persist();
      });
    }), this.relayer = e, this.logger = E(t, this.name), this.clientId = "";
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  get hasAnyTopics() {
    return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
  }
  hasSubscription(e, t) {
    let s = false;
    try {
      s = this.getSubscription(e).topic === t;
    } catch {
    }
    return s;
  }
  reset() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const s = this.topicMap.get(e);
    await Promise.all(s.map(async (i3) => await this.unsubscribeById(e, i3, t)));
  }
  async unsubscribeById(e, t, s) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: s } });
    try {
      const i3 = yi(s);
      await this.restartToComplete({ topic: e, id: t, relay: i3 }), await this.rpcUnsubscribe(e, t, i3);
      const r2 = de("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, r2), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: s } });
    } catch (i3) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i3), i3;
    }
  }
  async rpcSubscribe(e, t, s) {
    var i3;
    (!s || (s == null ? void 0 : s.transportType) === Q2.relay) && await this.restartToComplete({ topic: e, id: e, relay: t });
    const r2 = { method: mi(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: r2 });
    const o3 = (i3 = s == null ? void 0 : s.internal) == null ? void 0 : i3.throwOnFailedPublish;
    try {
      const a2 = await this.getSubscriptionId(e);
      if ((s == null ? void 0 : s.transportType) === Q2.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(r2).catch((u3) => this.logger.warn(u3));
      }, (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND)), a2;
      const c6 = new Promise(async (u3) => {
        const g3 = (m3) => {
          m3.topic === e && (this.events.removeListener($.created, g3), u3(m3.id));
        };
        this.events.on($.created, g3);
        try {
          const m3 = await ao(new Promise((A6, l5) => {
            this.relayer.request(r2).catch((y9) => {
              this.logger.warn(y9, y9 == null ? void 0 : y9.message), l5(y9);
            }).then(A6);
          }), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);
          this.events.removeListener($.created, g3), u3(m3);
        } catch {
        }
      }), h6 = await ao(c6, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!h6 && o3) throw new Error(`Subscribing to ${e} failed, please try again`);
      return h6 ? a2 : null;
    } catch (a2) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(T.connection_stalled), o3) throw a2;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const t = e[0].relay, s = { method: mi(t.protocol).batchSubscribe, params: { topics: e.map((i3) => i3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s });
    try {
      await await ao(new Promise((i3) => {
        this.relayer.request(s).catch((r2) => this.logger.warn(r2)).then(i3);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(T.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const t = e[0].relay, s = { method: mi(t.protocol).batchFetchMessages, params: { topics: e.map((r2) => r2.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s });
    let i3;
    try {
      i3 = await await ao(new Promise((r2, o3) => {
        this.relayer.request(s).catch((a2) => {
          this.logger.warn(a2), o3(a2);
        }).then(r2);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(T.connection_stalled);
    }
    return i3;
  }
  rpcUnsubscribe(e, t, s) {
    const i3 = { method: mi(s.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 }), this.relayer.request(i3);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, Be(de2({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, de2({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, s) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, s), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t);
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, de2({}, t)), this.topicMap.set(t.topic, e), this.events.emit($.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: s } = te("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(s);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const s = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(s.topic, e), this.events.emit($.deleted, Be(de2({}, s), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit($.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e = [...this.cached], t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let s = 0; s < t; s++) {
        const i3 = e.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i3);
      }
    }
    this.events.emit($.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size) {
        const { message: t } = te("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(await Promise.all(e.map(async (t) => Be(de2({}, t), { id: await this.getSubscriptionId(t.topic) })))));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e);
    t && t.messages && (await vo((0, import_time2.toMiliseconds)(import_time2.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete(e) {
    !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e), await this.relayer.transportOpen());
  }
  async getClientId() {
    return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
  }
  async getSubscriptionId(e) {
    return si(e + await this.getClientId());
  }
};
var Mn2 = Object.defineProperty;
var _i = Object.getOwnPropertySymbols;
var Kn2 = Object.prototype.hasOwnProperty;
var Bn2 = Object.prototype.propertyIsEnumerable;
var je2 = (n3, e, t) => e in n3 ? Mn2(n3, e, { enumerable: true, configurable: true, writable: true, value: t }) : n3[e] = t;
var Ei2 = (n3, e) => {
  for (var t in e || (e = {})) Kn2.call(e, t) && je2(n3, t, e[t]);
  if (_i) for (var t of _i(e)) Bn2.call(e, t) && je2(n3, t, e[t]);
  return n3;
};
var p2 = (n3, e, t) => je2(n3, typeof e != "symbol" ? e + "" : e, t);
var wi2 = class extends d2 {
  constructor(e) {
    super(e), p2(this, "protocol", "wc"), p2(this, "version", 2), p2(this, "core"), p2(this, "logger"), p2(this, "events", new import_events3.EventEmitter()), p2(this, "provider"), p2(this, "messages"), p2(this, "subscriber"), p2(this, "publisher"), p2(this, "name", Rt2), p2(this, "transportExplicitlyClosed", false), p2(this, "initialized", false), p2(this, "connectionAttemptInProgress", false), p2(this, "relayUrl"), p2(this, "projectId"), p2(this, "packageName"), p2(this, "bundleId"), p2(this, "hasExperiencedNetworkDisruption", false), p2(this, "pingTimeout"), p2(this, "heartBeatTimeout", (0, import_time2.toMiliseconds)(import_time2.THIRTY_SECONDS + import_time2.FIVE_SECONDS)), p2(this, "reconnectTimeout"), p2(this, "connectPromise"), p2(this, "reconnectInProgress", false), p2(this, "requestsInFlight", []), p2(this, "connectTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), p2(this, "request", async (t) => {
      var s, i3;
      this.logger.debug("Publishing Request Payload");
      const r2 = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: r2, method: t.method, topic: (s = t.params) == null ? void 0 : s.topic }, "relayer.request - publishing...");
        const o3 = `${r2}:${((i3 = t.params) == null ? void 0 : i3.tag) || ""}`;
        this.requestsInFlight.push(o3);
        const a2 = await this.provider.request(t);
        return this.requestsInFlight = this.requestsInFlight.filter((c6) => c6 !== o3), a2;
      } catch (o3) {
        throw this.logger.debug(`Failed to Publish Request: ${r2}`), o3;
      }
    }), p2(this, "resetPingTimeout", () => {
      if (et()) try {
        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
          var t, s, i3;
          this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (i3 = (s = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : s.socket) == null || i3.terminate();
        }, this.heartBeatTimeout);
      } catch (t) {
        this.logger.warn(t, t == null ? void 0 : t.message);
      }
    }), p2(this, "onPayloadHandler", (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }), p2(this, "onConnectHandler", () => {
      this.logger.warn({}, "Relayer connected "), this.startPingTimeout(), this.events.emit(T.connect);
    }), p2(this, "onDisconnectHandler", () => {
      this.logger.warn({}, "Relayer disconnected "), this.requestsInFlight = [], this.onProviderDisconnect();
    }), p2(this, "onProviderErrorHandler", (t) => {
      this.logger.fatal(`Fatal socket error: ${t.message}`), this.events.emit(T.error, t), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }), p2(this, "registerProviderListeners", () => {
      this.provider.on(L.payload, this.onPayloadHandler), this.provider.on(L.connect, this.onConnectHandler), this.provider.on(L.disconnect, this.onDisconnectHandler), this.provider.on(L.error, this.onProviderErrorHandler);
    }), this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? E(e.logger, this.name) : (0, import_pino.default)(k({ level: e.logger || St2 })), this.messages = new Di2(this.logger, e.core), this.subscriber = new fi2(this, this.logger), this.publisher = new On2(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || $e2, this.projectId = e.projectId, Wr() ? this.packageName = Jr() : zr() && (this.bundleId = Jr()), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.subscriber.hasAnyTopics) try {
      await this.transportOpen();
    } catch (e) {
      this.logger.warn(e, e == null ? void 0 : e.message);
    }
  }
  get context() {
    return y(this.logger);
  }
  get connected() {
    var e, t, s;
    return ((s = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s.readyState) === 1 || false;
  }
  get connecting() {
    var e, t, s;
    return ((s = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s.readyState) === 0 || this.connectPromise !== void 0 || false;
  }
  async publish(e, t, s) {
    this.isInitialized(), await this.publisher.publish(e, t, s), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now(), transportType: Q2.relay });
  }
  async subscribe(e, t) {
    var s, i3, r2;
    this.isInitialized(), (!(t != null && t.transportType) || (t == null ? void 0 : t.transportType) === "relay") && await this.toEstablishConnection();
    const o3 = typeof ((s = t == null ? void 0 : t.internal) == null ? void 0 : s.throwOnFailedPublish) > "u" ? true : (i3 = t == null ? void 0 : t.internal) == null ? void 0 : i3.throwOnFailedPublish;
    let a2 = ((r2 = this.subscriber.topicMap.get(e)) == null ? void 0 : r2[0]) || "", c6;
    const h6 = (u3) => {
      u3.topic === e && (this.subscriber.off($.created, h6), c6());
    };
    return await Promise.all([new Promise((u3) => {
      c6 = u3, this.subscriber.on($.created, h6);
    }), new Promise(async (u3, g3) => {
      a2 = await this.subscriber.subscribe(e, Ei2({ internal: { throwOnFailedPublish: o3 } }, t)).catch((m3) => {
        o3 && g3(m3);
      }) || a2, u3();
    })]), a2;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await ao(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.warn("Starting WS connection skipped because the client has no topics to work with.");
      return;
    }
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t, s) => {
      await this.connect(e).then(t).catch(s).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Yi()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e.sort((s, i3) => s.publishedAt - i3.publishedAt);
    this.logger.debug(`Batch of ${t.length} message events sorted`);
    for (const s of t) try {
      await this.onMessageEvent(s);
    } catch (i3) {
      this.logger.warn(i3, "Error while processing batch message event: " + (i3 == null ? void 0 : i3.message));
    }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e, t) {
    const { topic: s } = e;
    if (!t.sessionExists) {
      const i3 = ho(import_time2.FIVE_MINUTES), r2 = { topic: s, expiry: i3, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(s, r2);
    }
    this.events.emit(T.message, e), await this.recordMessageEvent(e);
  }
  async connect(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    let t = 1;
    for (; t < 6; ) {
      try {
        if (this.transportExplicitlyClosed) break;
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`), await this.createProvider(), await new Promise(async (s, i3) => {
          const r2 = () => {
            i3(new Error("Connection interrupted while trying to subscribe"));
          };
          this.provider.once(L.disconnect, r2), await ao(new Promise((o3, a2) => {
            this.provider.connect().then(o3).catch(a2);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o3) => {
            i3(o3);
          }).finally(() => {
            this.provider.off(L.disconnect, r2), clearTimeout(this.reconnectTimeout);
          }), await new Promise(async (o3, a2) => {
            const c6 = () => {
              a2(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(L.disconnect, c6), await this.subscriber.start().then(o3).catch(a2).finally(() => {
              this.provider.off(L.disconnect, c6);
            });
          }), this.hasExperiencedNetworkDisruption = false, s();
        });
      } catch (s) {
        await this.subscriber.stop();
        const i3 = s;
        this.logger.warn({}, i3.message), this.hasExperiencedNetworkDisruption = true;
      } finally {
        this.connectionAttemptInProgress = false;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);
        break;
      }
      await new Promise((s) => setTimeout(s, (0, import_time2.toMiliseconds)(t * 1))), t++;
    }
  }
  startPingTimeout() {
    var e, t, s, i3, r2;
    if (et()) try {
      (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((r2 = (i3 = (s = this.provider) == null ? void 0 : s.connection) == null ? void 0 : i3.socket) == null || r2.on("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (o3) {
      this.logger.warn(o3, o3 == null ? void 0 : o3.message);
    }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o(new f(Zr({ sdkVersion: me2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: t, message: s } = e;
    await this.messages.set(t, s);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: s } = e;
    if (!s || s.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${s}`), true;
    if (!await this.subscriber.isSubscribed(t)) return this.logger.warn(`Ignoring message for non-subscribed topic ${t}`), true;
    const i3 = this.messages.has(t, s);
    return i3 && this.logger.warn(`Ignoring duplicate message: ${s}`), i3;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(xt2)) return;
      const t = e.params, { topic: s, message: i3, publishedAt: r2, attestation: o3 } = t.data, a2 = { topic: s, message: i3, publishedAt: r2, transportType: Q2.relay, attestation: o3 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Ei2({ type: "event", event: t.id }, a2)), this.events.emit(t.id, a2), await this.acknowledgePayload(e), await this.onMessageEvent(a2);
    } else isJsonRpcResponse(e) && this.events.emit(T.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(T.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(L.payload, this.onPayloadHandler), this.provider.off(L.connect, this.onConnectHandler), this.provider.off(L.disconnect, this.onDisconnectHandler), this.provider.off(L.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await Yi();
    Xi(async (t) => {
      e !== t && (e = t, t ? await this.transportOpen().catch((s) => this.logger.error(s, s == null ? void 0 : s.message)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    });
  }
  async onProviderDisconnect() {
    clearTimeout(this.pingTimeout), this.events.emit(T.disconnect), this.connectionAttemptInProgress = false, !this.reconnectInProgress && (this.reconnectInProgress = true, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e, e == null ? void 0 : e.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = false;
    }, (0, import_time2.toMiliseconds)(Ot2)))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && await this.connect();
  }
};
var jn2 = Object.defineProperty;
var Ii = Object.getOwnPropertySymbols;
var Vn2 = Object.prototype.hasOwnProperty;
var qn2 = Object.prototype.propertyIsEnumerable;
var Ve2 = (n3, e, t) => e in n3 ? jn2(n3, e, { enumerable: true, configurable: true, writable: true, value: t }) : n3[e] = t;
var Ti2 = (n3, e) => {
  for (var t in e || (e = {})) Vn2.call(e, t) && Ve2(n3, t, e[t]);
  if (Ii) for (var t of Ii(e)) qn2.call(e, t) && Ve2(n3, t, e[t]);
  return n3;
};
var z3 = (n3, e, t) => Ve2(n3, typeof e != "symbol" ? e + "" : e, t);
var Ci2 = class extends f4 {
  constructor(e, t, s, i3 = B, r2 = void 0) {
    super(e, t, s, i3), this.core = e, this.logger = t, this.name = s, z3(this, "map", /* @__PURE__ */ new Map()), z3(this, "version", At2), z3(this, "cached", []), z3(this, "initialized", false), z3(this, "getKey"), z3(this, "storagePrefix", B), z3(this, "recentlyDeleted", []), z3(this, "recentlyDeletedLimit", 200), z3(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o3) => {
        this.getKey && o3 !== null && !ae(o3) ? this.map.set(this.getKey(o3), o3) : Pi2(o3) ? this.map.set(o3.id, o3) : Li(o3) && this.map.set(o3.topic, o3);
      }), this.cached = [], this.initialized = true);
    }), z3(this, "set", async (o3, a2) => {
      this.isInitialized(), this.map.has(o3) ? await this.update(o3, a2) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o3, value: a2 }), this.map.set(o3, a2), await this.persist());
    }), z3(this, "get", (o3) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o3 }), this.getData(o3))), z3(this, "getAll", (o3) => (this.isInitialized(), o3 ? this.values.filter((a2) => Object.keys(o3).every((c6) => (0, import_lodash.default)(a2[c6], o3[c6]))) : this.values)), z3(this, "update", async (o3, a2) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o3, update: a2 });
      const c6 = Ti2(Ti2({}, this.getData(o3)), a2);
      this.map.set(o3, c6), await this.persist();
    }), z3(this, "delete", async (o3, a2) => {
      this.isInitialized(), this.map.has(o3) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o3, reason: a2 }), this.map.delete(o3), this.addToRecentlyDeleted(o3), await this.persist());
    }), this.logger = E(t, this.name), this.storagePrefix = i3, this.getKey = r2;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: i3 } = te("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(i3), new Error(i3);
      }
      const { message: s } = te("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(s), new Error(s);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: t } = te("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Gn2 = Object.defineProperty;
var Hn2 = (n3, e, t) => e in n3 ? Gn2(n3, e, { enumerable: true, configurable: true, writable: true, value: t }) : n3[e] = t;
var d3 = (n3, e, t) => Hn2(n3, typeof e != "symbol" ? e + "" : e, t);
var Pi3 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, d3(this, "name", kt2), d3(this, "version", Ut2), d3(this, "events", new import_events3.default()), d3(this, "pairings"), d3(this, "initialized", false), d3(this, "storagePrefix", B), d3(this, "ignoredPayloadTypes", [Ie]), d3(this, "registeredMethods", []), d3(this, "init", async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }), d3(this, "register", ({ methods: s }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...s])];
    }), d3(this, "create", async (s) => {
      this.isInitialized();
      const i3 = ni(), r2 = await this.core.crypto.setSymKey(i3), o3 = ho(import_time2.FIVE_MINUTES), a2 = { protocol: Pt2 }, c6 = { topic: r2, expiry: o3, relay: a2, active: false, methods: s == null ? void 0 : s.methods }, h6 = wi({ protocol: this.core.protocol, version: this.core.version, topic: r2, symKey: i3, relay: a2, expiryTimestamp: o3, methods: s == null ? void 0 : s.methods });
      return this.events.emit(se2.create, c6), this.core.expirer.set(r2, o3), await this.pairings.set(r2, c6), await this.core.relayer.subscribe(r2, { transportType: s == null ? void 0 : s.transportType }), { topic: r2, uri: h6 };
    }), d3(this, "pair", async (s) => {
      this.isInitialized();
      const i3 = this.core.eventClient.createEvent({ properties: { topic: s == null ? void 0 : s.uri, trace: [q2.pairing_started] } });
      this.isValidPair(s, i3);
      const { topic: r2, symKey: o3, relay: a2, expiryTimestamp: c6, methods: h6 } = bi(s.uri);
      i3.props.properties.topic = r2, i3.addTrace(q2.pairing_uri_validation_success), i3.addTrace(q2.pairing_uri_not_expired);
      let u3;
      if (this.pairings.keys.includes(r2)) {
        if (u3 = this.pairings.get(r2), i3.addTrace(q2.existing_pairing), u3.active) throw i3.setError(J3.active_pairing_already_exists), new Error(`Pairing already exists: ${r2}. Please try again with a new connection URI.`);
        i3.addTrace(q2.pairing_not_expired);
      }
      const g3 = c6 || ho(import_time2.FIVE_MINUTES), m3 = { topic: r2, relay: a2, expiry: g3, active: false, methods: h6 };
      this.core.expirer.set(r2, g3), await this.pairings.set(r2, m3), i3.addTrace(q2.store_new_pairing), s.activatePairing && await this.activate({ topic: r2 }), this.events.emit(se2.create, m3), i3.addTrace(q2.emit_inactive_pairing), this.core.crypto.keychain.has(r2) || await this.core.crypto.setSymKey(o3, r2), i3.addTrace(q2.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        i3.setError(J3.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(r2, { relay: a2 });
      } catch (A6) {
        throw i3.setError(J3.subscribe_pairing_topic_failure), A6;
      }
      return i3.addTrace(q2.subscribe_pairing_topic_success), m3;
    }), d3(this, "activate", async ({ topic: s }) => {
      this.isInitialized();
      const i3 = ho(import_time2.FIVE_MINUTES);
      this.core.expirer.set(s, i3), await this.pairings.update(s, { active: true, expiry: i3 });
    }), d3(this, "ping", async (s) => {
      this.isInitialized(), await this.isValidPing(s), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
      const { topic: i3 } = s;
      if (this.pairings.keys.includes(i3)) {
        const r2 = await this.sendRequest(i3, "wc_pairingPing", {}), { done: o3, resolve: a2, reject: c6 } = co();
        this.events.once(go("pairing_ping", r2), ({ error: h6 }) => {
          h6 ? c6(h6) : a2();
        }), await o3();
      }
    }), d3(this, "updateExpiry", async ({ topic: s, expiry: i3 }) => {
      this.isInitialized(), await this.pairings.update(s, { expiry: i3 });
    }), d3(this, "updateMetadata", async ({ topic: s, metadata: i3 }) => {
      this.isInitialized(), await this.pairings.update(s, { peerMetadata: i3 });
    }), d3(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), d3(this, "disconnect", async (s) => {
      this.isInitialized(), await this.isValidDisconnect(s);
      const { topic: i3 } = s;
      this.pairings.keys.includes(i3) && (await this.sendRequest(i3, "wc_pairingDelete", de("USER_DISCONNECTED")), await this.deletePairing(i3));
    }), d3(this, "formatUriFromPairing", (s) => {
      this.isInitialized();
      const { topic: i3, relay: r2, expiry: o3, methods: a2 } = s, c6 = this.core.crypto.keychain.get(i3);
      return wi({ protocol: this.core.protocol, version: this.core.version, topic: i3, symKey: c6, relay: r2, expiryTimestamp: o3, methods: a2 });
    }), d3(this, "sendRequest", async (s, i3, r2) => {
      const o3 = formatJsonRpcRequest(i3, r2), a2 = await this.core.crypto.encode(s, o3), c6 = ie2[i3].req;
      return this.core.history.set(s, o3), this.core.relayer.publish(s, a2, c6), o3.id;
    }), d3(this, "sendResult", async (s, i3, r2) => {
      const o3 = formatJsonRpcResult(s, r2), a2 = await this.core.crypto.encode(i3, o3), c6 = (await this.core.history.get(i3, s)).request.method, h6 = ie2[c6].res;
      await this.core.relayer.publish(i3, a2, h6), await this.core.history.resolve(o3);
    }), d3(this, "sendError", async (s, i3, r2) => {
      const o3 = formatJsonRpcError(s, r2), a2 = await this.core.crypto.encode(i3, o3), c6 = (await this.core.history.get(i3, s)).request.method, h6 = ie2[c6] ? ie2[c6].res : ie2.unregistered_method.res;
      await this.core.relayer.publish(i3, a2, h6), await this.core.history.resolve(o3);
    }), d3(this, "deletePairing", async (s, i3) => {
      await this.core.relayer.unsubscribe(s), await Promise.all([this.pairings.delete(s, de("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(s), i3 ? Promise.resolve() : this.core.expirer.del(s)]);
    }), d3(this, "cleanup", async () => {
      const s = this.pairings.getAll().filter((i3) => po(i3.expiry));
      await Promise.all(s.map((i3) => this.deletePairing(i3.topic)));
    }), d3(this, "onRelayEventRequest", (s) => {
      const { topic: i3, payload: r2 } = s;
      switch (r2.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i3, r2);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i3, r2);
        default:
          return this.onUnknownRpcMethodRequest(i3, r2);
      }
    }), d3(this, "onRelayEventResponse", async (s) => {
      const { topic: i3, payload: r2 } = s, o3 = (await this.core.history.get(i3, r2.id)).request.method;
      switch (o3) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i3, r2);
        default:
          return this.onUnknownRpcMethodResponse(o3);
      }
    }), d3(this, "onPairingPingRequest", async (s, i3) => {
      const { id: r2 } = i3;
      try {
        this.isValidPing({ topic: s }), await this.sendResult(r2, s, true), this.events.emit(se2.ping, { id: r2, topic: s });
      } catch (o3) {
        await this.sendError(r2, s, o3), this.logger.error(o3);
      }
    }), d3(this, "onPairingPingResponse", (s, i3) => {
      const { id: r2 } = i3;
      setTimeout(() => {
        isJsonRpcResult(i3) ? this.events.emit(go("pairing_ping", r2), {}) : isJsonRpcError(i3) && this.events.emit(go("pairing_ping", r2), { error: i3.error });
      }, 500);
    }), d3(this, "onPairingDeleteRequest", async (s, i3) => {
      const { id: r2 } = i3;
      try {
        this.isValidDisconnect({ topic: s }), await this.deletePairing(s), this.events.emit(se2.delete, { id: r2, topic: s });
      } catch (o3) {
        await this.sendError(r2, s, o3), this.logger.error(o3);
      }
    }), d3(this, "onUnknownRpcMethodRequest", async (s, i3) => {
      const { id: r2, method: o3 } = i3;
      try {
        if (this.registeredMethods.includes(o3)) return;
        const a2 = de("WC_METHOD_UNSUPPORTED", o3);
        await this.sendError(r2, s, a2), this.logger.error(a2);
      } catch (a2) {
        await this.sendError(r2, s, a2), this.logger.error(a2);
      }
    }), d3(this, "onUnknownRpcMethodResponse", (s) => {
      this.registeredMethods.includes(s) || this.logger.error(de("WC_METHOD_UNSUPPORTED", s));
    }), d3(this, "isValidPair", (s, i3) => {
      var r2;
      if (!Di(s)) {
        const { message: a2 } = te("MISSING_OR_INVALID", `pair() params: ${s}`);
        throw i3.setError(J3.malformed_pairing_uri), new Error(a2);
      }
      if (!Ri(s.uri)) {
        const { message: a2 } = te("MISSING_OR_INVALID", `pair() uri: ${s.uri}`);
        throw i3.setError(J3.malformed_pairing_uri), new Error(a2);
      }
      const o3 = bi(s == null ? void 0 : s.uri);
      if (!((r2 = o3 == null ? void 0 : o3.relay) != null && r2.protocol)) {
        const { message: a2 } = te("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw i3.setError(J3.malformed_pairing_uri), new Error(a2);
      }
      if (!(o3 != null && o3.symKey)) {
        const { message: a2 } = te("MISSING_OR_INVALID", "pair() uri#symKey");
        throw i3.setError(J3.malformed_pairing_uri), new Error(a2);
      }
      if (o3 != null && o3.expiryTimestamp && (0, import_time2.toMiliseconds)(o3 == null ? void 0 : o3.expiryTimestamp) < Date.now()) {
        i3.setError(J3.pairing_expired);
        const { message: a2 } = te("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a2);
      }
    }), d3(this, "isValidPing", async (s) => {
      if (!Di(s)) {
        const { message: r2 } = te("MISSING_OR_INVALID", `ping() params: ${s}`);
        throw new Error(r2);
      }
      const { topic: i3 } = s;
      await this.isValidPairingTopic(i3);
    }), d3(this, "isValidDisconnect", async (s) => {
      if (!Di(s)) {
        const { message: r2 } = te("MISSING_OR_INVALID", `disconnect() params: ${s}`);
        throw new Error(r2);
      }
      const { topic: i3 } = s;
      await this.isValidPairingTopic(i3);
    }), d3(this, "isValidPairingTopic", async (s) => {
      if (!q(s, false)) {
        const { message: i3 } = te("MISSING_OR_INVALID", `pairing topic should be a string: ${s}`);
        throw new Error(i3);
      }
      if (!this.pairings.keys.includes(s)) {
        const { message: i3 } = te("NO_MATCHING_KEY", `pairing topic doesn't exist: ${s}`);
        throw new Error(i3);
      }
      if (po(this.pairings.get(s).expiry)) {
        await this.deletePairing(s);
        const { message: i3 } = te("EXPIRED", `pairing topic: ${s}`);
        throw new Error(i3);
      }
    }), this.core = e, this.logger = E(t, this.name), this.pairings = new Ci2(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(T.message, async (e) => {
      const { topic: t, message: s, transportType: i3 } = e;
      if (!this.pairings.keys.includes(t) || i3 === Q2.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s))) return;
      const r2 = await this.core.crypto.decode(t, s);
      try {
        isJsonRpcRequest(r2) ? (this.core.history.set(t, r2), this.onRelayEventRequest({ topic: t, payload: r2 })) : isJsonRpcResponse(r2) && (await this.core.history.resolve(r2), await this.onRelayEventResponse({ topic: t, payload: r2 }), this.core.history.delete(t, r2.id));
      } catch (o3) {
        this.logger.error(o3);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(M4.expired, async (e) => {
      const { topic: t } = lo(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(se2.expire, { topic: t }));
    });
  }
};
var Yn2 = Object.defineProperty;
var Jn2 = (n3, e, t) => e in n3 ? Yn2(n3, e, { enumerable: true, configurable: true, writable: true, value: t }) : n3[e] = t;
var S3 = (n3, e, t) => Jn2(n3, typeof e != "symbol" ? e + "" : e, t);
var Si = class extends I2 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, S3(this, "records", /* @__PURE__ */ new Map()), S3(this, "events", new import_events3.EventEmitter()), S3(this, "name", Ft2), S3(this, "version", Mt), S3(this, "cached", []), S3(this, "initialized", false), S3(this, "storagePrefix", B), S3(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s) => this.records.set(s.id, s)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), S3(this, "set", (s, i3, r2) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: s, request: i3, chainId: r2 }), this.records.has(i3.id)) return;
      const o3 = { id: i3.id, topic: s, request: { method: i3.method, params: i3.params || null }, chainId: r2, expiry: ho(import_time2.THIRTY_DAYS) };
      this.records.set(o3.id, o3), this.persist(), this.events.emit(F2.created, o3);
    }), S3(this, "resolve", async (s) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: s }), !this.records.has(s.id)) return;
      const i3 = await this.getRecord(s.id);
      typeof i3.response > "u" && (i3.response = isJsonRpcError(s) ? { error: s.error } : { result: s.result }, this.records.set(i3.id, i3), this.persist(), this.events.emit(F2.updated, i3));
    }), S3(this, "get", async (s, i3) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: s, id: i3 }), await this.getRecord(i3))), S3(this, "delete", (s, i3) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i3 }), this.values.forEach((r2) => {
        if (r2.topic === s) {
          if (typeof i3 < "u" && r2.id !== i3) return;
          this.records.delete(r2.id), this.events.emit(F2.deleted, r2);
        }
      }), this.persist();
    }), S3(this, "exists", async (s, i3) => (this.isInitialized(), this.records.has(i3) ? (await this.getRecord(i3)).topic === s : false)), S3(this, "on", (s, i3) => {
      this.events.on(s, i3);
    }), S3(this, "once", (s, i3) => {
      this.events.once(s, i3);
    }), S3(this, "off", (s, i3) => {
      this.events.off(s, i3);
    }), S3(this, "removeListener", (s, i3) => {
      this.events.removeListener(s, i3);
    }), this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u") return;
      const s = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(s);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: s } = te("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(s);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(F2.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: t } = te("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(F2.created, (e) => {
      const t = F2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(F2.updated, (e) => {
      const t = F2.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(F2.deleted, (e) => {
      const t = F2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.core.heartbeat.on(r.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = false;
      this.records.forEach((t) => {
        (0, import_time2.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(F2.deleted, t, false), e = true);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Xn2 = Object.defineProperty;
var Wn2 = (n3, e, t) => e in n3 ? Xn2(n3, e, { enumerable: true, configurable: true, writable: true, value: t }) : n3[e] = t;
var x3 = (n3, e, t) => Wn2(n3, typeof e != "symbol" ? e + "" : e, t);
var Ri2 = class extends S2 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, x3(this, "expirations", /* @__PURE__ */ new Map()), x3(this, "events", new import_events3.EventEmitter()), x3(this, "name", Kt), x3(this, "version", Bt2), x3(this, "cached", []), x3(this, "initialized", false), x3(this, "storagePrefix", B), x3(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s) => this.expirations.set(s.target, s)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), x3(this, "has", (s) => {
      try {
        const i3 = this.formatTarget(s);
        return typeof this.getExpiration(i3) < "u";
      } catch {
        return false;
      }
    }), x3(this, "set", (s, i3) => {
      this.isInitialized();
      const r2 = this.formatTarget(s), o3 = { target: r2, expiry: i3 };
      this.expirations.set(r2, o3), this.checkExpiry(r2, o3), this.events.emit(M4.created, { target: r2, expiration: o3 });
    }), x3(this, "get", (s) => {
      this.isInitialized();
      const i3 = this.formatTarget(s);
      return this.getExpiration(i3);
    }), x3(this, "del", (s) => {
      if (this.isInitialized(), this.has(s)) {
        const i3 = this.formatTarget(s), r2 = this.getExpiration(i3);
        this.expirations.delete(i3), this.events.emit(M4.deleted, { target: i3, expiration: r2 });
      }
    }), x3(this, "on", (s, i3) => {
      this.events.on(s, i3);
    }), x3(this, "once", (s, i3) => {
      this.events.once(s, i3);
    }), x3(this, "off", (s, i3) => {
      this.events.off(s, i3);
    }), x3(this, "removeListener", (s, i3) => {
      this.events.removeListener(s, i3);
    }), this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return uo(e);
    if (typeof e == "number") return fo(e);
    const { message: t } = te("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(M4.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: t } = te("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: s } = te("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(s), new Error(s);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: s } = t;
    (0, import_time2.toMiliseconds)(s) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(M4.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r.pulse, () => this.checkExpirations()), this.events.on(M4.created, (e) => {
      const t = M4.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(M4.expired, (e) => {
      const t = M4.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(M4.deleted, (e) => {
      const t = M4.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Zn2 = Object.defineProperty;
var Qn2 = (n3, e, t) => e in n3 ? Zn2(n3, e, { enumerable: true, configurable: true, writable: true, value: t }) : n3[e] = t;
var _2 = (n3, e, t) => Qn2(n3, typeof e != "symbol" ? e + "" : e, t);
var xi = class extends M2 {
  constructor(e, t, s) {
    super(e, t, s), this.core = e, this.logger = t, this.store = s, _2(this, "name", jt2), _2(this, "abortController"), _2(this, "isDevEnv"), _2(this, "verifyUrlV3", qt), _2(this, "storagePrefix", B), _2(this, "version", Oe2), _2(this, "publicKey"), _2(this, "fetchPromise"), _2(this, "init", async () => {
      var i3;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time2.toMiliseconds)((i3 = this.publicKey) == null ? void 0 : i3.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }), _2(this, "register", async (i3) => {
      if (!Ae() || this.isDevEnv) return;
      const r2 = window.location.origin, { id: o3, decryptedId: a2 } = i3, c6 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${r2}&id=${o3}&decryptedId=${a2}`;
      try {
        const h6 = (0, import_window_getters2.getDocument)(), u3 = this.startAbortTimer(import_time2.ONE_SECOND * 5), g3 = await new Promise((m3, A6) => {
          const l5 = () => {
            window.removeEventListener("message", O8), h6.body.removeChild(y9), A6("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", l5);
          const y9 = h6.createElement("iframe");
          y9.src = c6, y9.style.display = "none", y9.addEventListener("error", l5, { signal: this.abortController.signal });
          const O8 = (w4) => {
            if (w4.data && typeof w4.data == "string") try {
              const v6 = JSON.parse(w4.data);
              if (v6.type === "verify_attestation") {
                if (sn(v6.attestation).payload.id !== o3) return;
                clearInterval(u3), h6.body.removeChild(y9), this.abortController.signal.removeEventListener("abort", l5), window.removeEventListener("message", O8), m3(v6.attestation === null ? "" : v6.attestation);
              }
            } catch (v6) {
              this.logger.warn(v6);
            }
          };
          h6.body.appendChild(y9), window.addEventListener("message", O8, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", g3), g3;
      } catch (h6) {
        this.logger.warn(h6);
      }
      return "";
    }), _2(this, "resolve", async (i3) => {
      if (this.isDevEnv) return "";
      const { attestationId: r2, hash: o3, encryptedId: a2 } = i3;
      if (r2 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (r2) {
        if (sn(r2).payload.id !== a2) return;
        const h6 = await this.isValidJwtAttestation(r2);
        if (h6) {
          if (!h6.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h6;
        }
      }
      if (!o3) return;
      const c6 = this.getVerifyUrl(i3 == null ? void 0 : i3.verifyUrl);
      return this.fetchAttestation(o3, c6);
    }), _2(this, "fetchAttestation", async (i3, r2) => {
      this.logger.debug(`resolving attestation: ${i3} from url: ${r2}`);
      const o3 = this.startAbortTimer(import_time2.ONE_SECOND * 5), a2 = await fetch(`${r2}/attestation/${i3}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o3), a2.status === 200 ? await a2.json() : void 0;
    }), _2(this, "getVerifyUrl", (i3) => {
      let r2 = i3 || le2;
      return Gt2.includes(r2) || (this.logger.info(`verify url: ${r2}, not included in trusted list, assigning default: ${le2}`), r2 = le2), r2;
    }), _2(this, "fetchPublicKey", async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const i3 = this.startAbortTimer(import_time2.FIVE_SECONDS), r2 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(i3), await r2.json();
      } catch (i3) {
        this.logger.warn(i3);
      }
    }), _2(this, "persistPublicKey", async (i3) => {
      this.logger.debug("persisting public key to local storage", i3), await this.store.setItem(this.storeKey, i3), this.publicKey = i3;
    }), _2(this, "removePublicKey", async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }), _2(this, "isValidJwtAttestation", async (i3) => {
      const r2 = await this.getPublicKey();
      try {
        if (r2) return this.validateAttestation(i3, r2);
      } catch (a2) {
        this.logger.error(a2), this.logger.warn("error validating attestation");
      }
      const o3 = await this.fetchAndPersistPublicKey();
      try {
        if (o3) return this.validateAttestation(i3, o3);
      } catch (a2) {
        this.logger.error(a2), this.logger.warn("error validating attestation");
      }
    }), _2(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), _2(this, "fetchAndPersistPublicKey", async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (r2) => {
        const o3 = await this.fetchPublicKey();
        o3 && (await this.persistPublicKey(o3), r2(o3));
      });
      const i3 = await this.fetchPromise;
      return this.fetchPromise = void 0, i3;
    }), _2(this, "validateAttestation", (i3, r2) => {
      const o3 = gi(i3, r2.publicKey), a2 = { hasExpired: (0, import_time2.toMiliseconds)(o3.exp) < Date.now(), payload: o3 };
      if (a2.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a2.payload.origin, isScam: a2.payload.isScam, isVerified: a2.payload.isVerified };
    }), this.logger = E(t, this.name), this.abortController = new AbortController(), this.isDevEnv = Eo(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time2.toMiliseconds)(e));
  }
};
var eo = Object.defineProperty;
var to = (n3, e, t) => e in n3 ? eo(n3, e, { enumerable: true, configurable: true, writable: true, value: t }) : n3[e] = t;
var Oi = (n3, e, t) => to(n3, typeof e != "symbol" ? e + "" : e, t);
var Ai = class extends O3 {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, Oi(this, "context", Ht), Oi(this, "registerDeviceToken", async (s) => {
      const { clientId: i3, token: r2, notificationType: o3, enableEncrypted: a2 = false } = s, c6 = `${Yt2}/${this.projectId}/clients`;
      await fetch(c6, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i3, type: o3, token: r2, always_raw: a2 }) });
    }), this.logger = E(t, this.context);
  }
};
var io = Object.defineProperty;
var Ni = Object.getOwnPropertySymbols;
var so = Object.prototype.hasOwnProperty;
var ro2 = Object.prototype.propertyIsEnumerable;
var qe2 = (n3, e, t) => e in n3 ? io(n3, e, { enumerable: true, configurable: true, writable: true, value: t }) : n3[e] = t;
var pe = (n3, e) => {
  for (var t in e || (e = {})) so.call(e, t) && qe2(n3, t, e[t]);
  if (Ni) for (var t of Ni(e)) ro2.call(e, t) && qe2(n3, t, e[t]);
  return n3;
};
var E3 = (n3, e, t) => qe2(n3, typeof e != "symbol" ? e + "" : e, t);
var $i2 = class extends R2 {
  constructor(e, t, s = true) {
    super(e, t, s), this.core = e, this.logger = t, E3(this, "context", Xt), E3(this, "storagePrefix", B), E3(this, "storageVersion", Jt2), E3(this, "events", /* @__PURE__ */ new Map()), E3(this, "shouldPersist", false), E3(this, "init", async () => {
      if (!Eo()) try {
        const i3 = { eventId: wo(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Yt(this.core.relayer.protocol, this.core.relayer.version, me2) } } };
        await this.sendEvent([i3]);
      } catch (i3) {
        this.logger.warn(i3);
      }
    }), E3(this, "createEvent", (i3) => {
      const { event: r2 = "ERROR", type: o3 = "", properties: { topic: a2, trace: c6 } } = i3, h6 = wo(), u3 = this.core.projectId || "", g3 = Date.now(), m3 = pe({ eventId: h6, timestamp: g3, props: { event: r2, type: o3, properties: { topic: a2, trace: c6 } }, bundleId: u3, domain: this.getAppDomain() }, this.setMethods(h6));
      return this.telemetryEnabled && (this.events.set(h6, m3), this.shouldPersist = true), m3;
    }), E3(this, "getEvent", (i3) => {
      const { eventId: r2, topic: o3 } = i3;
      if (r2) return this.events.get(r2);
      const a2 = Array.from(this.events.values()).find((c6) => c6.props.properties.topic === o3);
      if (a2) return pe(pe({}, a2), this.setMethods(a2.eventId));
    }), E3(this, "deleteEvent", (i3) => {
      const { eventId: r2 } = i3;
      this.events.delete(r2), this.shouldPersist = true;
    }), E3(this, "setEventListeners", () => {
      this.core.heartbeat.on(r.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((i3) => {
          (0, import_time2.fromMiliseconds)(Date.now()) - (0, import_time2.fromMiliseconds)(i3.timestamp) > Wt2 && (this.events.delete(i3.eventId), this.shouldPersist = true);
        });
      });
    }), E3(this, "setMethods", (i3) => ({ addTrace: (r2) => this.addTrace(i3, r2), setError: (r2) => this.setError(i3, r2) })), E3(this, "addTrace", (i3, r2) => {
      const o3 = this.events.get(i3);
      o3 && (o3.props.properties.trace.push(r2), this.events.set(i3, o3), this.shouldPersist = true);
    }), E3(this, "setError", (i3, r2) => {
      const o3 = this.events.get(i3);
      o3 && (o3.props.type = r2, o3.timestamp = Date.now(), this.events.set(i3, o3), this.shouldPersist = true);
    }), E3(this, "persist", async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }), E3(this, "restore", async () => {
      try {
        const i3 = await this.core.storage.getItem(this.storageKey) || [];
        if (!i3.length) return;
        i3.forEach((r2) => {
          this.events.set(r2.eventId, pe(pe({}, r2), this.setMethods(r2.eventId)));
        });
      } catch (i3) {
        this.logger.warn(i3);
      }
    }), E3(this, "submit", async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const i3 = [];
      for (const [r2, o3] of this.events) o3.props.type && i3.push(o3);
      if (i3.length !== 0) try {
        if ((await this.sendEvent(i3)).ok) for (const r2 of i3) this.events.delete(r2.eventId), this.shouldPersist = true;
      } catch (r2) {
        this.logger.warn(r2);
      }
    }), E3(this, "sendEvent", async (i3) => {
      const r2 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${Zt}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${me2}${r2}`, { method: "POST", body: JSON.stringify(i3) });
    }), E3(this, "getAppDomain", () => Yr().url), this.logger = E(t, this.context), this.telemetryEnabled = s, s ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var no2 = Object.defineProperty;
var zi2 = Object.getOwnPropertySymbols;
var oo = Object.prototype.hasOwnProperty;
var ao2 = Object.prototype.propertyIsEnumerable;
var Ge2 = (n3, e, t) => e in n3 ? no2(n3, e, { enumerable: true, configurable: true, writable: true, value: t }) : n3[e] = t;
var Li2 = (n3, e) => {
  for (var t in e || (e = {})) oo.call(e, t) && Ge2(n3, t, e[t]);
  if (zi2) for (var t of zi2(e)) ao2.call(e, t) && Ge2(n3, t, e[t]);
  return n3;
};
var f6 = (n3, e, t) => Ge2(n3, typeof e != "symbol" ? e + "" : e, t);
var _e2 = class __e extends h3 {
  constructor(e) {
    var t;
    super(e), f6(this, "protocol", xe2), f6(this, "version", Oe2), f6(this, "name", he), f6(this, "relayUrl"), f6(this, "projectId"), f6(this, "customStoragePrefix"), f6(this, "events", new import_events3.EventEmitter()), f6(this, "logger"), f6(this, "heartbeat"), f6(this, "relayer"), f6(this, "crypto"), f6(this, "storage"), f6(this, "history"), f6(this, "expirer"), f6(this, "pairing"), f6(this, "verify"), f6(this, "echoClient"), f6(this, "linkModeSupportedApps"), f6(this, "eventClient"), f6(this, "initialized", false), f6(this, "logChunkController"), f6(this, "on", (o3, a2) => this.events.on(o3, a2)), f6(this, "once", (o3, a2) => this.events.once(o3, a2)), f6(this, "off", (o3, a2) => this.events.off(o3, a2)), f6(this, "removeListener", (o3, a2) => this.events.removeListener(o3, a2)), f6(this, "dispatchEnvelope", ({ topic: o3, message: a2, sessionExists: c6 }) => {
      if (!o3 || !a2) return;
      const h6 = { topic: o3, message: a2, publishedAt: Date.now(), transportType: Q2.link_mode };
      this.relayer.onLinkMessageEvent(h6, { sessionExists: c6 });
    }), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || $e2, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const s = k({ level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : mt2.logger, name: he }), { logger: i3, chunkLoggerController: r2 } = A({ opts: s, maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes, loggerOverride: e == null ? void 0 : e.logger });
    this.logChunkController = r2, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var o3, a2;
      (o3 = this.logChunkController) != null && o3.downloadLogsBlobInBrowser && ((a2 = this.logChunkController) == null || a2.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E(i3, this.name), this.heartbeat = new i(), this.crypto = new bi2(this, this.logger, e == null ? void 0 : e.keychain), this.history = new Si(this, this.logger), this.expirer = new Ri2(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h2(Li2(Li2({}, vt2), e == null ? void 0 : e.storageOptions)), this.relayer = new wi2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Pi3(this, this.logger), this.verify = new xi(this, this.logger, this.storage), this.echoClient = new Ai(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new $i2(this, this.logger, e == null ? void 0 : e.telemetryEnabled);
  }
  static async init(e) {
    const t = new __e(e);
    await t.initialize();
    const s = await t.crypto.getClientId();
    return await t.storage.setItem(Nt2, s), t;
  }
  get context() {
    return y(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(ze2, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(ze2) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
var co2 = _e2;

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/types/dist/index.es.js
var import_events5 = __toESM(require_events());
var T2 = Object.defineProperty;
var k3 = (e, s, r2) => s in e ? T2(e, s, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s] = r2;
var i2 = (e, s, r2) => k3(e, typeof s != "symbol" ? s + "" : s, r2);
var J4 = class {
  constructor(s) {
    this.opts = s, i2(this, "protocol", "wc"), i2(this, "version", 2);
  }
};
var V3 = class {
  constructor(s) {
    this.client = s;
  }
};

// node_modules/@walletconnect/sign-client/dist/index.es.js
var import_time3 = __toESM(require_cjs());
var import_events6 = __toESM(require_events());
var De2 = "wc";
var Le3 = 2;
var Me3 = "client";
var me3 = `${De2}@${Le3}:${Me3}:`;
var _e3 = { name: Me3, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.org" };
var ke3 = "WALLETCONNECT_DEEPLINK_CHOICE";
var pt2 = "proposal";
var $e3 = "Proposal expired";
var ht2 = "session";
var Y2 = import_time3.SEVEN_DAYS;
var dt2 = "engine";
var N2 = { wc_sessionPropose: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time3.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time3.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var Ee3 = { min: import_time3.FIVE_MINUTES, max: import_time3.SEVEN_DAYS };
var $2 = { idle: "IDLE", active: "ACTIVE" };
var Ke3 = { eth_sendTransaction: { key: "" }, eth_sendRawTransaction: { key: "" }, wallet_sendCalls: { key: "" }, solana_signTransaction: { key: "signature" }, solana_signAllTransactions: { key: "transactions" }, solana_signAndSendTransaction: { key: "signature" } };
var ut2 = "request";
var gt2 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var yt2 = "wc";
var wt3 = "auth";
var mt3 = "authKeys";
var _t3 = "pairingTopics";
var Et3 = "requests";
var ce2 = `${yt2}@${1.5}:${wt3}:`;
var le3 = `${ce2}:PUB_KEY`;
var Rs2 = Object.defineProperty;
var fs2 = Object.defineProperties;
var Is2 = Object.getOwnPropertyDescriptors;
var St3 = Object.getOwnPropertySymbols;
var vs2 = Object.prototype.hasOwnProperty;
var qs3 = Object.prototype.propertyIsEnumerable;
var Ue3 = (S7, n3, e) => n3 in S7 ? Rs2(S7, n3, { enumerable: true, configurable: true, writable: true, value: e }) : S7[n3] = e;
var v2 = (S7, n3) => {
  for (var e in n3 || (n3 = {})) vs2.call(n3, e) && Ue3(S7, e, n3[e]);
  if (St3) for (var e of St3(n3)) qs3.call(n3, e) && Ue3(S7, e, n3[e]);
  return S7;
};
var x4 = (S7, n3) => fs2(S7, Is2(n3));
var c3 = (S7, n3, e) => Ue3(S7, typeof n3 != "symbol" ? n3 + "" : n3, e);
var Ts2 = class extends V3 {
  constructor(n3) {
    super(n3), c3(this, "name", dt2), c3(this, "events", new import_events6.default()), c3(this, "initialized", false), c3(this, "requestQueue", { state: $2.idle, queue: [] }), c3(this, "sessionRequestQueue", { state: $2.idle, queue: [] }), c3(this, "requestQueueDelay", import_time3.ONE_SECOND), c3(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), c3(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), c3(this, "recentlyDeletedLimit", 200), c3(this, "relayMessageCache", []), c3(this, "pendingSessions", /* @__PURE__ */ new Map()), c3(this, "init", async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(N2) }), this.initialized = true, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay)));
    }), c3(this, "connect", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const t = x4(v2({}, e), { requiredNamespaces: e.requiredNamespaces || {}, optionalNamespaces: e.optionalNamespaces || {} });
      await this.isValidConnect(t);
      const { pairingTopic: s, requiredNamespaces: i3, optionalNamespaces: r2, sessionProperties: o3, relays: a2 } = t;
      let l5 = s, u3, g3 = false;
      try {
        if (l5) {
          const R6 = this.client.core.pairing.pairings.get(l5);
          this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), g3 = R6.active;
        }
      } catch (R6) {
        throw this.client.logger.error(`connect() -> pairing.get(${l5}) failed`), R6;
      }
      if (!l5 || !g3) {
        const { topic: R6, uri: D6 } = await this.client.core.pairing.create();
        l5 = R6, u3 = D6;
      }
      if (!l5) {
        const { message: R6 } = te("NO_MATCHING_KEY", `connect() pairing topic: ${l5}`);
        throw new Error(R6);
      }
      const h6 = await this.client.core.crypto.generateKeyPair(), d5 = N2.wc_sessionPropose.req.ttl || import_time3.FIVE_MINUTES, y9 = ho(d5), m3 = x4(v2({ requiredNamespaces: i3, optionalNamespaces: r2, relays: a2 ?? [{ protocol: Pt2 }], proposer: { publicKey: h6, metadata: this.client.metadata }, expiryTimestamp: y9, pairingTopic: l5 }, o3 && { sessionProperties: o3 }), { id: payloadId() }), I5 = go("session_connect", m3.id), { reject: p6, resolve: E9, done: V8 } = co(d5, $e3), q5 = ({ id: R6 }) => {
        R6 === m3.id && (this.client.events.off("proposal_expire", q5), this.pendingSessions.delete(m3.id), this.events.emit(I5, { error: { message: $e3, code: 0 } }));
      };
      return this.client.events.on("proposal_expire", q5), this.events.once(I5, ({ error: R6, session: D6 }) => {
        this.client.events.off("proposal_expire", q5), R6 ? p6(R6) : D6 && E9(D6);
      }), await this.sendRequest({ topic: l5, method: "wc_sessionPropose", params: m3, throwOnFailedPublish: true, clientRpcId: m3.id }), await this.setProposal(m3.id, m3), { uri: u3, approval: V8 };
    }), c3(this, "pair", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(e);
      } catch (t) {
        throw this.client.logger.error("pair() failed"), t;
      }
    }), c3(this, "approve", async (e) => {
      var t, s, i3;
      const r2 = this.client.core.eventClient.createEvent({ properties: { topic: (t = e == null ? void 0 : e.id) == null ? void 0 : t.toString(), trace: [qs2.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (P6) {
        throw r2.setError(Gs2.no_internet_connection), P6;
      }
      try {
        await this.isValidProposalId(e == null ? void 0 : e.id);
      } catch (P6) {
        throw this.client.logger.error(`approve() -> proposal.get(${e == null ? void 0 : e.id}) failed`), r2.setError(Gs2.proposal_not_found), P6;
      }
      try {
        await this.isValidApprove(e);
      } catch (P6) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), r2.setError(Gs2.session_approve_namespace_validation_failure), P6;
      }
      const { id: o3, relayProtocol: a2, namespaces: l5, sessionProperties: u3, sessionConfig: g3 } = e, h6 = this.client.proposal.get(o3);
      this.client.core.eventClient.deleteEvent({ eventId: r2.eventId });
      const { pairingTopic: d5, proposer: y9, requiredNamespaces: m3, optionalNamespaces: I5 } = h6;
      let p6 = (s = this.client.core.eventClient) == null ? void 0 : s.getEvent({ topic: d5 });
      p6 || (p6 = (i3 = this.client.core.eventClient) == null ? void 0 : i3.createEvent({ type: qs2.session_approve_started, properties: { topic: d5, trace: [qs2.session_approve_started, qs2.session_namespaces_validation_success] } }));
      const E9 = await this.client.core.crypto.generateKeyPair(), V8 = y9.publicKey, q5 = await this.client.core.crypto.generateSharedKey(E9, V8), R6 = v2(v2({ relay: { protocol: a2 ?? "irn" }, namespaces: l5, controller: { publicKey: E9, metadata: this.client.metadata }, expiry: ho(Y2) }, u3 && { sessionProperties: u3 }), g3 && { sessionConfig: g3 }), D6 = Q2.relay;
      p6.addTrace(qs2.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(q5, { transportType: D6 });
      } catch (P6) {
        throw p6.setError(Gs2.subscribe_session_topic_failure), P6;
      }
      p6.addTrace(qs2.subscribe_session_topic_success);
      const ee6 = x4(v2({}, R6), { topic: q5, requiredNamespaces: m3, optionalNamespaces: I5, pairingTopic: d5, acknowledged: false, self: R6.controller, peer: { publicKey: y9.publicKey, metadata: y9.metadata }, controller: E9, transportType: Q2.relay });
      await this.client.session.set(q5, ee6), p6.addTrace(qs2.store_session);
      try {
        p6.addTrace(qs2.publishing_session_settle), await this.sendRequest({ topic: q5, method: "wc_sessionSettle", params: R6, throwOnFailedPublish: true }).catch((P6) => {
          throw p6 == null ? void 0 : p6.setError(Gs2.session_settle_publish_failure), P6;
        }), p6.addTrace(qs2.session_settle_publish_success), p6.addTrace(qs2.publishing_session_approve), await this.sendResult({ id: o3, topic: d5, result: { relay: { protocol: a2 ?? "irn" }, responderPublicKey: E9 }, throwOnFailedPublish: true }).catch((P6) => {
          throw p6 == null ? void 0 : p6.setError(Gs2.session_approve_publish_failure), P6;
        }), p6.addTrace(qs2.session_approve_publish_success);
      } catch (P6) {
        throw this.client.logger.error(P6), this.client.session.delete(q5, de("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(q5), P6;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: p6.eventId }), await this.client.core.pairing.updateMetadata({ topic: d5, metadata: y9.metadata }), await this.client.proposal.delete(o3, de("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: d5 }), await this.setExpiry(q5, ho(Y2)), { topic: q5, acknowledged: () => Promise.resolve(this.client.session.get(q5)) };
    }), c3(this, "reject", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(e);
      } catch (r2) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r2;
      }
      const { id: t, reason: s } = e;
      let i3;
      try {
        i3 = this.client.proposal.get(t).pairingTopic;
      } catch (r2) {
        throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`), r2;
      }
      i3 && (await this.sendError({ id: t, topic: i3, error: s, rpcOpts: N2.wc_sessionPropose.reject }), await this.client.proposal.delete(t, de("USER_DISCONNECTED")));
    }), c3(this, "update", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(e);
      } catch (g3) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), g3;
      }
      const { topic: t, namespaces: s } = e, { done: i3, resolve: r2, reject: o3 } = co(), a2 = payloadId(), l5 = getBigIntRpcId().toString(), u3 = this.client.session.get(t).namespaces;
      return this.events.once(go("session_update", a2), ({ error: g3 }) => {
        g3 ? o3(g3) : r2();
      }), await this.client.session.update(t, { namespaces: s }), await this.sendRequest({ topic: t, method: "wc_sessionUpdate", params: { namespaces: s }, throwOnFailedPublish: true, clientRpcId: a2, relayRpcId: l5 }).catch((g3) => {
        this.client.logger.error(g3), this.client.session.update(t, { namespaces: u3 }), o3(g3);
      }), { acknowledged: i3 };
    }), c3(this, "extend", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(e);
      } catch (a2) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a2;
      }
      const { topic: t } = e, s = payloadId(), { done: i3, resolve: r2, reject: o3 } = co();
      return this.events.once(go("session_extend", s), ({ error: a2 }) => {
        a2 ? o3(a2) : r2();
      }), await this.setExpiry(t, ho(Y2)), this.sendRequest({ topic: t, method: "wc_sessionExtend", params: {}, clientRpcId: s, throwOnFailedPublish: true }).catch((a2) => {
        o3(a2);
      }), { acknowledged: i3 };
    }), c3(this, "request", async (e) => {
      this.isInitialized();
      try {
        await this.isValidRequest(e);
      } catch (p6) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), p6;
      }
      const { chainId: t, request: s, topic: i3, expiry: r2 = N2.wc_sessionRequest.req.ttl } = e, o3 = this.client.session.get(i3);
      (o3 == null ? void 0 : o3.transportType) === Q2.relay && await this.confirmOnlineStateOrThrow();
      const a2 = payloadId(), l5 = getBigIntRpcId().toString(), { done: u3, resolve: g3, reject: h6 } = co(r2, "Request expired. Please try again.");
      this.events.once(go("session_request", a2), ({ error: p6, result: E9 }) => {
        p6 ? h6(p6) : g3(E9);
      });
      const d5 = "wc_sessionRequest", y9 = this.getAppLinkIfEnabled(o3.peer.metadata, o3.transportType);
      if (y9) return await this.sendRequest({ clientRpcId: a2, relayRpcId: l5, topic: i3, method: d5, params: { request: x4(v2({}, s), { expiryTimestamp: ho(r2) }), chainId: t }, expiry: r2, throwOnFailedPublish: true, appLink: y9 }).catch((p6) => h6(p6)), this.client.events.emit("session_request_sent", { topic: i3, request: s, chainId: t, id: a2 }), await u3();
      const m3 = { request: x4(v2({}, s), { expiryTimestamp: ho(r2) }), chainId: t }, I5 = this.shouldSetTVF(d5, m3);
      return await Promise.all([new Promise(async (p6) => {
        await this.sendRequest(v2({ clientRpcId: a2, relayRpcId: l5, topic: i3, method: d5, params: m3, expiry: r2, throwOnFailedPublish: true }, I5 && { tvf: this.getTVFParams(a2, m3) })).catch((E9) => h6(E9)), this.client.events.emit("session_request_sent", { topic: i3, request: s, chainId: t, id: a2 }), p6();
      }), new Promise(async (p6) => {
        var E9;
        if (!((E9 = o3.sessionConfig) != null && E9.disableDeepLink)) {
          const V8 = await mo(this.client.core.storage, ke3);
          await yo({ id: a2, topic: i3, wcDeepLink: V8 });
        }
        p6();
      }), u3()]).then((p6) => p6[2]);
    }), c3(this, "respond", async (e) => {
      this.isInitialized(), await this.isValidRespond(e);
      const { topic: t, response: s } = e, { id: i3 } = s, r2 = this.client.session.get(t);
      r2.transportType === Q2.relay && await this.confirmOnlineStateOrThrow();
      const o3 = this.getAppLinkIfEnabled(r2.peer.metadata, r2.transportType);
      isJsonRpcResult(s) ? await this.sendResult({ id: i3, topic: t, result: s.result, throwOnFailedPublish: true, appLink: o3 }) : isJsonRpcError(s) && await this.sendError({ id: i3, topic: t, error: s.error, appLink: o3 }), this.cleanupAfterResponse(e);
    }), c3(this, "ping", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(e);
      } catch (s) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s;
      }
      const { topic: t } = e;
      if (this.client.session.keys.includes(t)) {
        const s = payloadId(), i3 = getBigIntRpcId().toString(), { done: r2, resolve: o3, reject: a2 } = co();
        this.events.once(go("session_ping", s), ({ error: l5 }) => {
          l5 ? a2(l5) : o3();
        }), await Promise.all([this.sendRequest({ topic: t, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s, relayRpcId: i3 }), r2()]);
      } else this.client.core.pairing.pairings.keys.includes(t) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: t }));
    }), c3(this, "emit", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e);
      const { topic: t, event: s, chainId: i3 } = e, r2 = getBigIntRpcId().toString(), o3 = payloadId();
      await this.sendRequest({ topic: t, method: "wc_sessionEvent", params: { event: s, chainId: i3 }, throwOnFailedPublish: true, relayRpcId: r2, clientRpcId: o3 });
    }), c3(this, "disconnect", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e);
      const { topic: t } = e;
      if (this.client.session.keys.includes(t)) await this.sendRequest({ topic: t, method: "wc_sessionDelete", params: de("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: t, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(t)) await this.client.core.pairing.disconnect({ topic: t });
      else {
        const { message: s } = te("MISMATCHED_TOPIC", `Session or pairing topic not found: ${t}`);
        throw new Error(s);
      }
    }), c3(this, "find", (e) => (this.isInitialized(), this.client.session.getAll().filter((t) => $i(t, e)))), c3(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), c3(this, "authenticate", async (e, t) => {
      var s;
      this.isInitialized(), this.isValidAuthenticate(e);
      const i3 = t && this.client.core.linkModeSupportedApps.includes(t) && ((s = this.client.metadata.redirect) == null ? void 0 : s.linkMode), r2 = i3 ? Q2.link_mode : Q2.relay;
      r2 === Q2.relay && await this.confirmOnlineStateOrThrow();
      const { chains: o3, statement: a2 = "", uri: l5, domain: u3, nonce: g3, type: h6, exp: d5, nbf: y9, methods: m3 = [], expiry: I5 } = e, p6 = [...e.resources || []], { topic: E9, uri: V8 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r2 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: E9, uri: V8 } });
      const q5 = await this.client.core.crypto.generateKeyPair(), R6 = oi(q5);
      if (await Promise.all([this.client.auth.authKeys.set(le3, { responseTopic: R6, publicKey: q5 }), this.client.auth.pairingTopics.set(R6, { topic: R6, pairingTopic: E9 })]), await this.client.core.relayer.subscribe(R6, { transportType: r2 }), this.client.logger.info(`sending request to new pairing topic: ${E9}`), m3.length > 0) {
        const { namespace: b4 } = Ye(o3[0]);
        let L5 = ts(b4, "request", m3);
        Me(p6) && (L5 = ns(L5, p6.pop())), p6.push(L5);
      }
      const D6 = I5 && I5 > N2.wc_sessionAuthenticate.req.ttl ? I5 : N2.wc_sessionAuthenticate.req.ttl, ee6 = { authPayload: { type: h6 ?? "caip122", chains: o3, statement: a2, aud: l5, domain: u3, version: "1", nonce: g3, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: d5, nbf: y9, resources: p6 }, requester: { publicKey: q5, metadata: this.client.metadata }, expiryTimestamp: ho(D6) }, P6 = { eip155: { chains: o3, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...m3])], events: ["chainChanged", "accountsChanged"] } }, X2 = { requiredNamespaces: {}, optionalNamespaces: P6, relays: [{ protocol: "irn" }], pairingTopic: E9, proposer: { publicKey: q5, metadata: this.client.metadata }, expiryTimestamp: ho(N2.wc_sessionPropose.req.ttl), id: payloadId() }, { done: ft6, resolve: Fe7, reject: Re5 } = co(D6, "Request expired"), te7 = payloadId(), pe5 = go("session_connect", X2.id), fe6 = go("session_request", te7), he5 = async ({ error: b4, session: L5 }) => {
        this.events.off(fe6, Ie7), b4 ? Re5(b4) : L5 && Fe7({ session: L5 });
      }, Ie7 = async (b4) => {
        var L5, je7, Qe5;
        if (await this.deletePendingAuthRequest(te7, { message: "fulfilled", code: 0 }), b4.error) {
          const ie7 = de("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return b4.error.code === ie7.code ? void 0 : (this.events.off(pe5, he5), Re5(b4.error.message));
        }
        await this.deleteProposal(X2.id), this.events.off(pe5, he5);
        const { cacaos: He6, responder: Q5 } = b4.result, qe7 = [], ze7 = [];
        for (const ie7 of He6) {
          await Yo({ cacao: ie7, projectId: this.client.core.projectId }) || (this.client.logger.error(ie7, "Signature verification failed"), Re5(de("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: Te6 } = ie7, Ne6 = Me(Te6.resources), Ye7 = [On(Te6.iss)], It6 = ut(Te6.iss);
          if (Ne6) {
            const Pe5 = rs(Ne6), vt6 = os(Ne6);
            qe7.push(...Pe5), Ye7.push(...vt6);
          }
          for (const Pe5 of Ye7) ze7.push(`${Pe5}:${It6}`);
        }
        const se7 = await this.client.core.crypto.generateSharedKey(q5, Q5.publicKey);
        let de7;
        qe7.length > 0 && (de7 = { topic: se7, acknowledged: true, self: { publicKey: q5, metadata: this.client.metadata }, peer: Q5, controller: Q5.publicKey, expiry: ho(Y2), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: E9, namespaces: Ti([...new Set(qe7)], [...new Set(ze7)]), transportType: r2 }, await this.client.core.relayer.subscribe(se7, { transportType: r2 }), await this.client.session.set(se7, de7), E9 && await this.client.core.pairing.updateMetadata({ topic: E9, metadata: Q5.metadata }), de7 = this.client.session.get(se7)), (L5 = this.client.metadata.redirect) != null && L5.linkMode && (je7 = Q5.metadata.redirect) != null && je7.linkMode && (Qe5 = Q5.metadata.redirect) != null && Qe5.universal && t && (this.client.core.addLinkModeSupportedApp(Q5.metadata.redirect.universal), this.client.session.update(se7, { transportType: Q2.link_mode })), Fe7({ auths: He6, session: de7 });
      };
      this.events.once(pe5, he5), this.events.once(fe6, Ie7);
      let ve5;
      try {
        if (i3) {
          const b4 = formatJsonRpcRequest("wc_sessionAuthenticate", ee6, te7);
          this.client.core.history.set(E9, b4);
          const L5 = await this.client.core.crypto.encode("", b4, { type: _e, encoding: Qs });
          ve5 = Ei(t, E9, L5);
        } else await Promise.all([this.sendRequest({ topic: E9, method: "wc_sessionAuthenticate", params: ee6, expiry: e.expiry, throwOnFailedPublish: true, clientRpcId: te7 }), this.sendRequest({ topic: E9, method: "wc_sessionPropose", params: X2, expiry: N2.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: X2.id })]);
      } catch (b4) {
        throw this.events.off(pe5, he5), this.events.off(fe6, Ie7), b4;
      }
      return await this.setProposal(X2.id, X2), await this.setAuthRequest(te7, { request: x4(v2({}, ee6), { verifyContext: {} }), pairingTopic: E9, transportType: r2 }), { uri: ve5 ?? V8, response: ft6 };
    }), c3(this, "approveSessionAuthenticate", async (e) => {
      const { id: t, auths: s } = e, i3 = this.client.core.eventClient.createEvent({ properties: { topic: t.toString(), trace: [Hs2.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (I5) {
        throw i3.setError(Ys2.no_internet_connection), I5;
      }
      const r2 = this.getPendingAuthRequest(t);
      if (!r2) throw i3.setError(Ys2.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t}`);
      const o3 = r2.transportType || Q2.relay;
      o3 === Q2.relay && await this.confirmOnlineStateOrThrow();
      const a2 = r2.requester.publicKey, l5 = await this.client.core.crypto.generateKeyPair(), u3 = oi(a2), g3 = { type: Ie, receiverPublicKey: a2, senderPublicKey: l5 }, h6 = [], d5 = [];
      for (const I5 of s) {
        if (!await Yo({ cacao: I5, projectId: this.client.core.projectId })) {
          i3.setError(Ys2.invalid_cacao);
          const R6 = de("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: t, topic: u3, error: R6, encodeOpts: g3 }), new Error(R6.message);
        }
        i3.addTrace(Hs2.cacaos_verified);
        const { p: p6 } = I5, E9 = Me(p6.resources), V8 = [On(p6.iss)], q5 = ut(p6.iss);
        if (E9) {
          const R6 = rs(E9), D6 = os(E9);
          h6.push(...R6), V8.push(...D6);
        }
        for (const R6 of V8) d5.push(`${R6}:${q5}`);
      }
      const y9 = await this.client.core.crypto.generateSharedKey(l5, a2);
      i3.addTrace(Hs2.create_authenticated_session_topic);
      let m3;
      if ((h6 == null ? void 0 : h6.length) > 0) {
        m3 = { topic: y9, acknowledged: true, self: { publicKey: l5, metadata: this.client.metadata }, peer: { publicKey: a2, metadata: r2.requester.metadata }, controller: a2, expiry: ho(Y2), authentication: s, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r2.pairingTopic, namespaces: Ti([...new Set(h6)], [...new Set(d5)]), transportType: o3 }, i3.addTrace(Hs2.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(y9, { transportType: o3 });
        } catch (I5) {
          throw i3.setError(Ys2.subscribe_authenticated_session_topic_failure), I5;
        }
        i3.addTrace(Hs2.subscribe_authenticated_session_topic_success), await this.client.session.set(y9, m3), i3.addTrace(Hs2.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r2.pairingTopic, metadata: r2.requester.metadata });
      }
      i3.addTrace(Hs2.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: u3, id: t, result: { cacaos: s, responder: { publicKey: l5, metadata: this.client.metadata } }, encodeOpts: g3, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r2.requester.metadata, o3) });
      } catch (I5) {
        throw i3.setError(Ys2.authenticated_session_approve_publish_failure), I5;
      }
      return await this.client.auth.requests.delete(t, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r2.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i3.eventId }), { session: m3 };
    }), c3(this, "rejectSessionAuthenticate", async (e) => {
      this.isInitialized();
      const { id: t, reason: s } = e, i3 = this.getPendingAuthRequest(t);
      if (!i3) throw new Error(`Could not find pending auth request with id ${t}`);
      i3.transportType === Q2.relay && await this.confirmOnlineStateOrThrow();
      const r2 = i3.requester.publicKey, o3 = await this.client.core.crypto.generateKeyPair(), a2 = oi(r2), l5 = { type: Ie, receiverPublicKey: r2, senderPublicKey: o3 };
      await this.sendError({ id: t, topic: a2, error: s, encodeOpts: l5, rpcOpts: N2.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i3.requester.metadata, i3.transportType) }), await this.client.auth.requests.delete(t, { message: "rejected", code: 0 }), await this.client.proposal.delete(t, de("USER_DISCONNECTED"));
    }), c3(this, "formatAuthMessage", (e) => {
      this.isInitialized();
      const { request: t, iss: s } = e;
      return In(t, s);
    }), c3(this, "processRelayMessageCache", () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const e = this.relayMessageCache.shift();
          e && await this.onRelayMessage(e);
        } catch (e) {
          this.client.logger.error(e);
        }
      }, 50);
    }), c3(this, "cleanupDuplicatePairings", async (e) => {
      if (e.pairingTopic) try {
        const t = this.client.core.pairing.pairings.get(e.pairingTopic), s = this.client.core.pairing.pairings.getAll().filter((i3) => {
          var r2, o3;
          return ((r2 = i3.peerMetadata) == null ? void 0 : r2.url) && ((o3 = i3.peerMetadata) == null ? void 0 : o3.url) === e.peer.metadata.url && i3.topic && i3.topic !== t.topic;
        });
        if (s.length === 0) return;
        this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`), await Promise.all(s.map((i3) => this.client.core.pairing.disconnect({ topic: i3.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (t) {
        this.client.logger.error(t);
      }
    }), c3(this, "deleteSession", async (e) => {
      var t;
      const { topic: s, expirerHasDeleted: i3 = false, emitEvent: r2 = true, id: o3 = 0 } = e, { self: a2 } = this.client.session.get(s);
      await this.client.core.relayer.unsubscribe(s), await this.client.session.delete(s, de("USER_DISCONNECTED")), this.addToRecentlyDeleted(s, "session"), this.client.core.crypto.keychain.has(a2.publicKey) && await this.client.core.crypto.deleteKeyPair(a2.publicKey), this.client.core.crypto.keychain.has(s) && await this.client.core.crypto.deleteSymKey(s), i3 || this.client.core.expirer.del(s), this.client.core.storage.removeItem(ke3).catch((l5) => this.client.logger.warn(l5)), this.getPendingSessionRequests().forEach((l5) => {
        l5.topic === s && this.deletePendingSessionRequest(l5.id, de("USER_DISCONNECTED"));
      }), s === ((t = this.sessionRequestQueue.queue[0]) == null ? void 0 : t.topic) && (this.sessionRequestQueue.state = $2.idle), r2 && this.client.events.emit("session_delete", { id: o3, topic: s });
    }), c3(this, "deleteProposal", async (e, t) => {
      if (t) try {
        const s = this.client.proposal.get(e), i3 = this.client.core.eventClient.getEvent({ topic: s.pairingTopic });
        i3 == null ? void 0 : i3.setError(Gs2.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(e, de("USER_DISCONNECTED")), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "proposal");
    }), c3(this, "deletePendingSessionRequest", async (e, t, s = false) => {
      await Promise.all([this.client.pendingRequest.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i3) => i3.id !== e), s && (this.sessionRequestQueue.state = $2.idle, this.client.events.emit("session_request_expire", { id: e }));
    }), c3(this, "deletePendingAuthRequest", async (e, t, s = false) => {
      await Promise.all([this.client.auth.requests.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]);
    }), c3(this, "setExpiry", async (e, t) => {
      this.client.session.keys.includes(e) && (this.client.core.expirer.set(e, t), await this.client.session.update(e, { expiry: t }));
    }), c3(this, "setProposal", async (e, t) => {
      this.client.core.expirer.set(e, ho(N2.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e, t);
    }), c3(this, "setAuthRequest", async (e, t) => {
      const { request: s, pairingTopic: i3, transportType: r2 = Q2.relay } = t;
      this.client.core.expirer.set(e, s.expiryTimestamp), await this.client.auth.requests.set(e, { authPayload: s.authPayload, requester: s.requester, expiryTimestamp: s.expiryTimestamp, id: e, pairingTopic: i3, verifyContext: s.verifyContext, transportType: r2 });
    }), c3(this, "setPendingSessionRequest", async (e) => {
      const { id: t, topic: s, params: i3, verifyContext: r2 } = e, o3 = i3.request.expiryTimestamp || ho(N2.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(t, o3), await this.client.pendingRequest.set(t, { id: t, topic: s, params: i3, verifyContext: r2 });
    }), c3(this, "sendRequest", async (e) => {
      const { topic: t, method: s, params: i3, expiry: r2, relayRpcId: o3, clientRpcId: a2, throwOnFailedPublish: l5, appLink: u3, tvf: g3 } = e, h6 = formatJsonRpcRequest(s, i3, a2);
      let d5;
      const y9 = !!u3;
      try {
        const p6 = y9 ? Qs : At;
        d5 = await this.client.core.crypto.encode(t, h6, { encoding: p6 });
      } catch (p6) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`), p6;
      }
      let m3;
      if (gt2.includes(s)) {
        const p6 = si(JSON.stringify(h6)), E9 = si(d5);
        m3 = await this.client.core.verify.register({ id: E9, decryptedId: p6 });
      }
      const I5 = N2[s].req;
      if (I5.attestation = m3, r2 && (I5.ttl = r2), o3 && (I5.id = o3), this.client.core.history.set(t, h6), y9) {
        const p6 = Ei(u3, t, d5);
        await global.Linking.openURL(p6, this.client.name);
      } else {
        const p6 = N2[s].req;
        r2 && (p6.ttl = r2), o3 && (p6.id = o3), p6.tvf = x4(v2({}, g3), { correlationId: h6.id }), l5 ? (p6.internal = x4(v2({}, p6.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t, d5, p6)) : this.client.core.relayer.publish(t, d5, p6).catch((E9) => this.client.logger.error(E9));
      }
      return h6.id;
    }), c3(this, "sendResult", async (e) => {
      const { id: t, topic: s, result: i3, throwOnFailedPublish: r2, encodeOpts: o3, appLink: a2 } = e, l5 = formatJsonRpcResult(t, i3);
      let u3;
      const g3 = a2 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const y9 = g3 ? Qs : At;
        u3 = await this.client.core.crypto.encode(s, l5, x4(v2({}, o3 || {}), { encoding: y9 }));
      } catch (y9) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`), y9;
      }
      let h6, d5;
      try {
        h6 = await this.client.core.history.get(s, t);
        const y9 = h6.request;
        try {
          this.shouldSetTVF(y9.method, y9.params) && (d5 = this.getTVFParams(t, y9.params, i3));
        } catch (m3) {
          this.client.logger.warn("sendResult() -> getTVFParams() failed", m3);
        }
      } catch (y9) {
        throw this.client.logger.error(`sendResult() -> history.get(${s}, ${t}) failed`), y9;
      }
      if (g3) {
        const y9 = Ei(a2, s, u3);
        await global.Linking.openURL(y9, this.client.name);
      } else {
        const y9 = h6.request.method, m3 = N2[y9].res;
        m3.tvf = x4(v2({}, d5), { correlationId: t }), r2 ? (m3.internal = x4(v2({}, m3.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s, u3, m3)) : this.client.core.relayer.publish(s, u3, m3).catch((I5) => this.client.logger.error(I5));
      }
      await this.client.core.history.resolve(l5);
    }), c3(this, "sendError", async (e) => {
      const { id: t, topic: s, error: i3, encodeOpts: r2, rpcOpts: o3, appLink: a2 } = e, l5 = formatJsonRpcError(t, i3);
      let u3;
      const g3 = a2 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const d5 = g3 ? Qs : At;
        u3 = await this.client.core.crypto.encode(s, l5, x4(v2({}, r2 || {}), { encoding: d5 }));
      } catch (d5) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`), d5;
      }
      let h6;
      try {
        h6 = await this.client.core.history.get(s, t);
      } catch (d5) {
        throw this.client.logger.error(`sendError() -> history.get(${s}, ${t}) failed`), d5;
      }
      if (g3) {
        const d5 = Ei(a2, s, u3);
        await global.Linking.openURL(d5, this.client.name);
      } else {
        const d5 = h6.request.method, y9 = o3 || N2[d5].res;
        this.client.core.relayer.publish(s, u3, y9);
      }
      await this.client.core.history.resolve(l5);
    }), c3(this, "cleanup", async () => {
      const e = [], t = [];
      this.client.session.getAll().forEach((s) => {
        let i3 = false;
        po(s.expiry) && (i3 = true), this.client.core.crypto.keychain.has(s.topic) || (i3 = true), i3 && e.push(s.topic);
      }), this.client.proposal.getAll().forEach((s) => {
        po(s.expiryTimestamp) && t.push(s.id);
      }), await Promise.all([...e.map((s) => this.deleteSession({ topic: s })), ...t.map((s) => this.deleteProposal(s))]);
    }), c3(this, "onRelayEventRequest", async (e) => {
      this.requestQueue.queue.push(e), await this.processRequestsQueue();
    }), c3(this, "processRequestsQueue", async () => {
      if (this.requestQueue.state === $2.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = $2.active;
        const e = this.requestQueue.queue.shift();
        if (e) try {
          await this.processRequest(e);
        } catch (t) {
          this.client.logger.warn(t);
        }
      }
      this.requestQueue.state = $2.idle;
    }), c3(this, "processRequest", async (e) => {
      const { topic: t, payload: s, attestation: i3, transportType: r2, encryptedId: o3 } = e, a2 = s.method;
      if (!this.shouldIgnorePairingRequest({ topic: t, requestMethod: a2 })) switch (a2) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: t, payload: s, attestation: i3, encryptedId: o3 });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(t, s);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(t, s);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(t, s);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(t, s);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(t, s);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: t, payload: s, attestation: i3, encryptedId: o3, transportType: r2 });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(t, s);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: t, payload: s, attestation: i3, encryptedId: o3, transportType: r2 });
        default:
          return this.client.logger.info(`Unsupported request method ${a2}`);
      }
    }), c3(this, "onRelayEventResponse", async (e) => {
      const { topic: t, payload: s, transportType: i3 } = e, r2 = (await this.client.core.history.get(t, s.id)).request.method;
      switch (r2) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(t, s, i3);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(t, s);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(t, s);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(t, s);
        case "wc_sessionPing":
          return this.onSessionPingResponse(t, s);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(t, s);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(t, s);
        default:
          return this.client.logger.info(`Unsupported response method ${r2}`);
      }
    }), c3(this, "onRelayEventUnknownPayload", (e) => {
      const { topic: t } = e, { message: s } = te("MISSING_OR_INVALID", `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s);
    }), c3(this, "shouldIgnorePairingRequest", (e) => {
      const { topic: t, requestMethod: s } = e, i3 = this.expectedPairingMethodMap.get(t);
      return !i3 || i3.includes(s) ? false : !!(i3.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }), c3(this, "onSessionProposeRequest", async (e) => {
      const { topic: t, payload: s, attestation: i3, encryptedId: r2 } = e, { params: o3, id: a2 } = s;
      try {
        const l5 = this.client.core.eventClient.getEvent({ topic: t });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l5 == null ? void 0 : l5.setError(J3.proposal_listener_not_found)), this.isValidConnect(v2({}, s.params));
        const u3 = o3.expiryTimestamp || ho(N2.wc_sessionPropose.req.ttl), g3 = v2({ id: a2, pairingTopic: t, expiryTimestamp: u3 }, o3);
        await this.setProposal(a2, g3);
        const h6 = await this.getVerifyContext({ attestationId: i3, hash: si(JSON.stringify(s)), encryptedId: r2, metadata: g3.proposer.metadata });
        l5 == null ? void 0 : l5.addTrace(q2.emit_session_proposal), this.client.events.emit("session_proposal", { id: a2, params: g3, verifyContext: h6 });
      } catch (l5) {
        await this.sendError({ id: a2, topic: t, error: l5, rpcOpts: N2.wc_sessionPropose.autoReject }), this.client.logger.error(l5);
      }
    }), c3(this, "onSessionProposeResponse", async (e, t, s) => {
      const { id: i3 } = t;
      if (isJsonRpcResult(t)) {
        const { result: r2 } = t;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r2 });
        const o3 = this.client.proposal.get(i3);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: o3 });
        const a2 = o3.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a2 });
        const l5 = r2.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l5 });
        const u3 = await this.client.core.crypto.generateSharedKey(a2, l5);
        this.pendingSessions.set(i3, { sessionTopic: u3, pairingTopic: e, proposalId: i3, publicKey: a2 });
        const g3 = await this.client.core.relayer.subscribe(u3, { transportType: s });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: g3 }), await this.client.core.pairing.activate({ topic: e });
      } else if (isJsonRpcError(t)) {
        await this.client.proposal.delete(i3, de("USER_DISCONNECTED"));
        const r2 = go("session_connect", i3);
        if (this.events.listenerCount(r2) === 0) throw new Error(`emitting ${r2} without any listeners, 954`);
        this.events.emit(r2, { error: t.error });
      }
    }), c3(this, "onSessionSettleRequest", async (e, t) => {
      const { id: s, params: i3 } = t;
      try {
        this.isValidSessionSettleRequest(i3);
        const { relay: r2, controller: o3, expiry: a2, namespaces: l5, sessionProperties: u3, sessionConfig: g3 } = t.params, h6 = [...this.pendingSessions.values()].find((m3) => m3.sessionTopic === e);
        if (!h6) return this.client.logger.error(`Pending session not found for topic ${e}`);
        const d5 = this.client.proposal.get(h6.proposalId), y9 = x4(v2(v2({ topic: e, relay: r2, expiry: a2, namespaces: l5, acknowledged: true, pairingTopic: h6.pairingTopic, requiredNamespaces: d5.requiredNamespaces, optionalNamespaces: d5.optionalNamespaces, controller: o3.publicKey, self: { publicKey: h6.publicKey, metadata: this.client.metadata }, peer: { publicKey: o3.publicKey, metadata: o3.metadata } }, u3 && { sessionProperties: u3 }), g3 && { sessionConfig: g3 }), { transportType: Q2.relay });
        await this.client.session.set(y9.topic, y9), await this.setExpiry(y9.topic, y9.expiry), await this.client.core.pairing.updateMetadata({ topic: h6.pairingTopic, metadata: y9.peer.metadata }), this.client.events.emit("session_connect", { session: y9 }), this.events.emit(go("session_connect", h6.proposalId), { session: y9 }), this.pendingSessions.delete(h6.proposalId), this.deleteProposal(h6.proposalId, false), this.cleanupDuplicatePairings(y9), await this.sendResult({ id: t.id, topic: e, result: true, throwOnFailedPublish: true });
      } catch (r2) {
        await this.sendError({ id: s, topic: e, error: r2 }), this.client.logger.error(r2);
      }
    }), c3(this, "onSessionSettleResponse", async (e, t) => {
      const { id: s } = t;
      isJsonRpcResult(t) ? (await this.client.session.update(e, { acknowledged: true }), this.events.emit(go("session_approve", s), {})) : isJsonRpcError(t) && (await this.client.session.delete(e, de("USER_DISCONNECTED")), this.events.emit(go("session_approve", s), { error: t.error }));
    }), c3(this, "onSessionUpdateRequest", async (e, t) => {
      const { params: s, id: i3 } = t;
      try {
        const r2 = `${e}_session_update`, o3 = Zi.get(r2);
        if (o3 && this.isRequestOutOfSync(o3, i3)) {
          this.client.logger.warn(`Discarding out of sync request - ${i3}`), this.sendError({ id: i3, topic: e, error: de("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(v2({ topic: e }, s));
        try {
          Zi.set(r2, i3), await this.client.session.update(e, { namespaces: s.namespaces }), await this.sendResult({ id: i3, topic: e, result: true, throwOnFailedPublish: true });
        } catch (a2) {
          throw Zi.delete(r2), a2;
        }
        this.client.events.emit("session_update", { id: i3, topic: e, params: s });
      } catch (r2) {
        await this.sendError({ id: i3, topic: e, error: r2 }), this.client.logger.error(r2);
      }
    }), c3(this, "isRequestOutOfSync", (e, t) => t.toString().slice(0, -3) < e.toString().slice(0, -3)), c3(this, "onSessionUpdateResponse", (e, t) => {
      const { id: s } = t, i3 = go("session_update", s);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(go("session_update", s), {}) : isJsonRpcError(t) && this.events.emit(go("session_update", s), { error: t.error });
    }), c3(this, "onSessionExtendRequest", async (e, t) => {
      const { id: s } = t;
      try {
        this.isValidExtend({ topic: e }), await this.setExpiry(e, ho(Y2)), await this.sendResult({ id: s, topic: e, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_extend", { id: s, topic: e });
      } catch (i3) {
        await this.sendError({ id: s, topic: e, error: i3 }), this.client.logger.error(i3);
      }
    }), c3(this, "onSessionExtendResponse", (e, t) => {
      const { id: s } = t, i3 = go("session_extend", s);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(go("session_extend", s), {}) : isJsonRpcError(t) && this.events.emit(go("session_extend", s), { error: t.error });
    }), c3(this, "onSessionPingRequest", async (e, t) => {
      const { id: s } = t;
      try {
        this.isValidPing({ topic: e }), await this.sendResult({ id: s, topic: e, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s, topic: e });
      } catch (i3) {
        await this.sendError({ id: s, topic: e, error: i3 }), this.client.logger.error(i3);
      }
    }), c3(this, "onSessionPingResponse", (e, t) => {
      const { id: s } = t, i3 = go("session_ping", s);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      setTimeout(() => {
        isJsonRpcResult(t) ? this.events.emit(go("session_ping", s), {}) : isJsonRpcError(t) && this.events.emit(go("session_ping", s), { error: t.error });
      }, 500);
    }), c3(this, "onSessionDeleteRequest", async (e, t) => {
      const { id: s } = t;
      try {
        this.isValidDisconnect({ topic: e, reason: t.params }), Promise.all([new Promise((i3) => {
          this.client.core.relayer.once(T.publish, async () => {
            i3(await this.deleteSession({ topic: e, id: s }));
          });
        }), this.sendResult({ id: s, topic: e, result: true, throwOnFailedPublish: true }), this.cleanupPendingSentRequestsForTopic({ topic: e, error: de("USER_DISCONNECTED") })]).catch((i3) => this.client.logger.error(i3));
      } catch (i3) {
        this.client.logger.error(i3);
      }
    }), c3(this, "onSessionRequest", async (e) => {
      var t, s, i3;
      const { topic: r2, payload: o3, attestation: a2, encryptedId: l5, transportType: u3 } = e, { id: g3, params: h6 } = o3;
      try {
        await this.isValidRequest(v2({ topic: r2 }, h6));
        const d5 = this.client.session.get(r2), y9 = await this.getVerifyContext({ attestationId: a2, hash: si(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", h6, g3))), encryptedId: l5, metadata: d5.peer.metadata, transportType: u3 }), m3 = { id: g3, topic: r2, params: h6, verifyContext: y9 };
        await this.setPendingSessionRequest(m3), u3 === Q2.link_mode && (t = d5.peer.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp((s = d5.peer.metadata.redirect) == null ? void 0 : s.universal), (i3 = this.client.signConfig) != null && i3.disableRequestQueue ? this.emitSessionRequest(m3) : (this.addSessionRequestToSessionRequestQueue(m3), this.processSessionRequestQueue());
      } catch (d5) {
        await this.sendError({ id: g3, topic: r2, error: d5 }), this.client.logger.error(d5);
      }
    }), c3(this, "onSessionRequestResponse", (e, t) => {
      const { id: s } = t, i3 = go("session_request", s);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(go("session_request", s), { result: t.result }) : isJsonRpcError(t) && this.events.emit(go("session_request", s), { error: t.error });
    }), c3(this, "onSessionEventRequest", async (e, t) => {
      const { id: s, params: i3 } = t;
      try {
        const r2 = `${e}_session_event_${i3.event.name}`, o3 = Zi.get(r2);
        if (o3 && this.isRequestOutOfSync(o3, s)) {
          this.client.logger.info(`Discarding out of sync request - ${s}`);
          return;
        }
        this.isValidEmit(v2({ topic: e }, i3)), this.client.events.emit("session_event", { id: s, topic: e, params: i3 }), Zi.set(r2, s);
      } catch (r2) {
        await this.sendError({ id: s, topic: e, error: r2 }), this.client.logger.error(r2);
      }
    }), c3(this, "onSessionAuthenticateResponse", (e, t) => {
      const { id: s } = t;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: e, payload: t }), isJsonRpcResult(t) ? this.events.emit(go("session_request", s), { result: t.result }) : isJsonRpcError(t) && this.events.emit(go("session_request", s), { error: t.error });
    }), c3(this, "onSessionAuthenticateRequest", async (e) => {
      var t;
      const { topic: s, payload: i3, attestation: r2, encryptedId: o3, transportType: a2 } = e;
      try {
        const { requester: l5, authPayload: u3, expiryTimestamp: g3 } = i3.params, h6 = await this.getVerifyContext({ attestationId: r2, hash: si(JSON.stringify(i3)), encryptedId: o3, metadata: l5.metadata, transportType: a2 }), d5 = { requester: l5, pairingTopic: s, id: i3.id, authPayload: u3, verifyContext: h6, expiryTimestamp: g3 };
        await this.setAuthRequest(i3.id, { request: d5, pairingTopic: s, transportType: a2 }), a2 === Q2.link_mode && (t = l5.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp(l5.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s, params: i3.params, id: i3.id, verifyContext: h6 });
      } catch (l5) {
        this.client.logger.error(l5);
        const u3 = i3.params.requester.publicKey, g3 = await this.client.core.crypto.generateKeyPair(), h6 = this.getAppLinkIfEnabled(i3.params.requester.metadata, a2), d5 = { type: Ie, receiverPublicKey: u3, senderPublicKey: g3 };
        await this.sendError({ id: i3.id, topic: s, error: l5, encodeOpts: d5, rpcOpts: N2.wc_sessionAuthenticate.autoReject, appLink: h6 });
      }
    }), c3(this, "addSessionRequestToSessionRequestQueue", (e) => {
      this.sessionRequestQueue.queue.push(e);
    }), c3(this, "cleanupAfterResponse", (e) => {
      this.deletePendingSessionRequest(e.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = $2.idle, this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay));
    }), c3(this, "cleanupPendingSentRequestsForTopic", ({ topic: e, error: t }) => {
      const s = this.client.core.history.pending;
      s.length > 0 && s.filter((i3) => i3.topic === e && i3.request.method === "wc_sessionRequest").forEach((i3) => {
        const r2 = i3.request.id, o3 = go("session_request", r2);
        if (this.events.listenerCount(o3) === 0) throw new Error(`emitting ${o3} without any listeners`);
        this.events.emit(go("session_request", i3.request.id), { error: t });
      });
    }), c3(this, "processSessionRequestQueue", () => {
      if (this.sessionRequestQueue.state === $2.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e = this.sessionRequestQueue.queue[0];
      if (!e) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = $2.active, this.emitSessionRequest(e);
      } catch (t) {
        this.client.logger.error(t);
      }
    }), c3(this, "emitSessionRequest", (e) => {
      this.client.events.emit("session_request", e);
    }), c3(this, "onPairingCreated", (e) => {
      if (e.methods && this.expectedPairingMethodMap.set(e.topic, e.methods), e.active) return;
      const t = this.client.proposal.getAll().find((s) => s.pairingTopic === e.topic);
      t && this.onSessionProposeRequest({ topic: e.topic, payload: formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: t.requiredNamespaces, optionalNamespaces: t.optionalNamespaces, relays: t.relays, proposer: t.proposer, sessionProperties: t.sessionProperties }, t.id) });
    }), c3(this, "isValidConnect", async (e) => {
      if (!Di(e)) {
        const { message: a2 } = te("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e)}`);
        throw new Error(a2);
      }
      const { pairingTopic: t, requiredNamespaces: s, optionalNamespaces: i3, sessionProperties: r2, relays: o3 } = e;
      if (ae(t) || await this.isValidPairingTopic(t), !Ci(o3, true)) {
        const { message: a2 } = te("MISSING_OR_INVALID", `connect() relays: ${o3}`);
        throw new Error(a2);
      }
      !ae(s) && qe(s) !== 0 && this.validateNamespaces(s, "requiredNamespaces"), !ae(i3) && qe(i3) !== 0 && this.validateNamespaces(i3, "optionalNamespaces"), ae(r2) || this.validateSessionProps(r2, "sessionProperties");
    }), c3(this, "validateNamespaces", (e, t) => {
      const s = ji(e, "connect()", t);
      if (s) throw new Error(s.message);
    }), c3(this, "isValidApprove", async (e) => {
      if (!Di(e)) throw new Error(te("MISSING_OR_INVALID", `approve() params: ${e}`).message);
      const { id: t, namespaces: s, relayProtocol: i3, sessionProperties: r2 } = e;
      this.checkRecentlyDeleted(t), await this.isValidProposalId(t);
      const o3 = this.client.proposal.get(t), a2 = Ir(s, "approve()");
      if (a2) throw new Error(a2.message);
      const l5 = Nr(o3.requiredNamespaces, s, "approve()");
      if (l5) throw new Error(l5.message);
      if (!q(i3, true)) {
        const { message: u3 } = te("MISSING_OR_INVALID", `approve() relayProtocol: ${i3}`);
        throw new Error(u3);
      }
      ae(r2) || this.validateSessionProps(r2, "sessionProperties");
    }), c3(this, "isValidReject", async (e) => {
      if (!Di(e)) {
        const { message: i3 } = te("MISSING_OR_INVALID", `reject() params: ${e}`);
        throw new Error(i3);
      }
      const { id: t, reason: s } = e;
      if (this.checkRecentlyDeleted(t), await this.isValidProposalId(t), !Mi(s)) {
        const { message: i3 } = te("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s)}`);
        throw new Error(i3);
      }
    }), c3(this, "isValidSessionSettleRequest", (e) => {
      if (!Di(e)) {
        const { message: l5 } = te("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e}`);
        throw new Error(l5);
      }
      const { relay: t, controller: s, namespaces: i3, expiry: r2 } = e;
      if (!Ar(t)) {
        const { message: l5 } = te("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l5);
      }
      const o3 = Bi(s, "onSessionSettleRequest()");
      if (o3) throw new Error(o3.message);
      const a2 = Ir(i3, "onSessionSettleRequest()");
      if (a2) throw new Error(a2.message);
      if (po(r2)) {
        const { message: l5 } = te("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l5);
      }
    }), c3(this, "isValidUpdate", async (e) => {
      if (!Di(e)) {
        const { message: a2 } = te("MISSING_OR_INVALID", `update() params: ${e}`);
        throw new Error(a2);
      }
      const { topic: t, namespaces: s } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const i3 = this.client.session.get(t), r2 = Ir(s, "update()");
      if (r2) throw new Error(r2.message);
      const o3 = Nr(i3.requiredNamespaces, s, "update()");
      if (o3) throw new Error(o3.message);
    }), c3(this, "isValidExtend", async (e) => {
      if (!Di(e)) {
        const { message: s } = te("MISSING_OR_INVALID", `extend() params: ${e}`);
        throw new Error(s);
      }
      const { topic: t } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
    }), c3(this, "isValidRequest", async (e) => {
      if (!Di(e)) {
        const { message: a2 } = te("MISSING_OR_INVALID", `request() params: ${e}`);
        throw new Error(a2);
      }
      const { topic: t, request: s, chainId: i3, expiry: r2 } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const { namespaces: o3 } = this.client.session.get(t);
      if (!Fi(o3, i3)) {
        const { message: a2 } = te("MISSING_OR_INVALID", `request() chainId: ${i3}`);
        throw new Error(a2);
      }
      if (!Vi(s)) {
        const { message: a2 } = te("MISSING_OR_INVALID", `request() ${JSON.stringify(s)}`);
        throw new Error(a2);
      }
      if (!qi(o3, i3, s.method)) {
        const { message: a2 } = te("MISSING_OR_INVALID", `request() method: ${s.method}`);
        throw new Error(a2);
      }
      if (r2 && !Ji(r2, Ee3)) {
        const { message: a2 } = te("MISSING_OR_INVALID", `request() expiry: ${r2}. Expiry must be a number (in seconds) between ${Ee3.min} and ${Ee3.max}`);
        throw new Error(a2);
      }
    }), c3(this, "isValidRespond", async (e) => {
      var t;
      if (!Di(e)) {
        const { message: r2 } = te("MISSING_OR_INVALID", `respond() params: ${e}`);
        throw new Error(r2);
      }
      const { topic: s, response: i3 } = e;
      try {
        await this.isValidSessionTopic(s);
      } catch (r2) {
        throw (t = e == null ? void 0 : e.response) != null && t.id && this.cleanupAfterResponse(e), r2;
      }
      if (!Hi(i3)) {
        const { message: r2 } = te("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i3)}`);
        throw new Error(r2);
      }
    }), c3(this, "isValidPing", async (e) => {
      if (!Di(e)) {
        const { message: s } = te("MISSING_OR_INVALID", `ping() params: ${e}`);
        throw new Error(s);
      }
      const { topic: t } = e;
      await this.isValidSessionOrPairingTopic(t);
    }), c3(this, "isValidEmit", async (e) => {
      if (!Di(e)) {
        const { message: o3 } = te("MISSING_OR_INVALID", `emit() params: ${e}`);
        throw new Error(o3);
      }
      const { topic: t, event: s, chainId: i3 } = e;
      await this.isValidSessionTopic(t);
      const { namespaces: r2 } = this.client.session.get(t);
      if (!Fi(r2, i3)) {
        const { message: o3 } = te("MISSING_OR_INVALID", `emit() chainId: ${i3}`);
        throw new Error(o3);
      }
      if (!Ki(s)) {
        const { message: o3 } = te("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
        throw new Error(o3);
      }
      if (!Gi(r2, i3, s.name)) {
        const { message: o3 } = te("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
        throw new Error(o3);
      }
    }), c3(this, "isValidDisconnect", async (e) => {
      if (!Di(e)) {
        const { message: s } = te("MISSING_OR_INVALID", `disconnect() params: ${e}`);
        throw new Error(s);
      }
      const { topic: t } = e;
      await this.isValidSessionOrPairingTopic(t);
    }), c3(this, "isValidAuthenticate", (e) => {
      const { chains: t, uri: s, domain: i3, nonce: r2 } = e;
      if (!Array.isArray(t) || t.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!q(s, false)) throw new Error("uri is required parameter");
      if (!q(i3, false)) throw new Error("domain is required parameter");
      if (!q(r2, false)) throw new Error("nonce is required parameter");
      if ([...new Set(t.map((a2) => Ye(a2).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: o3 } = Ye(t[0]);
      if (o3 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }), c3(this, "getVerifyContext", async (e) => {
      const { attestationId: t, hash: s, encryptedId: i3, metadata: r2, transportType: o3 } = e, a2 = { verified: { verifyUrl: r2.verifyUrl || le2, validation: "UNKNOWN", origin: r2.url || "" } };
      try {
        if (o3 === Q2.link_mode) {
          const u3 = this.getAppLinkIfEnabled(r2, o3);
          return a2.verified.validation = u3 && new URL(u3).origin === new URL(r2.url).origin ? "VALID" : "INVALID", a2;
        }
        const l5 = await this.client.core.verify.resolve({ attestationId: t, hash: s, encryptedId: i3, verifyUrl: r2.verifyUrl });
        l5 && (a2.verified.origin = l5.origin, a2.verified.isScam = l5.isScam, a2.verified.validation = l5.origin === new URL(r2.url).origin ? "VALID" : "INVALID");
      } catch (l5) {
        this.client.logger.warn(l5);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a2)}`), a2;
    }), c3(this, "validateSessionProps", (e, t) => {
      Object.values(e).forEach((s) => {
        if (!q(s, false)) {
          const { message: i3 } = te("MISSING_OR_INVALID", `${t} must be in Record<string, string> format. Received: ${JSON.stringify(s)}`);
          throw new Error(i3);
        }
      });
    }), c3(this, "getPendingAuthRequest", (e) => {
      const t = this.client.auth.requests.get(e);
      return typeof t == "object" ? t : void 0;
    }), c3(this, "addToRecentlyDeleted", (e, t) => {
      if (this.recentlyDeletedMap.set(e, t), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s = 0;
        const i3 = this.recentlyDeletedLimit / 2;
        for (const r2 of this.recentlyDeletedMap.keys()) {
          if (s++ >= i3) break;
          this.recentlyDeletedMap.delete(r2);
        }
      }
    }), c3(this, "checkRecentlyDeleted", (e) => {
      const t = this.recentlyDeletedMap.get(e);
      if (t) {
        const { message: s } = te("MISSING_OR_INVALID", `Record was recently deleted - ${t}: ${e}`);
        throw new Error(s);
      }
    }), c3(this, "isLinkModeEnabled", (e, t) => {
      var s, i3, r2, o3, a2, l5, u3, g3, h6;
      return !e || t !== Q2.link_mode ? false : ((i3 = (s = this.client.metadata) == null ? void 0 : s.redirect) == null ? void 0 : i3.linkMode) === true && ((o3 = (r2 = this.client.metadata) == null ? void 0 : r2.redirect) == null ? void 0 : o3.universal) !== void 0 && ((l5 = (a2 = this.client.metadata) == null ? void 0 : a2.redirect) == null ? void 0 : l5.universal) !== "" && ((u3 = e == null ? void 0 : e.redirect) == null ? void 0 : u3.universal) !== void 0 && ((g3 = e == null ? void 0 : e.redirect) == null ? void 0 : g3.universal) !== "" && ((h6 = e == null ? void 0 : e.redirect) == null ? void 0 : h6.linkMode) === true && this.client.core.linkModeSupportedApps.includes(e.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }), c3(this, "getAppLinkIfEnabled", (e, t) => {
      var s;
      return this.isLinkModeEnabled(e, t) ? (s = e == null ? void 0 : e.redirect) == null ? void 0 : s.universal : void 0;
    }), c3(this, "handleLinkModeMessage", ({ url: e }) => {
      if (!e || !e.includes("wc_ev") || !e.includes("topic")) return;
      const t = bo(e, "topic") || "", s = decodeURIComponent(bo(e, "wc_ev") || ""), i3 = this.client.session.keys.includes(t);
      i3 && this.client.session.update(t, { transportType: Q2.link_mode }), this.client.core.dispatchEnvelope({ topic: t, message: s, sessionExists: i3 });
    }), c3(this, "registerLinkModeListeners", async () => {
      var e;
      if (Eo() || ne() && (e = this.client.metadata.redirect) != null && e.linkMode) {
        const t = global == null ? void 0 : global.Linking;
        if (typeof t < "u") {
          t.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s = await t.getInitialURL();
          s && setTimeout(() => {
            this.handleLinkModeMessage({ url: s });
          }, 50);
        }
      }
    }), c3(this, "shouldSetTVF", (e, t) => {
      if (!t || e !== "wc_sessionRequest") return false;
      const { request: s } = t;
      return Object.keys(Ke3).includes(s.method);
    }), c3(this, "getTVFParams", (e, t, s) => {
      var i3, r2;
      try {
        const o3 = t.request.method, a2 = this.extractTxHashesFromResult(o3, s);
        return x4(v2({ correlationId: e, rpcMethods: [o3], chainId: t.chainId }, this.isValidContractData(t.request.params) && { contractAddresses: [(r2 = (i3 = t.request.params) == null ? void 0 : i3[0]) == null ? void 0 : r2.to] }), { txHashes: a2 });
      } catch (o3) {
        this.client.logger.warn("Error getting TVF params", o3);
      }
      return {};
    }), c3(this, "isValidContractData", (e) => {
      var t;
      if (!e) return false;
      try {
        const s = (e == null ? void 0 : e.data) || ((t = e == null ? void 0 : e[0]) == null ? void 0 : t.data);
        if (!s.startsWith("0x")) return false;
        const i3 = s.slice(2);
        return /^[0-9a-fA-F]*$/.test(i3) ? i3.length % 2 === 0 : false;
      } catch {
      }
      return false;
    }), c3(this, "extractTxHashesFromResult", (e, t) => {
      try {
        const s = Ke3[e];
        if (typeof t == "string") return [t];
        const i3 = t[s.key];
        if ($e(i3)) return i3;
        if (typeof i3 == "string") return [i3];
      } catch (s) {
        this.client.logger.warn("Error extracting tx hashes from result", s);
      }
      return [];
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: n3 } = te("NOT_INITIALIZED", this.name);
      throw new Error(n3);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(T.message, (n3) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(n3) : this.onRelayMessage(n3);
    });
  }
  async onRelayMessage(n3) {
    const { topic: e, message: t, attestation: s, transportType: i3 } = n3, { publicKey: r2 } = this.client.auth.authKeys.keys.includes(le3) ? this.client.auth.authKeys.get(le3) : { responseTopic: void 0, publicKey: void 0 }, o3 = await this.client.core.crypto.decode(e, t, { receiverPublicKey: r2, encoding: i3 === Q2.link_mode ? Qs : At });
    try {
      isJsonRpcRequest(o3) ? (this.client.core.history.set(e, o3), this.onRelayEventRequest({ topic: e, payload: o3, attestation: s, transportType: i3, encryptedId: si(t) })) : isJsonRpcResponse(o3) ? (await this.client.core.history.resolve(o3), await this.onRelayEventResponse({ topic: e, payload: o3, transportType: i3 }), this.client.core.history.delete(e, o3.id)) : this.onRelayEventUnknownPayload({ topic: e, payload: o3, transportType: i3 });
    } catch (a2) {
      this.client.logger.error(a2);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(M4.expired, async (n3) => {
      const { topic: e, id: t } = lo(n3.target);
      if (t && this.client.pendingRequest.keys.includes(t)) return await this.deletePendingSessionRequest(t, te("EXPIRED"), true);
      if (t && this.client.auth.requests.keys.includes(t)) return await this.deletePendingAuthRequest(t, te("EXPIRED"), true);
      e ? this.client.session.keys.includes(e) && (await this.deleteSession({ topic: e, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: e })) : t && (await this.deleteProposal(t, true), this.client.events.emit("proposal_expire", { id: t }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(se2.create, (n3) => this.onPairingCreated(n3)), this.client.core.pairing.events.on(se2.delete, (n3) => {
      this.addToRecentlyDeleted(n3.topic, "pairing");
    });
  }
  isValidPairingTopic(n3) {
    if (!q(n3, false)) {
      const { message: e } = te("MISSING_OR_INVALID", `pairing topic should be a string: ${n3}`);
      throw new Error(e);
    }
    if (!this.client.core.pairing.pairings.keys.includes(n3)) {
      const { message: e } = te("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n3}`);
      throw new Error(e);
    }
    if (po(this.client.core.pairing.pairings.get(n3).expiry)) {
      const { message: e } = te("EXPIRED", `pairing topic: ${n3}`);
      throw new Error(e);
    }
  }
  async isValidSessionTopic(n3) {
    if (!q(n3, false)) {
      const { message: e } = te("MISSING_OR_INVALID", `session topic should be a string: ${n3}`);
      throw new Error(e);
    }
    if (this.checkRecentlyDeleted(n3), !this.client.session.keys.includes(n3)) {
      const { message: e } = te("NO_MATCHING_KEY", `session topic doesn't exist: ${n3}`);
      throw new Error(e);
    }
    if (po(this.client.session.get(n3).expiry)) {
      await this.deleteSession({ topic: n3 });
      const { message: e } = te("EXPIRED", `session topic: ${n3}`);
      throw new Error(e);
    }
    if (!this.client.core.crypto.keychain.has(n3)) {
      const { message: e } = te("MISSING_OR_INVALID", `session topic does not exist in keychain: ${n3}`);
      throw await this.deleteSession({ topic: n3 }), new Error(e);
    }
  }
  async isValidSessionOrPairingTopic(n3) {
    if (this.checkRecentlyDeleted(n3), this.client.session.keys.includes(n3)) await this.isValidSessionTopic(n3);
    else if (this.client.core.pairing.pairings.keys.includes(n3)) this.isValidPairingTopic(n3);
    else if (q(n3, false)) {
      const { message: e } = te("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${n3}`);
      throw new Error(e);
    } else {
      const { message: e } = te("MISSING_OR_INVALID", `session or pairing topic should be a string: ${n3}`);
      throw new Error(e);
    }
  }
  async isValidProposalId(n3) {
    if (!ki(n3)) {
      const { message: e } = te("MISSING_OR_INVALID", `proposal id should be a number: ${n3}`);
      throw new Error(e);
    }
    if (!this.client.proposal.keys.includes(n3)) {
      const { message: e } = te("NO_MATCHING_KEY", `proposal id doesn't exist: ${n3}`);
      throw new Error(e);
    }
    if (po(this.client.proposal.get(n3).expiryTimestamp)) {
      await this.deleteProposal(n3);
      const { message: e } = te("EXPIRED", `proposal id: ${n3}`);
      throw new Error(e);
    }
  }
};
var Ns2 = class extends Ci2 {
  constructor(n3, e) {
    super(n3, e, pt2, me3), this.core = n3, this.logger = e;
  }
};
var Rt3 = class extends Ci2 {
  constructor(n3, e) {
    super(n3, e, ht2, me3), this.core = n3, this.logger = e;
  }
};
var Ps2 = class extends Ci2 {
  constructor(n3, e) {
    super(n3, e, ut2, me3, (t) => t.id), this.core = n3, this.logger = e;
  }
};
var Os2 = class extends Ci2 {
  constructor(n3, e) {
    super(n3, e, mt3, ce2, () => le3), this.core = n3, this.logger = e;
  }
};
var bs2 = class extends Ci2 {
  constructor(n3, e) {
    super(n3, e, _t3, ce2), this.core = n3, this.logger = e;
  }
};
var As2 = class extends Ci2 {
  constructor(n3, e) {
    super(n3, e, Et3, ce2, (t) => t.id), this.core = n3, this.logger = e;
  }
};
var Cs2 = Object.defineProperty;
var xs2 = (S7, n3, e) => n3 in S7 ? Cs2(S7, n3, { enumerable: true, configurable: true, writable: true, value: e }) : S7[n3] = e;
var Ge3 = (S7, n3, e) => xs2(S7, typeof n3 != "symbol" ? n3 + "" : n3, e);
var Vs2 = class {
  constructor(n3, e) {
    this.core = n3, this.logger = e, Ge3(this, "authKeys"), Ge3(this, "pairingTopics"), Ge3(this, "requests"), this.authKeys = new Os2(this.core, this.logger), this.pairingTopics = new bs2(this.core, this.logger), this.requests = new As2(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var Ds2 = Object.defineProperty;
var Ls3 = (S7, n3, e) => n3 in S7 ? Ds2(S7, n3, { enumerable: true, configurable: true, writable: true, value: e }) : S7[n3] = e;
var _3 = (S7, n3, e) => Ls3(S7, typeof n3 != "symbol" ? n3 + "" : n3, e);
var Se2 = class _Se extends J4 {
  constructor(n3) {
    super(n3), _3(this, "protocol", De2), _3(this, "version", Le3), _3(this, "name", _e3.name), _3(this, "metadata"), _3(this, "core"), _3(this, "logger"), _3(this, "events", new import_events6.EventEmitter()), _3(this, "engine"), _3(this, "session"), _3(this, "proposal"), _3(this, "pendingRequest"), _3(this, "auth"), _3(this, "signConfig"), _3(this, "on", (t, s) => this.events.on(t, s)), _3(this, "once", (t, s) => this.events.once(t, s)), _3(this, "off", (t, s) => this.events.off(t, s)), _3(this, "removeListener", (t, s) => this.events.removeListener(t, s)), _3(this, "removeAllListeners", (t) => this.events.removeAllListeners(t)), _3(this, "connect", async (t) => {
      try {
        return await this.engine.connect(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), _3(this, "pair", async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), _3(this, "approve", async (t) => {
      try {
        return await this.engine.approve(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), _3(this, "reject", async (t) => {
      try {
        return await this.engine.reject(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), _3(this, "update", async (t) => {
      try {
        return await this.engine.update(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), _3(this, "extend", async (t) => {
      try {
        return await this.engine.extend(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), _3(this, "request", async (t) => {
      try {
        return await this.engine.request(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), _3(this, "respond", async (t) => {
      try {
        return await this.engine.respond(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), _3(this, "ping", async (t) => {
      try {
        return await this.engine.ping(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), _3(this, "emit", async (t) => {
      try {
        return await this.engine.emit(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), _3(this, "disconnect", async (t) => {
      try {
        return await this.engine.disconnect(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), _3(this, "find", (t) => {
      try {
        return this.engine.find(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), _3(this, "getPendingSessionRequests", () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }), _3(this, "authenticate", async (t, s) => {
      try {
        return await this.engine.authenticate(t, s);
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }), _3(this, "formatAuthMessage", (t) => {
      try {
        return this.engine.formatAuthMessage(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), _3(this, "approveSessionAuthenticate", async (t) => {
      try {
        return await this.engine.approveSessionAuthenticate(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), _3(this, "rejectSessionAuthenticate", async (t) => {
      try {
        return await this.engine.rejectSessionAuthenticate(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), this.name = (n3 == null ? void 0 : n3.name) || _e3.name, this.metadata = (n3 == null ? void 0 : n3.metadata) || Yr(), this.signConfig = n3 == null ? void 0 : n3.signConfig;
    const e = typeof (n3 == null ? void 0 : n3.logger) < "u" && typeof (n3 == null ? void 0 : n3.logger) != "string" ? n3.logger : (0, import_pino.default)(k({ level: (n3 == null ? void 0 : n3.logger) || _e3.logger }));
    this.core = (n3 == null ? void 0 : n3.core) || new co2(n3), this.logger = E(e, this.name), this.session = new Rt3(this.core, this.logger), this.proposal = new Ns2(this.core, this.logger), this.pendingRequest = new Ps2(this.core, this.logger), this.engine = new Ts2(this), this.auth = new Vs2(this.core, this.logger);
  }
  static async init(n3) {
    const e = new _Se(n3);
    return await e.initialize(), e;
  }
  get context() {
    return y(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), setTimeout(() => {
        this.engine.processRelayMessageCache();
      }, (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND));
    } catch (n3) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(n3.message), n3;
    }
  }
};

// node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_events7 = __toESM(require_events());
var be2 = "error";
var _t4 = "wss://relay.walletconnect.org";
var Ct3 = "wc";
var It3 = "universal_provider";
var $e4 = `${Ct3}@2:${It3}:`;
var ye2 = "https://rpc.walletconnect.org/v1/";
var w = "generic";
var Ot3 = `${ye2}bundler`;
var f7 = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
var G2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function At3() {
  this.__data__ = [], this.size = 0;
}
var jt3 = At3;
function Ht2(r2, e) {
  return r2 === e || r2 !== r2 && e !== e;
}
var z4 = Ht2;
var Et4 = z4;
function St4(r2, e) {
  for (var t = r2.length; t--; ) if (Et4(r2[t][0], e)) return t;
  return -1;
}
var k4 = St4;
var Nt3 = k4;
var Tt3 = Array.prototype;
var Dt = Tt3.splice;
function qt2(r2) {
  var e = this.__data__, t = Nt3(e, r2);
  if (t < 0) return false;
  var i3 = e.length - 1;
  return t == i3 ? e.pop() : Dt.call(e, t, 1), --this.size, true;
}
var Rt4 = qt2;
var xt3 = k4;
function Lt3(r2) {
  var e = this.__data__, t = xt3(e, r2);
  return t < 0 ? void 0 : e[t][1];
}
var Ut3 = Lt3;
var Ft3 = k4;
function Mt3(r2) {
  return Ft3(this.__data__, r2) > -1;
}
var Gt3 = Mt3;
var zt3 = k4;
function kt3(r2, e) {
  var t = this.__data__, i3 = zt3(t, r2);
  return i3 < 0 ? (++this.size, t.push([r2, e])) : t[i3][1] = e, this;
}
var Bt3 = kt3;
var Vt2 = jt3;
var Jt3 = Rt4;
var Kt2 = Ut3;
var Wt3 = Gt3;
var Xt2 = Bt3;
function _4(r2) {
  var e = -1, t = r2 == null ? 0 : r2.length;
  for (this.clear(); ++e < t; ) {
    var i3 = r2[e];
    this.set(i3[0], i3[1]);
  }
}
_4.prototype.clear = Vt2, _4.prototype.delete = Jt3, _4.prototype.get = Kt2, _4.prototype.has = Wt3, _4.prototype.set = Xt2;
var B2 = _4;
var Yt3 = B2;
function Zt2() {
  this.__data__ = new Yt3(), this.size = 0;
}
var Qt2 = Zt2;
function er3(r2) {
  var e = this.__data__, t = e.delete(r2);
  return this.size = e.size, t;
}
var tr3 = er3;
function rr3(r2) {
  return this.__data__.get(r2);
}
var ir3 = rr3;
function sr3(r2) {
  return this.__data__.has(r2);
}
var nr3 = sr3;
var ar3 = typeof G2 == "object" && G2 && G2.Object === Object && G2;
var we3 = ar3;
var or3 = we3;
var cr3 = typeof self == "object" && self && self.Object === Object && self;
var hr3 = or3 || cr3 || Function("return this")();
var C3 = hr3;
var pr3 = C3;
var ur2 = pr3.Symbol;
var _e4 = ur2;
var Ce2 = _e4;
var Ie3 = Object.prototype;
var lr3 = Ie3.hasOwnProperty;
var dr3 = Ie3.toString;
var F3 = Ce2 ? Ce2.toStringTag : void 0;
function vr3(r2) {
  var e = lr3.call(r2, F3), t = r2[F3];
  try {
    r2[F3] = void 0;
    var i3 = true;
  } catch {
  }
  var s = dr3.call(r2);
  return i3 && (e ? r2[F3] = t : delete r2[F3]), s;
}
var fr2 = vr3;
var mr3 = Object.prototype;
var gr3 = mr3.toString;
function Pr2(r2) {
  return gr3.call(r2);
}
var br3 = Pr2;
var Oe4 = _e4;
var $r3 = fr2;
var yr3 = br3;
var wr3 = "[object Null]";
var _r3 = "[object Undefined]";
var Ae3 = Oe4 ? Oe4.toStringTag : void 0;
function Cr2(r2) {
  return r2 == null ? r2 === void 0 ? _r3 : wr3 : Ae3 && Ae3 in Object(r2) ? $r3(r2) : yr3(r2);
}
var V4 = Cr2;
function Ir3(r2) {
  var e = typeof r2;
  return r2 != null && (e == "object" || e == "function");
}
var $3 = Ir3;
var Or3 = V4;
var Ar3 = $3;
var jr2 = "[object AsyncFunction]";
var Hr2 = "[object Function]";
var Er3 = "[object GeneratorFunction]";
var Sr3 = "[object Proxy]";
function Nr3(r2) {
  if (!Ar3(r2)) return false;
  var e = Or3(r2);
  return e == Hr2 || e == Er3 || e == jr2 || e == Sr3;
}
var te3 = Nr3;
var Tr3 = C3;
var Dr2 = Tr3["__core-js_shared__"];
var qr2 = Dr2;
var re3 = qr2;
var je3 = function() {
  var r2 = /[^.]+$/.exec(re3 && re3.keys && re3.keys.IE_PROTO || "");
  return r2 ? "Symbol(src)_1." + r2 : "";
}();
function Rr3(r2) {
  return !!je3 && je3 in r2;
}
var xr3 = Rr3;
var Lr3 = Function.prototype;
var Ur3 = Lr3.toString;
function Fr2(r2) {
  if (r2 != null) {
    try {
      return Ur3.call(r2);
    } catch {
    }
    try {
      return r2 + "";
    } catch {
    }
  }
  return "";
}
var Mr2 = Fr2;
var Gr2 = te3;
var zr3 = xr3;
var kr3 = $3;
var Br3 = Mr2;
var Vr2 = /[\\^$.*+?()[\]{}|]/g;
var Jr3 = /^\[object .+?Constructor\]$/;
var Kr3 = Function.prototype;
var Wr3 = Object.prototype;
var Xr2 = Kr3.toString;
var Yr3 = Wr3.hasOwnProperty;
var Zr3 = RegExp("^" + Xr2.call(Yr3).replace(Vr2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function Qr2(r2) {
  if (!kr3(r2) || zr3(r2)) return false;
  var e = Gr2(r2) ? Zr3 : Jr3;
  return e.test(Br3(r2));
}
var ei3 = Qr2;
function ti3(r2, e) {
  return r2 == null ? void 0 : r2[e];
}
var ri3 = ti3;
var ii3 = ei3;
var si3 = ri3;
function ni3(r2, e) {
  var t = si3(r2, e);
  return ii3(t) ? t : void 0;
}
var ie3 = ni3;
var ai3 = ie3;
var oi3 = C3;
var ci3 = ai3(oi3, "Map");
var He2 = ci3;
var hi3 = ie3;
var pi3 = hi3(Object, "create");
var J5 = pi3;
var Ee4 = J5;
function ui3() {
  this.__data__ = Ee4 ? Ee4(null) : {}, this.size = 0;
}
var li3 = ui3;
function di3(r2) {
  var e = this.has(r2) && delete this.__data__[r2];
  return this.size -= e ? 1 : 0, e;
}
var vi2 = di3;
var fi3 = J5;
var mi3 = "__lodash_hash_undefined__";
var gi3 = Object.prototype;
var Pi4 = gi3.hasOwnProperty;
function bi3(r2) {
  var e = this.__data__;
  if (fi3) {
    var t = e[r2];
    return t === mi3 ? void 0 : t;
  }
  return Pi4.call(e, r2) ? e[r2] : void 0;
}
var $i3 = bi3;
var yi3 = J5;
var wi3 = Object.prototype;
var _i2 = wi3.hasOwnProperty;
function Ci3(r2) {
  var e = this.__data__;
  return yi3 ? e[r2] !== void 0 : _i2.call(e, r2);
}
var Ii2 = Ci3;
var Oi2 = J5;
var Ai2 = "__lodash_hash_undefined__";
function ji2(r2, e) {
  var t = this.__data__;
  return this.size += this.has(r2) ? 0 : 1, t[r2] = Oi2 && e === void 0 ? Ai2 : e, this;
}
var Hi2 = ji2;
var Ei3 = li3;
var Si2 = vi2;
var Ni2 = $i3;
var Ti3 = Ii2;
var Di3 = Hi2;
function I3(r2) {
  var e = -1, t = r2 == null ? 0 : r2.length;
  for (this.clear(); ++e < t; ) {
    var i3 = r2[e];
    this.set(i3[0], i3[1]);
  }
}
I3.prototype.clear = Ei3, I3.prototype.delete = Si2, I3.prototype.get = Ni2, I3.prototype.has = Ti3, I3.prototype.set = Di3;
var qi2 = I3;
var Se3 = qi2;
var Ri3 = B2;
var xi2 = He2;
function Li3() {
  this.size = 0, this.__data__ = { hash: new Se3(), map: new (xi2 || Ri3)(), string: new Se3() };
}
var Ui = Li3;
function Fi2(r2) {
  var e = typeof r2;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? r2 !== "__proto__" : r2 === null;
}
var Mi2 = Fi2;
var Gi2 = Mi2;
function zi3(r2, e) {
  var t = r2.__data__;
  return Gi2(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
}
var K3 = zi3;
var ki3 = K3;
function Bi2(r2) {
  var e = ki3(this, r2).delete(r2);
  return this.size -= e ? 1 : 0, e;
}
var Vi2 = Bi2;
var Ji2 = K3;
function Ki2(r2) {
  return Ji2(this, r2).get(r2);
}
var Wi2 = Ki2;
var Xi2 = K3;
function Yi2(r2) {
  return Xi2(this, r2).has(r2);
}
var Zi2 = Yi2;
var Qi2 = K3;
function es2(r2, e) {
  var t = Qi2(this, r2), i3 = t.size;
  return t.set(r2, e), this.size += t.size == i3 ? 0 : 1, this;
}
var ts2 = es2;
var rs2 = Ui;
var is2 = Vi2;
var ss2 = Wi2;
var ns2 = Zi2;
var as2 = ts2;
function O4(r2) {
  var e = -1, t = r2 == null ? 0 : r2.length;
  for (this.clear(); ++e < t; ) {
    var i3 = r2[e];
    this.set(i3[0], i3[1]);
  }
}
O4.prototype.clear = rs2, O4.prototype.delete = is2, O4.prototype.get = ss2, O4.prototype.has = ns2, O4.prototype.set = as2;
var os2 = O4;
var cs3 = B2;
var hs2 = He2;
var ps2 = os2;
var us2 = 200;
function ls3(r2, e) {
  var t = this.__data__;
  if (t instanceof cs3) {
    var i3 = t.__data__;
    if (!hs2 || i3.length < us2 - 1) return i3.push([r2, e]), this.size = ++t.size, this;
    t = this.__data__ = new ps2(i3);
  }
  return t.set(r2, e), this.size = t.size, this;
}
var ds2 = ls3;
var vs3 = B2;
var fs3 = Qt2;
var ms2 = tr3;
var gs2 = ir3;
var Ps3 = nr3;
var bs3 = ds2;
function A3(r2) {
  var e = this.__data__ = new vs3(r2);
  this.size = e.size;
}
A3.prototype.clear = fs3, A3.prototype.delete = ms2, A3.prototype.get = gs2, A3.prototype.has = Ps3, A3.prototype.set = bs3;
var $s2 = A3;
var ys2 = ie3;
var ws2 = function() {
  try {
    var r2 = ys2(Object, "defineProperty");
    return r2({}, "", {}), r2;
  } catch {
  }
}();
var Ne3 = ws2;
var Te2 = Ne3;
function _s2(r2, e, t) {
  e == "__proto__" && Te2 ? Te2(r2, e, { configurable: true, enumerable: true, value: t, writable: true }) : r2[e] = t;
}
var se3 = _s2;
var Cs3 = se3;
var Is3 = z4;
function Os3(r2, e, t) {
  (t !== void 0 && !Is3(r2[e], t) || t === void 0 && !(e in r2)) && Cs3(r2, e, t);
}
var De3 = Os3;
function As3(r2) {
  return function(e, t, i3) {
    for (var s = -1, n3 = Object(e), a2 = i3(e), o3 = a2.length; o3--; ) {
      var c6 = a2[r2 ? o3 : ++s];
      if (t(n3[c6], c6, n3) === false) break;
    }
    return e;
  };
}
var js3 = As3;
var Hs3 = js3;
var Es2 = Hs3();
var Ss2 = Es2;
var ne2 = { exports: {} };
(function(r2, e) {
  var t = C3, i3 = e && !e.nodeType && e, s = i3 && true && r2 && !r2.nodeType && r2, n3 = s && s.exports === i3, a2 = n3 ? t.Buffer : void 0, o3 = a2 ? a2.allocUnsafe : void 0;
  function c6(u3, l5) {
    if (l5) return u3.slice();
    var P6 = u3.length, d5 = o3 ? o3(P6) : new u3.constructor(P6);
    return u3.copy(d5), d5;
  }
  r2.exports = c6;
})(ne2, ne2.exports);
var Ns3 = C3;
var Ts3 = Ns3.Uint8Array;
var Ds3 = Ts3;
var qe3 = Ds3;
function qs4(r2) {
  var e = new r2.constructor(r2.byteLength);
  return new qe3(e).set(new qe3(r2)), e;
}
var Rs3 = qs4;
var xs3 = Rs3;
function Ls4(r2, e) {
  var t = e ? xs3(r2.buffer) : r2.buffer;
  return new r2.constructor(t, r2.byteOffset, r2.length);
}
var Us2 = Ls4;
function Fs2(r2, e) {
  var t = -1, i3 = r2.length;
  for (e || (e = Array(i3)); ++t < i3; ) e[t] = r2[t];
  return e;
}
var Ms2 = Fs2;
var Gs3 = $3;
var Re2 = Object.create;
var zs2 = /* @__PURE__ */ function() {
  function r2() {
  }
  return function(e) {
    if (!Gs3(e)) return {};
    if (Re2) return Re2(e);
    r2.prototype = e;
    var t = new r2();
    return r2.prototype = void 0, t;
  };
}();
var ks3 = zs2;
function Bs2(r2, e) {
  return function(t) {
    return r2(e(t));
  };
}
var Vs3 = Bs2;
var Js3 = Vs3;
var Ks2 = Js3(Object.getPrototypeOf, Object);
var xe3 = Ks2;
var Ws3 = Object.prototype;
function Xs3(r2) {
  var e = r2 && r2.constructor, t = typeof e == "function" && e.prototype || Ws3;
  return r2 === t;
}
var Le4 = Xs3;
var Ys3 = ks3;
var Zs3 = xe3;
var Qs3 = Le4;
function en3(r2) {
  return typeof r2.constructor == "function" && !Qs3(r2) ? Ys3(Zs3(r2)) : {};
}
var tn3 = en3;
function rn3(r2) {
  return r2 != null && typeof r2 == "object";
}
var M5 = rn3;
var sn4 = V4;
var nn3 = M5;
var an3 = "[object Arguments]";
function on3(r2) {
  return nn3(r2) && sn4(r2) == an3;
}
var cn3 = on3;
var Ue4 = cn3;
var hn3 = M5;
var Fe3 = Object.prototype;
var pn3 = Fe3.hasOwnProperty;
var un3 = Fe3.propertyIsEnumerable;
var ln3 = Ue4(/* @__PURE__ */ function() {
  return arguments;
}()) ? Ue4 : function(r2) {
  return hn3(r2) && pn3.call(r2, "callee") && !un3.call(r2, "callee");
};
var Me4 = ln3;
var dn3 = Array.isArray;
var Ge4 = dn3;
var vn3 = 9007199254740991;
function fn3(r2) {
  return typeof r2 == "number" && r2 > -1 && r2 % 1 == 0 && r2 <= vn3;
}
var ze3 = fn3;
var mn3 = te3;
var gn3 = ze3;
function Pn2(r2) {
  return r2 != null && gn3(r2.length) && !mn3(r2);
}
var ae2 = Pn2;
var bn3 = ae2;
var $n2 = M5;
function yn3(r2) {
  return $n2(r2) && bn3(r2);
}
var wn3 = yn3;
var W = { exports: {} };
function _n3() {
  return false;
}
var Cn3 = _n3;
(function(r2, e) {
  var t = C3, i3 = Cn3, s = e && !e.nodeType && e, n3 = s && true && r2 && !r2.nodeType && r2, a2 = n3 && n3.exports === s, o3 = a2 ? t.Buffer : void 0, c6 = o3 ? o3.isBuffer : void 0, u3 = c6 || i3;
  r2.exports = u3;
})(W, W.exports);
var In3 = V4;
var On3 = xe3;
var An2 = M5;
var jn3 = "[object Object]";
var Hn3 = Function.prototype;
var En3 = Object.prototype;
var ke4 = Hn3.toString;
var Sn2 = En3.hasOwnProperty;
var Nn2 = ke4.call(Object);
function Tn3(r2) {
  if (!An2(r2) || In3(r2) != jn3) return false;
  var e = On3(r2);
  if (e === null) return true;
  var t = Sn2.call(e, "constructor") && e.constructor;
  return typeof t == "function" && t instanceof t && ke4.call(t) == Nn2;
}
var Dn3 = Tn3;
var qn3 = V4;
var Rn3 = ze3;
var xn3 = M5;
var Ln3 = "[object Arguments]";
var Un3 = "[object Array]";
var Fn3 = "[object Boolean]";
var Mn3 = "[object Date]";
var Gn3 = "[object Error]";
var zn3 = "[object Function]";
var kn3 = "[object Map]";
var Bn3 = "[object Number]";
var Vn3 = "[object Object]";
var Jn3 = "[object RegExp]";
var Kn3 = "[object Set]";
var Wn3 = "[object String]";
var Xn3 = "[object WeakMap]";
var Yn3 = "[object ArrayBuffer]";
var Zn3 = "[object DataView]";
var Qn3 = "[object Float32Array]";
var ea = "[object Float64Array]";
var ta = "[object Int8Array]";
var ra = "[object Int16Array]";
var ia = "[object Int32Array]";
var sa = "[object Uint8Array]";
var na = "[object Uint8ClampedArray]";
var aa = "[object Uint16Array]";
var oa = "[object Uint32Array]";
var p3 = {};
p3[Qn3] = p3[ea] = p3[ta] = p3[ra] = p3[ia] = p3[sa] = p3[na] = p3[aa] = p3[oa] = true, p3[Ln3] = p3[Un3] = p3[Yn3] = p3[Fn3] = p3[Zn3] = p3[Mn3] = p3[Gn3] = p3[zn3] = p3[kn3] = p3[Bn3] = p3[Vn3] = p3[Jn3] = p3[Kn3] = p3[Wn3] = p3[Xn3] = false;
function ca(r2) {
  return xn3(r2) && Rn3(r2.length) && !!p3[qn3(r2)];
}
var ha = ca;
function pa(r2) {
  return function(e) {
    return r2(e);
  };
}
var ua = pa;
var oe2 = { exports: {} };
(function(r2, e) {
  var t = we3, i3 = e && !e.nodeType && e, s = i3 && true && r2 && !r2.nodeType && r2, n3 = s && s.exports === i3, a2 = n3 && t.process, o3 = function() {
    try {
      var c6 = s && s.require && s.require("util").types;
      return c6 || a2 && a2.binding && a2.binding("util");
    } catch {
    }
  }();
  r2.exports = o3;
})(oe2, oe2.exports);
var la = ha;
var da = ua;
var Be3 = oe2.exports;
var Ve3 = Be3 && Be3.isTypedArray;
var va = Ve3 ? da(Ve3) : la;
var Je2 = va;
function fa(r2, e) {
  if (!(e === "constructor" && typeof r2[e] == "function") && e != "__proto__") return r2[e];
}
var Ke4 = fa;
var ma = se3;
var ga = z4;
var Pa = Object.prototype;
var ba = Pa.hasOwnProperty;
function $a(r2, e, t) {
  var i3 = r2[e];
  (!(ba.call(r2, e) && ga(i3, t)) || t === void 0 && !(e in r2)) && ma(r2, e, t);
}
var ya = $a;
var wa = ya;
var _a = se3;
function Ca(r2, e, t, i3) {
  var s = !t;
  t || (t = {});
  for (var n3 = -1, a2 = e.length; ++n3 < a2; ) {
    var o3 = e[n3], c6 = i3 ? i3(t[o3], r2[o3], o3, t, r2) : void 0;
    c6 === void 0 && (c6 = r2[o3]), s ? _a(t, o3, c6) : wa(t, o3, c6);
  }
  return t;
}
var Ia = Ca;
function Oa(r2, e) {
  for (var t = -1, i3 = Array(r2); ++t < r2; ) i3[t] = e(t);
  return i3;
}
var Aa = Oa;
var ja = 9007199254740991;
var Ha = /^(?:0|[1-9]\d*)$/;
function Ea(r2, e) {
  var t = typeof r2;
  return e = e ?? ja, !!e && (t == "number" || t != "symbol" && Ha.test(r2)) && r2 > -1 && r2 % 1 == 0 && r2 < e;
}
var We3 = Ea;
var Sa = Aa;
var Na = Me4;
var Ta = Ge4;
var Da = W.exports;
var qa = We3;
var Ra = Je2;
var xa = Object.prototype;
var La = xa.hasOwnProperty;
function Ua(r2, e) {
  var t = Ta(r2), i3 = !t && Na(r2), s = !t && !i3 && Da(r2), n3 = !t && !i3 && !s && Ra(r2), a2 = t || i3 || s || n3, o3 = a2 ? Sa(r2.length, String) : [], c6 = o3.length;
  for (var u3 in r2) (e || La.call(r2, u3)) && !(a2 && (u3 == "length" || s && (u3 == "offset" || u3 == "parent") || n3 && (u3 == "buffer" || u3 == "byteLength" || u3 == "byteOffset") || qa(u3, c6))) && o3.push(u3);
  return o3;
}
var Fa = Ua;
function Ma(r2) {
  var e = [];
  if (r2 != null) for (var t in Object(r2)) e.push(t);
  return e;
}
var Ga = Ma;
var za = $3;
var ka = Le4;
var Ba = Ga;
var Va = Object.prototype;
var Ja = Va.hasOwnProperty;
function Ka(r2) {
  if (!za(r2)) return Ba(r2);
  var e = ka(r2), t = [];
  for (var i3 in r2) i3 == "constructor" && (e || !Ja.call(r2, i3)) || t.push(i3);
  return t;
}
var Wa = Ka;
var Xa = Fa;
var Ya = Wa;
var Za = ae2;
function Qa(r2) {
  return Za(r2) ? Xa(r2, true) : Ya(r2);
}
var Xe2 = Qa;
var eo2 = Ia;
var to2 = Xe2;
function ro3(r2) {
  return eo2(r2, to2(r2));
}
var io2 = ro3;
var Ye3 = De3;
var so2 = ne2.exports;
var no3 = Us2;
var ao3 = Ms2;
var oo2 = tn3;
var Ze2 = Me4;
var Qe2 = Ge4;
var co3 = wn3;
var ho2 = W.exports;
var po2 = te3;
var uo2 = $3;
var lo2 = Dn3;
var vo2 = Je2;
var et2 = Ke4;
var fo2 = io2;
function mo2(r2, e, t, i3, s, n3, a2) {
  var o3 = et2(r2, t), c6 = et2(e, t), u3 = a2.get(c6);
  if (u3) {
    Ye3(r2, t, u3);
    return;
  }
  var l5 = n3 ? n3(o3, c6, t + "", r2, e, a2) : void 0, P6 = l5 === void 0;
  if (P6) {
    var d5 = Qe2(c6), Q5 = !d5 && ho2(c6), ve5 = !d5 && !Q5 && vo2(c6);
    l5 = c6, d5 || Q5 || ve5 ? Qe2(o3) ? l5 = o3 : co3(o3) ? l5 = ao3(o3) : Q5 ? (P6 = false, l5 = so2(c6, true)) : ve5 ? (P6 = false, l5 = no3(c6, true)) : l5 = [] : lo2(c6) || Ze2(c6) ? (l5 = o3, Ze2(o3) ? l5 = fo2(o3) : (!uo2(o3) || po2(o3)) && (l5 = oo2(c6))) : P6 = false;
  }
  P6 && (a2.set(c6, l5), s(l5, c6, i3, n3, a2), a2.delete(c6)), Ye3(r2, t, l5);
}
var go2 = mo2;
var Po3 = $s2;
var bo2 = De3;
var $o2 = Ss2;
var yo2 = go2;
var wo2 = $3;
var _o2 = Xe2;
var Co2 = Ke4;
function tt2(r2, e, t, i3, s) {
  r2 !== e && $o2(e, function(n3, a2) {
    if (s || (s = new Po3()), wo2(n3)) yo2(r2, e, a2, t, tt2, i3, s);
    else {
      var o3 = i3 ? i3(Co2(r2, a2), n3, a2 + "", r2, e, s) : void 0;
      o3 === void 0 && (o3 = n3), bo2(r2, a2, o3);
    }
  }, _o2);
}
var Io2 = tt2;
function Oo2(r2) {
  return r2;
}
var rt2 = Oo2;
function Ao2(r2, e, t) {
  switch (t.length) {
    case 0:
      return r2.call(e);
    case 1:
      return r2.call(e, t[0]);
    case 2:
      return r2.call(e, t[0], t[1]);
    case 3:
      return r2.call(e, t[0], t[1], t[2]);
  }
  return r2.apply(e, t);
}
var jo2 = Ao2;
var Ho2 = jo2;
var it2 = Math.max;
function Eo2(r2, e, t) {
  return e = it2(e === void 0 ? r2.length - 1 : e, 0), function() {
    for (var i3 = arguments, s = -1, n3 = it2(i3.length - e, 0), a2 = Array(n3); ++s < n3; ) a2[s] = i3[e + s];
    s = -1;
    for (var o3 = Array(e + 1); ++s < e; ) o3[s] = i3[s];
    return o3[e] = t(a2), Ho2(r2, this, o3);
  };
}
var So2 = Eo2;
function No2(r2) {
  return function() {
    return r2;
  };
}
var To2 = No2;
var Do2 = To2;
var st2 = Ne3;
var qo2 = rt2;
var Ro2 = st2 ? function(r2, e) {
  return st2(r2, "toString", { configurable: true, enumerable: false, value: Do2(e), writable: true });
} : qo2;
var xo2 = Ro2;
var Lo2 = 800;
var Uo2 = 16;
var Fo2 = Date.now;
function Mo2(r2) {
  var e = 0, t = 0;
  return function() {
    var i3 = Fo2(), s = Uo2 - (i3 - t);
    if (t = i3, s > 0) {
      if (++e >= Lo2) return arguments[0];
    } else e = 0;
    return r2.apply(void 0, arguments);
  };
}
var Go2 = Mo2;
var zo2 = xo2;
var ko2 = Go2;
var Bo2 = ko2(zo2);
var Vo2 = Bo2;
var Jo2 = rt2;
var Ko2 = So2;
var Wo2 = Vo2;
function Xo(r2, e) {
  return Wo2(Ko2(r2, e, Jo2), r2 + "");
}
var Yo2 = Xo;
var Zo = z4;
var Qo2 = ae2;
var ec = We3;
var tc = $3;
function rc(r2, e, t) {
  if (!tc(t)) return false;
  var i3 = typeof e;
  return (i3 == "number" ? Qo2(t) && ec(e, t.length) : i3 == "string" && e in t) ? Zo(t[e], r2) : false;
}
var ic = rc;
var sc = Yo2;
var nc = ic;
function ac(r2) {
  return sc(function(e, t) {
    var i3 = -1, s = t.length, n3 = s > 1 ? t[s - 1] : void 0, a2 = s > 2 ? t[2] : void 0;
    for (n3 = r2.length > 3 && typeof n3 == "function" ? (s--, n3) : void 0, a2 && nc(t[0], t[1], a2) && (n3 = s < 3 ? void 0 : n3, s = 1), e = Object(e); ++i3 < s; ) {
      var o3 = t[i3];
      o3 && r2(e, o3, i3, n3);
    }
    return e;
  });
}
var oc = ac;
var cc = Io2;
var hc = oc;
var pc = hc(function(r2, e, t) {
  cc(r2, e, t);
});
var uc = pc;
var lc = Object.defineProperty;
var dc = Object.defineProperties;
var vc = Object.getOwnPropertyDescriptors;
var nt = Object.getOwnPropertySymbols;
var fc = Object.prototype.hasOwnProperty;
var mc = Object.prototype.propertyIsEnumerable;
var at2 = (r2, e, t) => e in r2 ? lc(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var X = (r2, e) => {
  for (var t in e || (e = {})) fc.call(e, t) && at2(r2, t, e[t]);
  if (nt) for (var t of nt(e)) mc.call(e, t) && at2(r2, t, e[t]);
  return r2;
};
var gc = (r2, e) => dc(r2, vc(e));
function v3(r2, e, t) {
  var i3;
  const s = Ye(r2);
  return ((i3 = e.rpcMap) == null ? void 0 : i3[s.reference]) || `${ye2}?chainId=${s.namespace}:${s.reference}&projectId=${t}`;
}
function y5(r2) {
  return r2.includes(":") ? r2.split(":")[1] : r2;
}
function ot2(r2) {
  return r2.map((e) => `${e.split(":")[0]}:${e.split(":")[1]}`);
}
function Pc(r2, e) {
  const t = Object.keys(e.namespaces).filter((s) => s.includes(r2));
  if (!t.length) return [];
  const i3 = [];
  return t.forEach((s) => {
    const n3 = e.namespaces[s].accounts;
    i3.push(...n3);
  }), i3;
}
function ce3(r2 = {}, e = {}) {
  const t = ct2(r2), i3 = ct2(e);
  return uc(t, i3);
}
function ct2(r2) {
  var e, t, i3, s;
  const n3 = {};
  if (!qe(r2)) return n3;
  for (const [a2, o3] of Object.entries(r2)) {
    const c6 = Tt(a2) ? [a2] : o3.chains, u3 = o3.methods || [], l5 = o3.events || [], P6 = o3.rpcMap || {}, d5 = pr(a2);
    n3[d5] = gc(X(X({}, n3[d5]), o3), { chains: Q(c6, (e = n3[d5]) == null ? void 0 : e.chains), methods: Q(u3, (t = n3[d5]) == null ? void 0 : t.methods), events: Q(l5, (i3 = n3[d5]) == null ? void 0 : i3.events), rpcMap: X(X({}, P6), (s = n3[d5]) == null ? void 0 : s.rpcMap) });
  }
  return n3;
}
function bc(r2) {
  return r2.includes(":") ? r2.split(":")[2] : r2;
}
function ht3(r2) {
  const e = {};
  for (const [t, i3] of Object.entries(r2)) {
    const s = i3.methods || [], n3 = i3.events || [], a2 = i3.accounts || [], o3 = Tt(t) ? [t] : i3.chains ? i3.chains : ot2(i3.accounts);
    e[t] = { chains: o3, methods: s, events: n3, accounts: a2 };
  }
  return e;
}
function he2(r2) {
  return typeof r2 == "number" ? r2 : r2.includes("0x") ? parseInt(r2, 16) : (r2 = r2.includes(":") ? r2.split(":")[1] : r2, isNaN(Number(r2)) ? r2 : Number(r2));
}
var pt3 = {};
var h4 = (r2) => pt3[r2];
var pe2 = (r2, e) => {
  pt3[r2] = e;
};
var $c = Object.defineProperty;
var yc = (r2, e, t) => e in r2 ? $c(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var j3 = (r2, e, t) => yc(r2, typeof e != "symbol" ? e + "" : e, t);
var wc = class {
  constructor(e) {
    j3(this, "name", "polkadot"), j3(this, "client"), j3(this, "httpProviders"), j3(this, "events"), j3(this, "namespace"), j3(this, "chainId"), this.namespace = e.namespace, this.events = h4("events"), this.client = h4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f7.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var i3;
      const s = y5(t);
      e[s] = this.createHttpProvider(s, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const i3 = this.createHttpProvider(e, t);
    i3 && (this.httpProviders[e] = i3);
  }
  createHttpProvider(e, t) {
    const i3 = t || v3(e, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new o(new f2(i3, h4("disableProviderPing")));
  }
};
var _c = Object.defineProperty;
var Cc = Object.defineProperties;
var Ic = Object.getOwnPropertyDescriptors;
var ut3 = Object.getOwnPropertySymbols;
var Oc = Object.prototype.hasOwnProperty;
var Ac = Object.prototype.propertyIsEnumerable;
var ue3 = (r2, e, t) => e in r2 ? _c(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var lt2 = (r2, e) => {
  for (var t in e || (e = {})) Oc.call(e, t) && ue3(r2, t, e[t]);
  if (ut3) for (var t of ut3(e)) Ac.call(e, t) && ue3(r2, t, e[t]);
  return r2;
};
var dt3 = (r2, e) => Cc(r2, Ic(e));
var H3 = (r2, e, t) => ue3(r2, typeof e != "symbol" ? e + "" : e, t);
var jc = class {
  constructor(e) {
    H3(this, "name", "eip155"), H3(this, "client"), H3(this, "chainId"), H3(this, "namespace"), H3(this, "httpProviders"), H3(this, "events"), this.namespace = e.namespace, this.events = h4("events"), this.client = h4("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(e) {
    switch (e.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(e);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(e);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(e);
    }
    return this.namespace.methods.includes(e.request.method) ? await this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(parseInt(e), t), this.chainId = parseInt(e), this.events.emit(f7.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  createHttpProvider(e, t) {
    const i3 = t || v3(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new o(new f2(i3, h4("disableProviderPing")));
  }
  setHttpProvider(e, t) {
    const i3 = this.createHttpProvider(e, t);
    i3 && (this.httpProviders[e] = i3);
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var i3;
      const s = parseInt(y5(t));
      e[s] = this.createHttpProvider(s, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[t]);
    }), e;
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const e = this.chainId, t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  async handleSwitchChain(e) {
    var t, i3;
    let s = e.request.params ? (t = e.request.params[0]) == null ? void 0 : t.chainId : "0x0";
    s = s.startsWith("0x") ? s : `0x${s}`;
    const n3 = parseInt(s, 16);
    if (this.isChainApproved(n3)) this.setDefaultChain(`${n3}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: e.topic, request: { method: e.request.method, params: [{ chainId: s }] }, chainId: (i3 = this.namespace.chains) == null ? void 0 : i3[0] }), this.setDefaultChain(`${n3}`);
    else throw new Error(`Failed to switch to chain 'eip155:${n3}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(e) {
    return this.namespace.chains.includes(`${this.name}:${e}`);
  }
  async getCapabilities(e) {
    var t, i3, s;
    const n3 = (i3 = (t = e.request) == null ? void 0 : t.params) == null ? void 0 : i3[0];
    if (!n3) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
    const a2 = this.client.session.get(e.topic), o3 = ((s = a2 == null ? void 0 : a2.sessionProperties) == null ? void 0 : s.capabilities) || {};
    if (o3 != null && o3[n3]) return o3 == null ? void 0 : o3[n3];
    const c6 = await this.client.request(e);
    try {
      await this.client.session.update(e.topic, { sessionProperties: dt3(lt2({}, a2.sessionProperties || {}), { capabilities: dt3(lt2({}, o3 || {}), { [n3]: c6 }) }) });
    } catch (u3) {
      console.warn("Failed to update session with capabilities", u3);
    }
    return c6;
  }
  async getCallStatus(e) {
    var t, i3;
    const s = this.client.session.get(e.topic), n3 = (t = s.sessionProperties) == null ? void 0 : t.bundler_name;
    if (n3) {
      const o3 = this.getBundlerUrl(e.chainId, n3);
      try {
        return await this.getUserOperationReceipt(o3, e);
      } catch (c6) {
        console.warn("Failed to fetch call status from bundler", c6, o3);
      }
    }
    const a2 = (i3 = s.sessionProperties) == null ? void 0 : i3.bundler_url;
    if (a2) try {
      return await this.getUserOperationReceipt(a2, e);
    } catch (o3) {
      console.warn("Failed to fetch call status from custom bundler", o3, a2);
    }
    if (this.namespace.methods.includes(e.request.method)) return await this.client.request(e);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(e, t) {
    var i3;
    const s = new URL(e), n3 = await fetch(s, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(formatJsonRpcRequest("eth_getUserOperationReceipt", [(i3 = t.request.params) == null ? void 0 : i3[0]])) });
    if (!n3.ok) throw new Error(`Failed to fetch user operation receipt - ${n3.status}`);
    return await n3.json();
  }
  getBundlerUrl(e, t) {
    return `${Ot3}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${t}`;
  }
};
var Hc = Object.defineProperty;
var Ec = (r2, e, t) => e in r2 ? Hc(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var E4 = (r2, e, t) => Ec(r2, typeof e != "symbol" ? e + "" : e, t);
var Sc = class {
  constructor(e) {
    E4(this, "name", "solana"), E4(this, "client"), E4(this, "httpProviders"), E4(this, "events"), E4(this, "namespace"), E4(this, "chainId"), this.namespace = e.namespace, this.events = h4("events"), this.client = h4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f7.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var i3;
      const s = y5(t);
      e[s] = this.createHttpProvider(s, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const i3 = this.createHttpProvider(e, t);
    i3 && (this.httpProviders[e] = i3);
  }
  createHttpProvider(e, t) {
    const i3 = t || v3(e, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new o(new f2(i3, h4("disableProviderPing")));
  }
};
var Nc = Object.defineProperty;
var Tc = (r2, e, t) => e in r2 ? Nc(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var S4 = (r2, e, t) => Tc(r2, typeof e != "symbol" ? e + "" : e, t);
var Dc = class {
  constructor(e) {
    S4(this, "name", "cosmos"), S4(this, "client"), S4(this, "httpProviders"), S4(this, "events"), S4(this, "namespace"), S4(this, "chainId"), this.namespace = e.namespace, this.events = h4("events"), this.client = h4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f7.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var i3;
      const s = y5(t);
      e[s] = this.createHttpProvider(s, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const i3 = this.createHttpProvider(e, t);
    i3 && (this.httpProviders[e] = i3);
  }
  createHttpProvider(e, t) {
    const i3 = t || v3(e, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new o(new f2(i3, h4("disableProviderPing")));
  }
};
var qc = Object.defineProperty;
var Rc = (r2, e, t) => e in r2 ? qc(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var N3 = (r2, e, t) => Rc(r2, typeof e != "symbol" ? e + "" : e, t);
var xc = class {
  constructor(e) {
    N3(this, "name", "algorand"), N3(this, "client"), N3(this, "httpProviders"), N3(this, "events"), N3(this, "namespace"), N3(this, "chainId"), this.namespace = e.namespace, this.events = h4("events"), this.client = h4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    if (!this.httpProviders[e]) {
      const i3 = t || v3(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
      if (!i3) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, i3);
    }
    this.chainId = e, this.events.emit(f7.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var i3;
      e[t] = this.createHttpProvider(t, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const i3 = this.createHttpProvider(e, t);
    i3 && (this.httpProviders[e] = i3);
  }
  createHttpProvider(e, t) {
    const i3 = t || v3(e, this.namespace, this.client.core.projectId);
    return typeof i3 > "u" ? void 0 : new o(new f2(i3, h4("disableProviderPing")));
  }
};
var Lc = Object.defineProperty;
var Uc = (r2, e, t) => e in r2 ? Lc(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var T3 = (r2, e, t) => Uc(r2, typeof e != "symbol" ? e + "" : e, t);
var Fc = class {
  constructor(e) {
    T3(this, "name", "cip34"), T3(this, "client"), T3(this, "httpProviders"), T3(this, "events"), T3(this, "namespace"), T3(this, "chainId"), this.namespace = e.namespace, this.events = h4("events"), this.client = h4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f7.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      const i3 = this.getCardanoRPCUrl(t), s = y5(t);
      e[s] = this.createHttpProvider(s, i3);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  getCardanoRPCUrl(e) {
    const t = this.namespace.rpcMap;
    if (t) return t[e];
  }
  setHttpProvider(e, t) {
    const i3 = this.createHttpProvider(e, t);
    i3 && (this.httpProviders[e] = i3);
  }
  createHttpProvider(e, t) {
    const i3 = t || this.getCardanoRPCUrl(e);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new o(new f2(i3, h4("disableProviderPing")));
  }
};
var Mc = Object.defineProperty;
var Gc = (r2, e, t) => e in r2 ? Mc(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var D3 = (r2, e, t) => Gc(r2, typeof e != "symbol" ? e + "" : e, t);
var zc = class {
  constructor(e) {
    D3(this, "name", "elrond"), D3(this, "client"), D3(this, "httpProviders"), D3(this, "events"), D3(this, "namespace"), D3(this, "chainId"), this.namespace = e.namespace, this.events = h4("events"), this.client = h4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f7.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var i3;
      const s = y5(t);
      e[s] = this.createHttpProvider(s, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const i3 = this.createHttpProvider(e, t);
    i3 && (this.httpProviders[e] = i3);
  }
  createHttpProvider(e, t) {
    const i3 = t || v3(e, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new o(new f2(i3, h4("disableProviderPing")));
  }
};
var kc = Object.defineProperty;
var Bc = (r2, e, t) => e in r2 ? kc(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var q3 = (r2, e, t) => Bc(r2, typeof e != "symbol" ? e + "" : e, t);
var Vc = class {
  constructor(e) {
    q3(this, "name", "multiversx"), q3(this, "client"), q3(this, "httpProviders"), q3(this, "events"), q3(this, "namespace"), q3(this, "chainId"), this.namespace = e.namespace, this.events = h4("events"), this.client = h4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f7.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var i3;
      const s = y5(t);
      e[s] = this.createHttpProvider(s, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const i3 = this.createHttpProvider(e, t);
    i3 && (this.httpProviders[e] = i3);
  }
  createHttpProvider(e, t) {
    const i3 = t || v3(e, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new o(new f2(i3, h4("disableProviderPing")));
  }
};
var Jc = Object.defineProperty;
var Kc = (r2, e, t) => e in r2 ? Jc(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var R4 = (r2, e, t) => Kc(r2, typeof e != "symbol" ? e + "" : e, t);
var Wc = class {
  constructor(e) {
    R4(this, "name", "near"), R4(this, "client"), R4(this, "httpProviders"), R4(this, "events"), R4(this, "namespace"), R4(this, "chainId"), this.namespace = e.namespace, this.events = h4("events"), this.client = h4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    if (this.chainId = e, !this.httpProviders[e]) {
      const i3 = t || v3(`${this.name}:${e}`, this.namespace);
      if (!i3) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, i3);
    }
    this.events.emit(f7.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var i3;
      e[t] = this.createHttpProvider(t, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const i3 = this.createHttpProvider(e, t);
    i3 && (this.httpProviders[e] = i3);
  }
  createHttpProvider(e, t) {
    const i3 = t || v3(e, this.namespace);
    return typeof i3 > "u" ? void 0 : new o(new f2(i3, h4("disableProviderPing")));
  }
};
var Xc = Object.defineProperty;
var Yc = (r2, e, t) => e in r2 ? Xc(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var x5 = (r2, e, t) => Yc(r2, typeof e != "symbol" ? e + "" : e, t);
var Zc = class {
  constructor(e) {
    x5(this, "name", "tezos"), x5(this, "client"), x5(this, "httpProviders"), x5(this, "events"), x5(this, "namespace"), x5(this, "chainId"), this.namespace = e.namespace, this.events = h4("events"), this.client = h4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    if (this.chainId = e, !this.httpProviders[e]) {
      const i3 = t || v3(`${this.name}:${e}`, this.namespace);
      if (!i3) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, i3);
    }
    this.events.emit(f7.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      e[t] = this.createHttpProvider(t);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const i3 = this.createHttpProvider(e, t);
    i3 && (this.httpProviders[e] = i3);
  }
  createHttpProvider(e, t) {
    const i3 = t || v3(e, this.namespace);
    return typeof i3 > "u" ? void 0 : new o(new f2(i3));
  }
};
var Qc = Object.defineProperty;
var eh = (r2, e, t) => e in r2 ? Qc(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var L2 = (r2, e, t) => eh(r2, typeof e != "symbol" ? e + "" : e, t);
var th = class {
  constructor(e) {
    L2(this, "name", w), L2(this, "client"), L2(this, "httpProviders"), L2(this, "events"), L2(this, "namespace"), L2(this, "chainId"), this.namespace = e.namespace, this.events = h4("events"), this.client = h4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(e.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(e.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(e.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(e.events || []))], this.httpProviders = this.createHttpProviders();
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider(e.chainId).request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f7.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    var e, t;
    const i3 = {};
    return (t = (e = this.namespace) == null ? void 0 : e.accounts) == null || t.forEach((s) => {
      const n3 = Ye(s);
      i3[`${n3.namespace}:${n3.reference}`] = this.createHttpProvider(s);
    }), i3;
  }
  getHttpProvider(e) {
    const t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const i3 = this.createHttpProvider(e, t);
    i3 && (this.httpProviders[e] = i3);
  }
  createHttpProvider(e, t) {
    const i3 = t || v3(e, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new o(new f2(i3, h4("disableProviderPing")));
  }
};
var rh = Object.defineProperty;
var ih = Object.defineProperties;
var sh = Object.getOwnPropertyDescriptors;
var vt3 = Object.getOwnPropertySymbols;
var nh = Object.prototype.hasOwnProperty;
var ah = Object.prototype.propertyIsEnumerable;
var le4 = (r2, e, t) => e in r2 ? rh(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Y3 = (r2, e) => {
  for (var t in e || (e = {})) nh.call(e, t) && le4(r2, t, e[t]);
  if (vt3) for (var t of vt3(e)) ah.call(e, t) && le4(r2, t, e[t]);
  return r2;
};
var de3 = (r2, e) => ih(r2, sh(e));
var g = (r2, e, t) => le4(r2, typeof e != "symbol" ? e + "" : e, t);
var Z2 = class _Z {
  constructor(e) {
    g(this, "client"), g(this, "namespaces"), g(this, "optionalNamespaces"), g(this, "sessionProperties"), g(this, "events", new import_events7.default()), g(this, "rpcProviders", {}), g(this, "session"), g(this, "providerOpts"), g(this, "logger"), g(this, "uri"), g(this, "disableProviderPing", false), this.providerOpts = e, this.logger = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : (0, import_pino.default)(k({ level: (e == null ? void 0 : e.logger) || be2 })), this.disableProviderPing = (e == null ? void 0 : e.disableProviderPing) || false;
  }
  static async init(e) {
    const t = new _Z(e);
    return await t.initialize(), t;
  }
  async request(e, t, i3) {
    const [s, n3] = this.validateChain(t);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(s).request({ request: Y3({}, e), chainId: `${s}:${n3}`, topic: this.session.topic, expiry: i3 });
  }
  sendAsync(e, t, i3, s) {
    const n3 = (/* @__PURE__ */ new Date()).getTime();
    this.request(e, i3, s).then((a2) => t(null, formatJsonRpcResult(n3, a2))).catch((a2) => t(a2, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var e;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (e = this.session) == null ? void 0 : e.topic, reason: de("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(e) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(e), await this.cleanupPendingPairings(), !e.skipPairing) return await this.pair(e.pairingTopic);
  }
  async authenticate(e, t) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(e), await this.cleanupPendingPairings();
    const { uri: i3, response: s } = await this.client.authenticate(e, t);
    i3 && (this.uri = i3, this.events.emit("display_uri", i3));
    const n3 = await s();
    if (this.session = n3.session, this.session) {
      const a2 = ht3(this.session.namespaces);
      this.namespaces = ce3(this.namespaces, a2), this.persist("namespaces", this.namespaces), this.onConnect();
    }
    return n3;
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  get isWalletConnect() {
    return true;
  }
  async pair(e) {
    const { uri: t, approval: i3 } = await this.client.connect({ pairingTopic: e, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties });
    t && (this.uri = t, this.events.emit("display_uri", t));
    const s = await i3();
    this.session = s;
    const n3 = ht3(s.namespaces);
    return this.namespaces = ce3(this.namespaces, n3), this.persist("namespaces", this.namespaces), this.onConnect(), this.session;
  }
  setDefaultChain(e, t) {
    try {
      if (!this.session) return;
      const [i3, s] = this.validateChain(e), n3 = this.getProvider(i3);
      n3.name === w ? n3.setDefaultChain(`${i3}:${s}`, t) : n3.setDefaultChain(s, t);
    } catch (i3) {
      if (!/Please call connect/.test(i3.message)) throw i3;
    }
  }
  async cleanupPendingPairings(e = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const t = this.client.pairing.getAll();
    if ($e(t)) {
      for (const i3 of t) e.deletePairings ? this.client.core.expirer.set(i3.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(i3.topic);
      this.logger.info(`Inactive pairings cleared: ${t.length}`);
    }
  }
  abortPairingAttempt() {
    this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.");
  }
  async checkStorage() {
    if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
      const e = this.client.session.keys.length - 1;
      this.session = this.client.session.get(this.client.session.keys[e]), this.createProviders();
    }
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    this.client = this.providerOpts.client || await Se2.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || be2, relayUrl: this.providerOpts.relayUrl || _t4, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const e = [...new Set(Object.keys(this.session.namespaces).map((t) => pr(t)))];
    pe2("client", this.client), pe2("events", this.events), pe2("disableProviderPing", this.disableProviderPing), e.forEach((t) => {
      if (!this.session) return;
      const i3 = Pc(t, this.session), s = ot2(i3), n3 = ce3(this.namespaces, this.optionalNamespaces), a2 = de3(Y3({}, n3[t]), { accounts: i3, chains: s });
      switch (t) {
        case "eip155":
          this.rpcProviders[t] = new jc({ namespace: a2 });
          break;
        case "algorand":
          this.rpcProviders[t] = new xc({ namespace: a2 });
          break;
        case "solana":
          this.rpcProviders[t] = new Sc({ namespace: a2 });
          break;
        case "cosmos":
          this.rpcProviders[t] = new Dc({ namespace: a2 });
          break;
        case "polkadot":
          this.rpcProviders[t] = new wc({ namespace: a2 });
          break;
        case "cip34":
          this.rpcProviders[t] = new Fc({ namespace: a2 });
          break;
        case "elrond":
          this.rpcProviders[t] = new zc({ namespace: a2 });
          break;
        case "multiversx":
          this.rpcProviders[t] = new Vc({ namespace: a2 });
          break;
        case "near":
          this.rpcProviders[t] = new Wc({ namespace: a2 });
          break;
        case "tezos":
          this.rpcProviders[t] = new Zc({ namespace: a2 });
          break;
        default:
          this.rpcProviders[w] ? this.rpcProviders[w].updateNamespace(a2) : this.rpcProviders[w] = new th({ namespace: a2 });
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (e) => {
      this.events.emit("session_ping", e);
    }), this.client.on("session_event", (e) => {
      const { params: t } = e, { event: i3 } = t;
      if (i3.name === "accountsChanged") {
        const s = i3.data;
        s && $e(s) && this.events.emit("accountsChanged", s.map(bc));
      } else if (i3.name === "chainChanged") {
        const s = t.chainId, n3 = t.event.data, a2 = pr(s), o3 = he2(s) !== he2(n3) ? `${a2}:${he2(n3)}` : s;
        this.onChainChanged(o3);
      } else this.events.emit(i3.name, i3.data);
      this.events.emit("session_event", e);
    }), this.client.on("session_update", ({ topic: e, params: t }) => {
      var i3;
      const { namespaces: s } = t, n3 = (i3 = this.client) == null ? void 0 : i3.session.get(e);
      this.session = de3(Y3({}, n3), { namespaces: s }), this.onSessionUpdate(), this.events.emit("session_update", { topic: e, params: t });
    }), this.client.on("session_delete", async (e) => {
      await this.cleanup(), this.events.emit("session_delete", e), this.events.emit("disconnect", de3(Y3({}, de("USER_DISCONNECTED")), { data: e.topic }));
    }), this.on(f7.DEFAULT_CHAIN_CHANGED, (e) => {
      this.onChainChanged(e, true);
    });
  }
  getProvider(e) {
    return this.rpcProviders[e] || this.rpcProviders[w];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((e) => {
      var t;
      this.getProvider(e).updateNamespace((t = this.session) == null ? void 0 : t.namespaces[e]);
    });
  }
  setNamespaces(e) {
    const { namespaces: t, optionalNamespaces: i3, sessionProperties: s } = e;
    t && Object.keys(t).length && (this.namespaces = t), i3 && Object.keys(i3).length && (this.optionalNamespaces = i3), this.sessionProperties = s, this.persist("namespaces", t), this.persist("optionalNamespaces", i3);
  }
  validateChain(e) {
    const [t, i3] = (e == null ? void 0 : e.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [t, i3];
    if (t && !Object.keys(this.namespaces || {}).map((a2) => pr(a2)).includes(t)) throw new Error(`Namespace '${t}' is not configured. Please call connect() first with namespace config.`);
    if (t && i3) return [t, i3];
    const s = pr(Object.keys(this.namespaces)[0]), n3 = this.rpcProviders[s].getDefaultChain();
    return [s, n3];
  }
  async requestAccounts() {
    const [e] = this.validateChain();
    return await this.getProvider(e).requestAccounts();
  }
  onChainChanged(e, t = false) {
    if (!this.namespaces) return;
    const [i3, s] = this.validateChain(e);
    s && (t || this.getProvider(i3).setDefaultChain(s), this.namespaces[i3] ? this.namespaces[i3].defaultChain = s : this.namespaces[`${i3}:${s}`] ? this.namespaces[`${i3}:${s}`].defaultChain = s : this.namespaces[`${i3}:${s}`] = { defaultChain: s }, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", s));
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({ deletePairings: true });
  }
  persist(e, t) {
    this.client.core.storage.setItem(`${$e4}/${e}`, t);
  }
  async getFromStore(e) {
    return await this.client.core.storage.getItem(`${$e4}/${e}`);
  }
};
var oh = Z2;

// node_modules/@reown/appkit/node_modules/@walletconnect/core/dist/index.es.js
var import_events8 = __toESM(require_events());

// node_modules/@reown/appkit/node_modules/unstorage/dist/shared/unstorage.CoCt7NXC.mjs
function wrapToPromise2(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall2(function_, ...arguments_) {
  try {
    return wrapToPromise2(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive2(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject2(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify4(value) {
  if (isPrimitive2(value)) {
    return String(value);
  }
  if (isPureObject2(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify4(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
var BASE64_PREFIX2 = "base64:";
function serializeRaw2(value) {
  if (typeof value === "string") {
    return value;
  }
  return BASE64_PREFIX2 + base64Encode2(value);
}
function deserializeRaw2(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX2)) {
    return value;
  }
  return base64Decode2(value.slice(BASE64_PREFIX2.length));
}
function base64Decode2(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c6) => c6.codePointAt(0)
  );
}
function base64Encode2(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}
function normalizeKey2(key) {
  var _a2;
  if (!key) {
    return "";
  }
  return ((_a2 = key.split("?")[0]) == null ? void 0 : _a2.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || "";
}
function joinKeys2(...keys2) {
  return normalizeKey2(keys2.join(":"));
}
function normalizeBaseKey2(base5) {
  base5 = normalizeKey2(base5);
  return base5 ? base5 + ":" : "";
}
function filterKeyByDepth2(key, depth) {
  if (depth === void 0) {
    return true;
  }
  let substrCount = 0;
  let index = key.indexOf(":");
  while (index > -1) {
    substrCount++;
    index = key.indexOf(":", index + 1);
  }
  return substrCount <= depth;
}
function filterKeyByBase2(key, base5) {
  if (base5) {
    return key.startsWith(base5) && key[key.length - 1] !== "$";
  }
  return key[key.length - 1] !== "$";
}

// node_modules/@reown/appkit/node_modules/unstorage/dist/index.mjs
function defineDriver2(factory) {
  return factory;
}
var DRIVER_NAME2 = "memory";
var memory2 = defineDriver2(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME2,
    getInstance: () => data,
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});
function createStorage2(options = {}) {
  const context = {
    mounts: { "": options.driver || memory2() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base5 of context.mountpoints) {
      if (key.startsWith(base5)) {
        return {
          base: base5,
          relativeKey: key.slice(base5.length),
          driver: context.mounts[base5]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base5, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base5) || includeParent && base5.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base5.length > mountpoint.length ? base5.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey2(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch2(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey2(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r2) => r2.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall2(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall2(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall2(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r2) => r2.map((item) => ({
              key: joinKeys2(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall2(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall2(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall2(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw2(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall2(driver.setItem, relativeKey, stringify4(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall2(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify4(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall2(
              batch.driver.setItem,
              item.relativeKey,
              stringify4(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall2(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall2(driver.setItem, relativeKey, serializeRaw2(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall2(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall2(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall2(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall2(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base5, opts = {}) {
      var _a2;
      base5 = normalizeBaseKey2(base5);
      const mounts = getMounts(base5, true);
      let maskedMounts = [];
      const allKeys = [];
      let allMountsSupportMaxDepth = true;
      for (const mount of mounts) {
        if (!((_a2 = mount.driver.flags) == null ? void 0 : _a2.maxDepth)) {
          allMountsSupportMaxDepth = false;
        }
        const rawKeys = await asyncCall2(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey2(key);
          if (!maskedMounts.some((p6) => fullKey.startsWith(p6))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p6) => !p6.startsWith(mount.mountpoint))
        ];
      }
      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;
      return allKeys.filter(
        (key) => (!shouldFilterByDepth || filterKeyByDepth2(key, opts.maxDepth)) && filterKeyByBase2(key, base5)
      );
    },
    // Utils
    async clear(base5, opts = {}) {
      base5 = normalizeBaseKey2(base5);
      await Promise.all(
        getMounts(base5, false).map(async (m3) => {
          if (m3.driver.clear) {
            return asyncCall2(m3.driver.clear, m3.relativeBase, opts);
          }
          if (m3.driver.removeItem) {
            const keys2 = await m3.driver.getKeys(m3.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key) => m3.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose2(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base5, driver) {
      base5 = normalizeBaseKey2(base5);
      if (base5 && context.mounts[base5]) {
        throw new Error(`already mounted at ${base5}`);
      }
      if (base5) {
        context.mountpoints.push(base5);
        context.mountpoints.sort((a2, b4) => b4.length - a2.length);
      }
      context.mounts[base5] = driver;
      if (context.watching) {
        Promise.resolve(watch2(driver, onChange, base5)).then((unwatcher) => {
          context.unwatch[base5] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base5, _dispose = true) {
      var _a2, _b;
      base5 = normalizeBaseKey2(base5);
      if (!base5 || !context.mounts[base5]) {
        return;
      }
      if (context.watching && base5 in context.unwatch) {
        (_b = (_a2 = context.unwatch)[base5]) == null ? void 0 : _b.call(_a2);
        delete context.unwatch[base5];
      }
      if (_dispose) {
        await dispose2(context.mounts[base5]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base5);
      delete context.mounts[base5];
    },
    getMount(key = "") {
      key = normalizeKey2(key) + ":";
      const m3 = getMount(key);
      return {
        driver: m3.driver,
        base: m3.base
      };
    },
    getMounts(base5 = "", opts = {}) {
      base5 = normalizeKey2(base5);
      const mounts = getMounts(base5, opts.parents);
      return mounts.map((m3) => ({
        driver: m3.driver,
        base: m3.mountpoint
      }));
    },
    // Aliases
    keys: (base5, opts = {}) => storage.getKeys(base5, opts),
    get: (key, opts = {}) => storage.getItem(key, opts),
    set: (key, value, opts = {}) => storage.setItem(key, value, opts),
    has: (key, opts = {}) => storage.hasItem(key, opts),
    del: (key, opts = {}) => storage.removeItem(key, opts),
    remove: (key, opts = {}) => storage.removeItem(key, opts)
  };
  return storage;
}
function watch2(driver, onChange, base5) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base5 + key)) : () => {
  };
}
async function dispose2(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall2(driver.dispose);
  }
}

// node_modules/@reown/appkit/node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var x6 = "idb-keyval";
var z5 = (i3 = {}) => {
  const t = i3.base && i3.base.length > 0 ? `${i3.base}:` : "", e = (s) => t + s;
  let n3;
  return i3.dbName && i3.storeName && (n3 = createStore(i3.dbName, i3.storeName)), { name: x6, options: i3, async hasItem(s) {
    return !(typeof await get(e(s), n3) > "u");
  }, async getItem(s) {
    return await get(e(s), n3) ?? null;
  }, setItem(s, a2) {
    return set(e(s), a2, n3);
  }, removeItem(s) {
    return del(e(s), n3);
  }, getKeys() {
    return keys(n3);
  }, clear() {
    return clear(n3);
  } };
};
var D4 = "WALLET_CONNECT_V2_INDEXED_DB";
var E5 = "keyvaluestorage";
var _5 = class {
  constructor() {
    this.indexedDb = createStorage2({ driver: z5({ dbName: D4, storeName: E5 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const e = await this.indexedDb.getItem(t);
    if (e !== null) return e;
  }
  async setItem(t, e) {
    await this.indexedDb.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var l4 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c4 = { exports: {} };
(function() {
  let i3;
  function t() {
  }
  i3 = t, i3.prototype.getItem = function(e) {
    return this.hasOwnProperty(e) ? String(this[e]) : null;
  }, i3.prototype.setItem = function(e, n3) {
    this[e] = String(n3);
  }, i3.prototype.removeItem = function(e) {
    delete this[e];
  }, i3.prototype.clear = function() {
    const e = this;
    Object.keys(e).forEach(function(n3) {
      e[n3] = void 0, delete e[n3];
    });
  }, i3.prototype.key = function(e) {
    return e = e || 0, Object.keys(this)[e];
  }, i3.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l4 < "u" && l4.localStorage ? c4.exports = l4.localStorage : typeof window < "u" && window.localStorage ? c4.exports = window.localStorage : c4.exports = new t();
})();
function k5(i3) {
  var t;
  return [i3[0], safeJsonParse((t = i3[1]) != null ? t : "")];
}
var K4 = class {
  constructor() {
    this.localStorage = c4.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k5);
  }
  async getItem(t) {
    const e = this.localStorage.getItem(t);
    if (e !== null) return safeJsonParse(e);
  }
  async setItem(t, e) {
    this.localStorage.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
var N4 = "wc_storage_version";
var y6 = 1;
var O5 = async (i3, t, e) => {
  const n3 = N4, s = await t.getItem(n3);
  if (s && s >= y6) {
    e(t);
    return;
  }
  const a2 = await i3.getKeys();
  if (!a2.length) {
    e(t);
    return;
  }
  const m3 = [];
  for (; a2.length; ) {
    const r2 = a2.shift();
    if (!r2) continue;
    const o3 = r2.toLowerCase();
    if (o3.includes("wc@") || o3.includes("walletconnect") || o3.includes("wc_") || o3.includes("wallet_connect")) {
      const f10 = await i3.getItem(r2);
      await t.setItem(r2, f10), m3.push(r2);
    }
  }
  await t.setItem(n3, y6), e(t), j4(i3, m3);
};
var j4 = async (i3, t) => {
  t.length && t.forEach(async (e) => {
    await i3.removeItem(e);
  });
};
var h5 = class {
  constructor() {
    this.initialized = false, this.setInitialized = (e) => {
      this.storage = e, this.initialized = true;
    };
    const t = new K4();
    this.storage = t;
    try {
      const e = new _5();
      O5(t, e, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, e) {
    return await this.initialize(), this.storage.setItem(t, e);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const e = setInterval(() => {
        this.initialized && (clearInterval(e), t());
      }, 20);
    });
  }
};

// node_modules/@reown/appkit/node_modules/@walletconnect/core/dist/index.es.js
var import_time5 = __toESM(require_cjs());

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/dist/index.es.js
var import_time4 = __toESM(require_cjs());
var import_window_getters3 = __toESM(require_cjs2());
var import_window_metadata2 = __toESM(require_cjs3());

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
function publicKeyToAddress2(publicKey) {
  const address = keccak2562(`0x${publicKey.substring(4)}`).substring(26);
  return checksumAddress2(`0x${address}`);
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverPublicKey.js
async function recoverPublicKey2({ hash, signature }) {
  const hashHex = isHex2(hash) ? hash : toHex3(hash);
  const { secp256k1: secp256k13 } = await import("./secp256k1-NRWN4ZMW.js");
  const signature_ = (() => {
    if (typeof signature === "object" && "r" in signature && "s" in signature) {
      const { r: r2, s, v: v6, yParity } = signature;
      const yParityOrV2 = Number(yParity ?? v6);
      const recoveryBit2 = toRecoveryBit2(yParityOrV2);
      return new secp256k13.Signature(hexToBigInt3(r2), hexToBigInt3(s)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex2(signature) ? signature : toHex3(signature);
    const yParityOrV = hexToNumber3(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit2(yParityOrV);
    return secp256k13.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey}`;
}
function toRecoveryBit2(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverAddress.js
async function recoverAddress2({ hash, signature }) {
  return publicKeyToAddress2(await recoverPublicKey2({ hash, signature }));
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transaction.js
var transactionType2 = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction3(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber3(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber3(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType2[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList2(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction3 = defineFormatter2("transaction", formatTransaction3);
function formatAuthorizationList2(authorizationList) {
  return authorizationList.map((authorization) => ({
    contractAddress: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/block.js
function formatBlock2(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction3(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock3 = defineFormatter2("block", formatBlock2);

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/public/getTransactionCount.js
async function getTransactionCount2(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [address, blockNumber ? numberToHex3(blockNumber) : blockTag]
  }, { dedupe: Boolean(blockNumber) });
  return hexToNumber3(count);
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction2 = 6;
var bytesPerFieldElement2 = 32;
var fieldElementsPerBlob2 = 4096;
var bytesPerBlob2 = bytesPerFieldElement2 * fieldElementsPerBlob2;
var maxBytesPerTransaction2 = bytesPerBlob2 * blobsPerTransaction2 - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob2 * blobsPerTransaction2;

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/log.js
function formatLog3(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/wallet/sendTransaction.js
var supportsWalletNamespace2 = new LruMap2(128);

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/promise/withDedupe.js
var promiseCache2 = new LruMap2(8192);

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/rpc/id.js
function createIdStore2() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache2 = createIdStore2();

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transactionReceipt.js
var receiptStatuses2 = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt2(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog3(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber3(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses2[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType2[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt3 = defineFormatter2("transactionReceipt", formatTransactionReceipt2);

// node_modules/@reown/appkit/node_modules/@noble/hashes/esm/ripemd160.js
var Rho2 = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id2 = new Uint8Array(new Array(16).fill(0).map((_7, i3) => i3));
var Pi5 = Id2.map((i3) => (9 * i3 + 5) % 16);
var idxL2 = [Id2];
var idxR2 = [Pi5];
for (let i3 = 0; i3 < 4; i3++)
  for (let j5 of [idxL2, idxR2])
    j5.push(j5[i3].map((k8) => Rho2[k8]));
var shifts2 = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i3) => new Uint8Array(i3));
var shiftsL2 = idxL2.map((idx, i3) => idx.map((j5) => shifts2[i3][j5]));
var shiftsR2 = idxR2.map((idx, i3) => idx.map((j5) => shifts2[i3][j5]));
var Kl2 = new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr4 = new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f8(group, x9, y9, z9) {
  if (group === 0)
    return x9 ^ y9 ^ z9;
  else if (group === 1)
    return x9 & y9 | ~x9 & z9;
  else if (group === 2)
    return (x9 | ~y9) ^ z9;
  else if (group === 3)
    return x9 & z9 | y9 & ~z9;
  else
    return x9 ^ (y9 | ~z9);
}
var R_BUF2 = new Uint32Array(16);
var RIPEMD1602 = class extends HashMD2 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2: h22, h3: h32, h4: h42 } = this;
    return [h0, h1, h22, h32, h42];
  }
  set(h0, h1, h22, h32, h42) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h22 | 0;
    this.h3 = h32 | 0;
    this.h4 = h42 | 0;
  }
  process(view, offset) {
    for (let i3 = 0; i3 < 16; i3++, offset += 4)
      R_BUF2[i3] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar6 = al, bl = this.h1 | 0, br6 = bl, cl = this.h2 | 0, cr6 = cl, dl = this.h3 | 0, dr6 = dl, el = this.h4 | 0, er6 = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl2[group], hbr = Kr4[group];
      const rl = idxL2[group], rr6 = idxR2[group];
      const sl = shiftsL2[group], sr6 = shiftsR2[group];
      for (let i3 = 0; i3 < 16; i3++) {
        const tl = rotl2(al + f8(group, bl, cl, dl) + R_BUF2[rl[i3]] + hbl, sl[i3]) + el | 0;
        al = el, el = dl, dl = rotl2(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i3 = 0; i3 < 16; i3++) {
        const tr6 = rotl2(ar6 + f8(rGroup, br6, cr6, dr6) + R_BUF2[rr6[i3]] + hbr, sr6[i3]) + er6 | 0;
        ar6 = er6, er6 = dr6, dr6 = rotl2(cr6, 10) | 0, cr6 = br6, br6 = tr6;
      }
    }
    this.set(this.h1 + cl + dr6 | 0, this.h2 + dl + er6 | 0, this.h3 + el + ar6 | 0, this.h4 + al + br6 | 0, this.h0 + bl + cr6 | 0);
  }
  roundClean() {
    R_BUF2.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd1603 = wrapConstructor2(() => new RIPEMD1602());

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/nonceManager.js
function createNonceManager2(parameters) {
  const { source } = parameters;
  const deltaMap = /* @__PURE__ */ new Map();
  const nonceMap = new LruMap2(8192);
  const promiseMap = /* @__PURE__ */ new Map();
  const getKey = ({ address, chainId }) => `${address}.${chainId}`;
  return {
    async consume({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      const promise = this.get({ address, chainId, client });
      this.increment({ address, chainId });
      const nonce = await promise;
      await source.set({ address, chainId }, nonce);
      nonceMap.set(key, nonce);
      return nonce;
    },
    async increment({ address, chainId }) {
      const key = getKey({ address, chainId });
      const delta = deltaMap.get(key) ?? 0;
      deltaMap.set(key, delta + 1);
    },
    async get({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      let promise = promiseMap.get(key);
      if (!promise) {
        promise = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client });
            const previousNonce = nonceMap.get(key) ?? 0;
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1;
            nonceMap.delete(key);
            return nonce;
          } finally {
            this.reset({ address, chainId });
          }
        })();
        promiseMap.set(key, promise);
      }
      const delta = deltaMap.get(key) ?? 0;
      return delta + await promise;
    },
    reset({ address, chainId }) {
      const key = getKey({ address, chainId });
      deltaMap.delete(key);
      promiseMap.delete(key);
    }
  };
}
function jsonRpc2() {
  return {
    async get(parameters) {
      const { address, client } = parameters;
      return getTransactionCount2(client, {
        address,
        blockTag: "pending"
      });
    },
    set() {
    }
  };
}
var nonceManager2 = createNonceManager2({
  source: jsonRpc2()
});

// node_modules/@reown/appkit/node_modules/ox/_esm/core/version.js
var version2 = "0.1.1";

// node_modules/@reown/appkit/node_modules/ox/_esm/core/internal/errors.js
function getVersion2() {
  return version2;
}

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Errors.js
var BaseError5 = class _BaseError extends Error {
  constructor(shortMessage, options = {}) {
    const details = (() => {
      var _a2;
      if (options.cause instanceof _BaseError) {
        if (options.cause.details)
          return options.cause.details;
        if (options.cause.shortMessage)
          return options.cause.shortMessage;
      }
      if ((_a2 = options.cause) == null ? void 0 : _a2.message)
        return options.cause.message;
      return options.details;
    })();
    const docsPath = (() => {
      if (options.cause instanceof _BaseError)
        return options.cause.docsPath || options.docsPath;
      return options.docsPath;
    })();
    const docsBaseUrl = "https://oxlib.sh";
    const docs = `${docsBaseUrl}${docsPath ?? ""}`;
    const message = [
      shortMessage || "An error occurred.",
      ...options.metaMessages ? ["", ...options.metaMessages] : [],
      ...details || docsPath ? [
        "",
        details ? `Details: ${details}` : void 0,
        docsPath ? `See: ${docs}` : void 0
      ] : []
    ].filter((x9) => typeof x9 === "string").join("\n");
    super(message, options.cause ? { cause: options.cause } : void 0);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseError"
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: `ox@${getVersion2()}`
    });
    this.cause = options.cause;
    this.details = details;
    this.docs = docs;
    this.docsPath = docsPath;
    this.shortMessage = shortMessage;
  }
  walk(fn6) {
    return walk2(this, fn6);
  }
};
function walk2(err, fn6) {
  if (fn6 == null ? void 0 : fn6(err))
    return err;
  if (err && typeof err === "object" && "cause" in err && err.cause)
    return walk2(err.cause, fn6);
  return fn6 ? null : err;
}

// node_modules/@reown/appkit/node_modules/ox/_esm/core/internal/bytes.js
function assertSize3(bytes, size_) {
  if (size5(bytes) > size_)
    throw new SizeOverflowError4({
      givenSize: size5(bytes),
      maxSize: size_
    });
}
var charCodeMap2 = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase162(char) {
  if (char >= charCodeMap2.zero && char <= charCodeMap2.nine)
    return char - charCodeMap2.zero;
  if (char >= charCodeMap2.A && char <= charCodeMap2.F)
    return char - (charCodeMap2.A - 10);
  if (char >= charCodeMap2.a && char <= charCodeMap2.f)
    return char - (charCodeMap2.a - 10);
  return void 0;
}
function pad6(bytes, options = {}) {
  const { dir, size: size7 = 32 } = options;
  if (size7 === 0)
    return bytes;
  if (bytes.length > size7)
    throw new SizeExceedsPaddingSizeError4({
      size: bytes.length,
      targetSize: size7,
      type: "Bytes"
    });
  const paddedBytes = new Uint8Array(size7);
  for (let i3 = 0; i3 < size7; i3++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i3 : size7 - i3 - 1] = bytes[padEnd ? i3 : bytes.length - i3 - 1];
  }
  return paddedBytes;
}

// node_modules/@reown/appkit/node_modules/ox/_esm/core/internal/hex.js
function assertSize4(hex, size_) {
  if (size6(hex) > size_)
    throw new SizeOverflowError5({
      givenSize: size6(hex),
      maxSize: size_
    });
}
function pad7(hex_, options = {}) {
  const { dir, size: size7 = 32 } = options;
  if (size7 === 0)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size7 * 2)
    throw new SizeExceedsPaddingSizeError5({
      size: Math.ceil(hex.length / 2),
      targetSize: size7,
      type: "Hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size7 * 2, "0")}`;
}

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Bytes.js
var decoder2 = new TextDecoder();
var encoder3 = new TextEncoder();
function from6(value) {
  if (value instanceof Uint8Array)
    return value;
  if (typeof value === "string")
    return fromHex4(value);
  return fromArray2(value);
}
function fromArray2(value) {
  return value instanceof Uint8Array ? value : new Uint8Array(value);
}
function fromHex4(value, options = {}) {
  const { size: size7 } = options;
  let hex = value;
  if (size7) {
    assertSize4(value, size7);
    hex = padRight3(value, size7);
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes = new Uint8Array(length);
  for (let index = 0, j5 = 0; index < length; index++) {
    const nibbleLeft = charCodeToBase162(hexString.charCodeAt(j5++));
    const nibbleRight = charCodeToBase162(hexString.charCodeAt(j5++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError5(`Invalid byte sequence ("${hexString[j5 - 2]}${hexString[j5 - 1]}" in "${hexString}").`);
    }
    bytes[index] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes;
}
function fromString4(value, options = {}) {
  const { size: size7 } = options;
  const bytes = encoder3.encode(value);
  if (typeof size7 === "number") {
    assertSize3(bytes, size7);
    return padRight4(bytes, size7);
  }
  return bytes;
}
function padRight4(value, size7) {
  return pad6(value, { dir: "right", size: size7 });
}
function size5(value) {
  return value.length;
}
var SizeOverflowError4 = class extends BaseError5 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Bytes.SizeOverflowError"
    });
  }
};
var SizeExceedsPaddingSizeError4 = class extends BaseError5 {
  constructor({ size: size7, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size7}\`) exceeds padding size (\`${targetSize}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Bytes.SizeExceedsPaddingSizeError"
    });
  }
};

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Hex.js
var encoder4 = new TextEncoder();
var hexes2 = Array.from({ length: 256 }, (_v, i3) => i3.toString(16).padStart(2, "0"));
function concat5(...values) {
  return `0x${values.reduce((acc, x9) => acc + x9.replace("0x", ""), "")}`;
}
function fromBoolean2(value, options = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof options.size === "number") {
    assertSize4(hex, options.size);
    return padLeft2(hex, options.size);
  }
  return hex;
}
function fromBytes4(value, options = {}) {
  let string = "";
  for (let i3 = 0; i3 < value.length; i3++)
    string += hexes2[value[i3]];
  const hex = `0x${string}`;
  if (typeof options.size === "number") {
    assertSize4(hex, options.size);
    return padRight3(hex, options.size);
  }
  return hex;
}
function fromNumber2(value, options = {}) {
  const { signed, size: size7 } = options;
  const value_ = BigInt(value);
  let maxValue;
  if (size7) {
    if (signed)
      maxValue = (1n << BigInt(size7) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size7) * 8n) - 1n;
  } else if (typeof value === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value_ > maxValue || value_ < minValue) {
    const suffix = typeof value === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError3({
      max: maxValue ? `${maxValue}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed,
      size: size7,
      value: `${value}${suffix}`
    });
  }
  const stringValue = (signed && value_ < 0 ? (1n << BigInt(size7 * 8)) + BigInt(value_) : value_).toString(16);
  const hex = `0x${stringValue}`;
  if (size7)
    return padLeft2(hex, size7);
  return hex;
}
function fromString5(value, options = {}) {
  return fromBytes4(encoder4.encode(value), options);
}
function padLeft2(value, size7) {
  return pad7(value, { dir: "left", size: size7 });
}
function padRight3(value, size7) {
  return pad7(value, { dir: "right", size: size7 });
}
function size6(value) {
  return Math.ceil((value.length - 2) / 2);
}
var IntegerOutOfRangeError3 = class extends BaseError5 {
  constructor({ max, min, signed, size: size7, value }) {
    super(`Number \`${value}\` is not in safe${size7 ? ` ${size7 * 8}-bit` : ""}${signed ? " signed" : " unsigned"} integer range ${max ? `(\`${min}\` to \`${max}\`)` : `(above \`${min}\`)`}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.IntegerOutOfRangeError"
    });
  }
};
var SizeOverflowError5 = class extends BaseError5 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SizeOverflowError"
    });
  }
};
var SizeExceedsPaddingSizeError5 = class extends BaseError5 {
  constructor({ size: size7, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size7}\`) exceeds padding size (\`${targetSize}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SizeExceedsPaddingSizeError"
    });
  }
};

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Hash.js
function keccak2564(value, options = {}) {
  const { as: as4 = typeof value === "string" ? "Hex" : "Bytes" } = options;
  const bytes = keccak_2562(from6(value));
  if (as4 === "Bytes")
    return bytes;
  return fromBytes4(bytes);
}

// node_modules/@reown/appkit/node_modules/ox/_esm/core/internal/lru.js
var LruMap4 = class extends Map {
  constructor(size7) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size7;
  }
  get(key) {
    const value = super.get(key);
    if (super.has(key) && value !== void 0) {
      this.delete(key);
      super.set(key, value);
    }
    return value;
  }
  set(key, value) {
    super.set(key, value);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
};

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Caches.js
var caches2 = {
  checksum: new LruMap4(8192)
};
var checksum3 = caches2.checksum;

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Address.js
var addressRegex2 = /^0x[a-fA-F0-9]{40}$/;
function assert2(value, options = {}) {
  const { strict = true } = options;
  if (!addressRegex2.test(value))
    throw new InvalidAddressError5({
      address: value,
      cause: new InvalidInputError2()
    });
  if (strict) {
    if (value.toLowerCase() === value)
      return;
    if (checksum4(value) !== value)
      throw new InvalidAddressError5({
        address: value,
        cause: new InvalidChecksumError2()
      });
  }
}
function checksum4(address) {
  if (checksum3.has(address))
    return checksum3.get(address);
  assert2(address, { strict: false });
  const hexAddress = address.substring(2).toLowerCase();
  const hash = keccak2564(fromString4(hexAddress), { as: "Bytes" });
  const characters = hexAddress.split("");
  for (let i3 = 0; i3 < 40; i3 += 2) {
    if (hash[i3 >> 1] >> 4 >= 8 && characters[i3]) {
      characters[i3] = characters[i3].toUpperCase();
    }
    if ((hash[i3 >> 1] & 15) >= 8 && characters[i3 + 1]) {
      characters[i3 + 1] = characters[i3 + 1].toUpperCase();
    }
  }
  const result = `0x${characters.join("")}`;
  checksum3.set(address, result);
  return result;
}
var InvalidAddressError5 = class extends BaseError5 {
  constructor({ address, cause }) {
    super(`Address "${address}" is invalid.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidAddressError"
    });
  }
};
var InvalidInputError2 = class extends BaseError5 {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidInputError"
    });
  }
};
var InvalidChecksumError2 = class extends BaseError5 {
  constructor() {
    super("Address does not match its checksum counterpart.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidChecksumError"
    });
  }
};

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Solidity.js
var arrayRegex4 = /^(.*)\[([0-9]*)\]$/;
var bytesRegex4 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex4 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var maxInt83 = 2n ** (8n - 1n) - 1n;
var maxInt163 = 2n ** (16n - 1n) - 1n;
var maxInt243 = 2n ** (24n - 1n) - 1n;
var maxInt323 = 2n ** (32n - 1n) - 1n;
var maxInt403 = 2n ** (40n - 1n) - 1n;
var maxInt483 = 2n ** (48n - 1n) - 1n;
var maxInt563 = 2n ** (56n - 1n) - 1n;
var maxInt643 = 2n ** (64n - 1n) - 1n;
var maxInt723 = 2n ** (72n - 1n) - 1n;
var maxInt803 = 2n ** (80n - 1n) - 1n;
var maxInt883 = 2n ** (88n - 1n) - 1n;
var maxInt963 = 2n ** (96n - 1n) - 1n;
var maxInt1043 = 2n ** (104n - 1n) - 1n;
var maxInt1123 = 2n ** (112n - 1n) - 1n;
var maxInt1203 = 2n ** (120n - 1n) - 1n;
var maxInt1283 = 2n ** (128n - 1n) - 1n;
var maxInt1363 = 2n ** (136n - 1n) - 1n;
var maxInt1443 = 2n ** (144n - 1n) - 1n;
var maxInt1523 = 2n ** (152n - 1n) - 1n;
var maxInt1603 = 2n ** (160n - 1n) - 1n;
var maxInt1683 = 2n ** (168n - 1n) - 1n;
var maxInt1763 = 2n ** (176n - 1n) - 1n;
var maxInt1843 = 2n ** (184n - 1n) - 1n;
var maxInt1923 = 2n ** (192n - 1n) - 1n;
var maxInt2003 = 2n ** (200n - 1n) - 1n;
var maxInt2083 = 2n ** (208n - 1n) - 1n;
var maxInt2163 = 2n ** (216n - 1n) - 1n;
var maxInt2243 = 2n ** (224n - 1n) - 1n;
var maxInt2323 = 2n ** (232n - 1n) - 1n;
var maxInt2403 = 2n ** (240n - 1n) - 1n;
var maxInt2483 = 2n ** (248n - 1n) - 1n;
var maxInt2563 = 2n ** (256n - 1n) - 1n;
var minInt83 = -(2n ** (8n - 1n));
var minInt163 = -(2n ** (16n - 1n));
var minInt243 = -(2n ** (24n - 1n));
var minInt323 = -(2n ** (32n - 1n));
var minInt403 = -(2n ** (40n - 1n));
var minInt483 = -(2n ** (48n - 1n));
var minInt563 = -(2n ** (56n - 1n));
var minInt643 = -(2n ** (64n - 1n));
var minInt723 = -(2n ** (72n - 1n));
var minInt803 = -(2n ** (80n - 1n));
var minInt883 = -(2n ** (88n - 1n));
var minInt963 = -(2n ** (96n - 1n));
var minInt1043 = -(2n ** (104n - 1n));
var minInt1123 = -(2n ** (112n - 1n));
var minInt1203 = -(2n ** (120n - 1n));
var minInt1283 = -(2n ** (128n - 1n));
var minInt1363 = -(2n ** (136n - 1n));
var minInt1443 = -(2n ** (144n - 1n));
var minInt1523 = -(2n ** (152n - 1n));
var minInt1603 = -(2n ** (160n - 1n));
var minInt1683 = -(2n ** (168n - 1n));
var minInt1763 = -(2n ** (176n - 1n));
var minInt1843 = -(2n ** (184n - 1n));
var minInt1923 = -(2n ** (192n - 1n));
var minInt2003 = -(2n ** (200n - 1n));
var minInt2083 = -(2n ** (208n - 1n));
var minInt2163 = -(2n ** (216n - 1n));
var minInt2243 = -(2n ** (224n - 1n));
var minInt2323 = -(2n ** (232n - 1n));
var minInt2403 = -(2n ** (240n - 1n));
var minInt2483 = -(2n ** (248n - 1n));
var minInt2563 = -(2n ** (256n - 1n));
var maxUint83 = 2n ** 8n - 1n;
var maxUint164 = 2n ** 16n - 1n;
var maxUint243 = 2n ** 24n - 1n;
var maxUint323 = 2n ** 32n - 1n;
var maxUint403 = 2n ** 40n - 1n;
var maxUint483 = 2n ** 48n - 1n;
var maxUint563 = 2n ** 56n - 1n;
var maxUint643 = 2n ** 64n - 1n;
var maxUint723 = 2n ** 72n - 1n;
var maxUint803 = 2n ** 80n - 1n;
var maxUint883 = 2n ** 88n - 1n;
var maxUint963 = 2n ** 96n - 1n;
var maxUint1043 = 2n ** 104n - 1n;
var maxUint1123 = 2n ** 112n - 1n;
var maxUint1203 = 2n ** 120n - 1n;
var maxUint1283 = 2n ** 128n - 1n;
var maxUint1363 = 2n ** 136n - 1n;
var maxUint1443 = 2n ** 144n - 1n;
var maxUint1523 = 2n ** 152n - 1n;
var maxUint1603 = 2n ** 160n - 1n;
var maxUint1683 = 2n ** 168n - 1n;
var maxUint1763 = 2n ** 176n - 1n;
var maxUint1843 = 2n ** 184n - 1n;
var maxUint1923 = 2n ** 192n - 1n;
var maxUint2003 = 2n ** 200n - 1n;
var maxUint2083 = 2n ** 208n - 1n;
var maxUint2163 = 2n ** 216n - 1n;
var maxUint2243 = 2n ** 224n - 1n;
var maxUint2323 = 2n ** 232n - 1n;
var maxUint2403 = 2n ** 240n - 1n;
var maxUint2483 = 2n ** 248n - 1n;
var maxUint2565 = 2n ** 256n - 1n;

// node_modules/@reown/appkit/node_modules/ox/_esm/core/internal/cursor.js
var staticCursor2 = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError2({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError4({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError2({ offset });
    const position = this.position - offset;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError2({ offset });
    const position = this.position + offset;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length - 1);
    return this.bytes.subarray(position, position + length);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes) {
    this.assertPosition(this.position + bytes.length - 1);
    this.bytes.set(bytes, this.position);
    this.position += bytes.length;
  },
  pushUint8(value) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value;
    this.position++;
  },
  pushUint16(value) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value);
    this.position += 2;
  },
  pushUint24(value) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value >> 8);
    this.dataView.setUint8(this.position + 2, value & ~4294967040);
    this.position += 3;
  },
  pushUint32(value) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectByte();
    this.position++;
    return value;
  },
  readBytes(length, size7) {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectBytes(length);
    this.position += size7 ?? length;
    return value;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint8();
    this.position += 1;
    return value;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint16();
    this.position += 2;
    return value;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint24();
    this.position += 3;
    return value;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint32();
    this.position += 4;
    return value;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const count = this.getReadCount();
    this.positionReadCount.set(this.position, count + 1);
    if (count > 0)
      this.recursiveReadCount++;
  }
};
var NegativeOffsetError2 = class extends BaseError5 {
  constructor({ offset }) {
    super(`Offset \`${offset}\` cannot be negative.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.NegativeOffsetError"
    });
  }
};
var PositionOutOfBoundsError4 = class extends BaseError5 {
  constructor({ length, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.PositionOutOfBoundsError"
    });
  }
};
var RecursiveReadLimitExceededError2 = class extends BaseError5 {
  constructor({ count, limit }) {
    super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.RecursiveReadLimitExceededError"
    });
  }
};

// node_modules/@reown/appkit/node_modules/ox/_esm/core/AbiParameters.js
function encodePacked4(types, values) {
  if (types.length !== values.length)
    throw new LengthMismatchError2({
      expectedLength: types.length,
      givenLength: values.length
    });
  const data = [];
  for (let i3 = 0; i3 < types.length; i3++) {
    const type = types[i3];
    const value = values[i3];
    data.push(encodePacked4.encode(type, value));
  }
  return concat5(...data);
}
(function(encodePacked5) {
  function encode7(type, value, isArray = false) {
    if (type === "address") {
      const address = value;
      assert2(address);
      return padLeft2(address.toLowerCase(), isArray ? 32 : 0);
    }
    if (type === "string")
      return fromString5(value);
    if (type === "bytes")
      return value;
    if (type === "bool")
      return padLeft2(fromBoolean2(value), isArray ? 32 : 1);
    const intMatch = type.match(integerRegex4);
    if (intMatch) {
      const [_type, baseType, bits = "256"] = intMatch;
      const size7 = Number.parseInt(bits) / 8;
      return fromNumber2(value, {
        size: isArray ? 32 : size7,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type.match(bytesRegex4);
    if (bytesMatch) {
      const [_type, size7] = bytesMatch;
      if (Number.parseInt(size7) !== (value.length - 2) / 2)
        throw new BytesSizeMismatchError4({
          expectedSize: Number.parseInt(size7),
          value
        });
      return padRight3(value, isArray ? 32 : 0);
    }
    const arrayMatch = type.match(arrayRegex4);
    if (arrayMatch && Array.isArray(value)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (let i3 = 0; i3 < value.length; i3++) {
        data.push(encode7(childType, value[i3], true));
      }
      if (data.length === 0)
        return "0x";
      return concat5(...data);
    }
    throw new InvalidTypeError2(type);
  }
  encodePacked5.encode = encode7;
})(encodePacked4 || (encodePacked4 = {}));
var BytesSizeMismatchError4 = class extends BaseError5 {
  constructor({ expectedSize, value }) {
    super(`Size of bytes "${value}" (bytes${size6(value)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
};
var LengthMismatchError2 = class extends BaseError5 {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.LengthMismatchError"
    });
  }
};
var InvalidTypeError2 = class extends BaseError5 {
  constructor(type) {
    super(`Type \`${type}\` is not a valid ABI Type.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidTypeError"
    });
  }
};

// node_modules/@reown/appkit/node_modules/base-x/src/esm/index.js
function base2(ALPHABET4) {
  if (ALPHABET4.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j5 = 0; j5 < BASE_MAP.length; j5++) {
    BASE_MAP[j5] = 255;
  }
  for (let i3 = 0; i3 < ALPHABET4.length; i3++) {
    const x9 = ALPHABET4.charAt(i3);
    const xc2 = x9.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x9 + " is ambiguous");
    }
    BASE_MAP[xc2] = i3;
  }
  const BASE = ALPHABET4.length;
  const LEADER = ALPHABET4.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE);
  function encode7(source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size7 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size7);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i3 = 0;
      for (let it1 = size7 - 1; (carry !== 0 || i3 < length) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i3;
      pbegin++;
    }
    let it22 = size7 - length;
    while (it22 !== size7 && b58[it22] === 0) {
      it22++;
    }
    let str = LEADER.repeat(zeroes);
    for (; it22 < size7; ++it22) {
      str += ALPHABET4.charAt(b58[it22]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size7 = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size7);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i3 = 0;
      for (let it32 = size7 - 1; (carry !== 0 || i3 < length) && it32 !== -1; it32--, i3++) {
        carry += BASE * b256[it32] >>> 0;
        b256[it32] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i3;
      psz++;
    }
    let it42 = size7 - length;
    while (it42 !== size7 && b256[it42] === 0) {
      it42++;
    }
    const vch = new Uint8Array(zeroes + (size7 - it42));
    let j5 = zeroes;
    while (it42 !== size7) {
      vch[j5++] = b256[it42++];
    }
    return vch;
  }
  function decode3(string) {
    const buffer = decodeUnsafe(string);
    if (buffer) {
      return buffer;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode7,
    decodeUnsafe,
    decode: decode3
  };
}
var esm_default3 = base2;

// node_modules/@reown/appkit/node_modules/bs58/src/esm/index.js
var ALPHABET2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default4 = esm_default3(ALPHABET2);

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/dist/index.es.js
var import_elliptic2 = __toESM(require_elliptic());
var Pe2 = ":";
function Ye4(e) {
  const [t, n3] = e.split(Pe2);
  return { namespace: t, reference: n3 };
}
function Be4(e, t) {
  return e.includes(":") ? [e] : t.chains || [];
}
var Ft4 = "ReactNative";
var H4 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var Gt4 = "js";
function et3() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function ne3() {
  return !(0, import_window_getters3.getDocument)() && !!(0, import_window_getters3.getNavigator)() && navigator.product === Ft4;
}
function zr4() {
  return ne3() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android";
}
function Jr4() {
  return ne3() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios";
}
function Ae4() {
  return !et3() && !!(0, import_window_getters3.getNavigator)() && !!(0, import_window_getters3.getDocument)();
}
function ue4() {
  return ne3() ? H4.reactNative : et3() ? H4.node : Ae4() ? H4.browser : H4.unknown;
}
function Yr4() {
  var e;
  try {
    return ne3() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e = global.Application) == null ? void 0 : e.applicationId : void 0;
  } catch {
    return;
  }
}
function Wt4(e, t) {
  const n3 = new URLSearchParams(e);
  for (const r2 of Object.keys(t).sort()) if (t.hasOwnProperty(r2)) {
    const o3 = t[r2];
    o3 !== void 0 && n3.set(r2, o3);
  }
  return n3.toString();
}
function Xr3() {
  return (0, import_window_metadata2.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function zt4() {
  if (ue4() === H4.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: n3, Version: r2 } = global.Platform;
    return [n3, r2].join("-");
  }
  const e = detect();
  if (e === null) return "unknown";
  const t = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [t, e.name, e.version].join("-") : [t, e.version].join("-");
}
function Jt4() {
  var e;
  const t = ue4();
  return t === H4.browser ? [t, ((e = (0, import_window_getters3.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : t;
}
function Yt4(e, t, n3) {
  const r2 = zt4(), o3 = Jt4();
  return [[e, t].join("-"), [Gt4, n3].join("-"), r2, o3].join("/");
}
function Qr3({ protocol: e, version: t, relayUrl: n3, sdkVersion: r2, auth: o3, projectId: s, useOnCloseEvent: i3, bundleId: c6, packageName: u3 }) {
  const a2 = n3.split("?"), l5 = Yt4(e, t, r2), f10 = { auth: o3, ua: l5, projectId: s, useOnCloseEvent: i3 || void 0, packageName: u3 || void 0, bundleId: c6 || void 0 }, d5 = Wt4(a2[1] || "", f10);
  return a2[0] + "?" + d5;
}
function re4(e, t) {
  return e.filter((n3) => t.includes(n3)).length === e.length;
}
function ro4(e) {
  return Object.fromEntries(e.entries());
}
function oo3(e) {
  return new Map(Object.entries(e));
}
function ao4(e = import_time4.FIVE_MINUTES, t) {
  const n3 = (0, import_time4.toMiliseconds)(e || import_time4.FIVE_MINUTES);
  let r2, o3, s, i3;
  return { resolve: (c6) => {
    s && r2 && (clearTimeout(s), r2(c6), i3 = Promise.resolve(c6));
  }, reject: (c6) => {
    s && o3 && (clearTimeout(s), o3(c6));
  }, done: () => new Promise((c6, u3) => {
    if (i3) return c6(i3);
    s = setTimeout(() => {
      const a2 = new Error(t);
      i3 = Promise.reject(a2), u3(a2);
    }, n3), r2 = c6, o3 = u3;
  }) };
}
function uo3(e, t, n3) {
  return new Promise(async (r2, o3) => {
    const s = setTimeout(() => o3(new Error(n3)), t);
    try {
      const i3 = await e;
      r2(i3);
    } catch (i3) {
      o3(i3);
    }
    clearTimeout(s);
  });
}
function tt3(e, t) {
  if (typeof t == "string" && t.startsWith(`${e}:`)) return t;
  if (e.toLowerCase() === "topic") {
    if (typeof t != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${t}`;
  } else if (e.toLowerCase() === "id") {
    if (typeof t != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${t}`;
  }
  throw new Error(`Unknown expirer target type: ${e}`);
}
function fo3(e) {
  return tt3("topic", e);
}
function lo3(e) {
  return tt3("id", e);
}
function ho3(e) {
  const [t, n3] = e.split(":"), r2 = { id: void 0, topic: void 0 };
  if (t === "topic" && typeof n3 == "string") r2.topic = n3;
  else if (t === "id" && Number.isInteger(Number(n3))) r2.id = Number(n3);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${n3}`);
  return r2;
}
function po3(e, t) {
  return (0, import_time4.fromMiliseconds)((t || Date.now()) + (0, import_time4.toMiliseconds)(e));
}
function go3(e) {
  return Date.now() >= (0, import_time4.toMiliseconds)(e);
}
function yo3(e, t) {
  return `${e}${t ? `:${t}` : ""}`;
}
function Q3(e = [], t = []) {
  return [.../* @__PURE__ */ new Set([...e, ...t])];
}
async function mo3({ id: e, topic: t, wcDeepLink: n3 }) {
  var r2;
  try {
    if (!n3) return;
    const o3 = typeof n3 == "string" ? JSON.parse(n3) : n3, s = o3 == null ? void 0 : o3.href;
    if (typeof s != "string") return;
    const i3 = en4(s, e, t), c6 = ue4();
    if (c6 === H4.browser) {
      if (!((r2 = (0, import_window_getters3.getDocument)()) != null && r2.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      tn4(i3);
    } else c6 === H4.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(i3);
  } catch (o3) {
    console.error(o3);
  }
}
function en4(e, t, n3) {
  const r2 = `requestId=${t}&sessionTopic=${n3}`;
  e.endsWith("/") && (e = e.slice(0, -1));
  let o3 = `${e}`;
  if (e.startsWith("https://t.me")) {
    const s = e.includes("?") ? "&startapp=" : "?startapp=";
    o3 = `${o3}${s}${on4(r2, true)}`;
  } else o3 = `${o3}/wc?${r2}`;
  return o3;
}
function tn4(e) {
  let t = "_self";
  rn4() ? t = "_top" : (nn4() || e.startsWith("https://") || e.startsWith("http://")) && (t = "_blank"), window.open(e, t, "noreferrer noopener");
}
async function bo3(e, t) {
  let n3 = "";
  try {
    if (Ae4() && (n3 = localStorage.getItem(t), n3)) return n3;
    n3 = await e.getItem(t);
  } catch (r2) {
    console.error(r2);
  }
  return n3;
}
function wo3(e, t) {
  if (!e.includes(t)) return null;
  const n3 = e.split(/([&,?,=])/), r2 = n3.indexOf(t);
  return n3[r2 + 2];
}
function Eo3() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e) => {
    const t = Math.random() * 16 | 0;
    return (e === "x" ? t : t & 3 | 8).toString(16);
  });
}
function vo3() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function nn4() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function rn4() {
  try {
    return window.self !== window.top;
  } catch {
    return false;
  }
}
function on4(e, t = false) {
  const n3 = Buffer.from(e).toString("base64");
  return t ? n3.replace(/[=]/g, "") : n3;
}
function rt3(e) {
  return Buffer.from(e, "base64").toString("utf-8");
}
function xo3(e) {
  return new Promise((t) => setTimeout(t, e));
}
function Ne4(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error("positive integer expected, got " + e);
}
function Io3(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function je4(e, ...t) {
  if (!Io3(e)) throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length)) throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length);
}
function ot3(e) {
  if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Ne4(e.outputLen), Ne4(e.blockLen);
}
function me4(e, t = true) {
  if (e.destroyed) throw new Error("Hash instance has been destroyed");
  if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function sn5(e, t) {
  je4(e);
  const n3 = t.outputLen;
  if (e.length < n3) throw new Error("digestInto() expects output buffer of length at least " + n3);
}
var Ce3 = BigInt(2 ** 32 - 1);
var cn4 = BigInt(32);
function Oo3(e, t = false) {
  return t ? { h: Number(e & Ce3), l: Number(e >> cn4 & Ce3) } : { h: Number(e >> cn4 & Ce3) | 0, l: Number(e & Ce3) | 0 };
}
function Ao3(e, t = false) {
  let n3 = new Uint32Array(e.length), r2 = new Uint32Array(e.length);
  for (let o3 = 0; o3 < e.length; o3++) {
    const { h: s, l: i3 } = Oo3(e[o3], t);
    [n3[o3], r2[o3]] = [s, i3];
  }
  return [n3, r2];
}
var No3 = (e, t, n3) => e << n3 | t >>> 32 - n3;
var So3 = (e, t, n3) => t << n3 | e >>> 32 - n3;
var Uo3 = (e, t, n3) => t << n3 - 32 | e >>> 64 - n3;
var _o3 = (e, t, n3) => e << n3 - 32 | t >>> 64 - n3;
var be3 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function To3(e) {
  return new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
}
function st3(e) {
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function J6(e, t) {
  return e << 32 - t | e >>> t;
}
var an4 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function $o3(e) {
  return e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;
}
function un4(e) {
  for (let t = 0; t < e.length; t++) e[t] = $o3(e[t]);
}
function Ro3(e) {
  if (typeof e != "string") throw new Error("utf8ToBytes expected string, got " + typeof e);
  return new Uint8Array(new TextEncoder().encode(e));
}
function we4(e) {
  return typeof e == "string" && (e = Ro3(e)), je4(e), e;
}
var it3 = class {
  clone() {
    return this._cloneInto();
  }
};
function fn4(e) {
  const t = (r2) => e().update(we4(r2)).digest(), n3 = e();
  return t.outputLen = n3.outputLen, t.blockLen = n3.blockLen, t.create = () => e(), t;
}
function Se4(e = 32) {
  if (be3 && typeof be3.getRandomValues == "function") return be3.getRandomValues(new Uint8Array(e));
  if (be3 && typeof be3.randomBytes == "function") return be3.randomBytes(e);
  throw new Error("crypto.getRandomValues must be defined");
}
var ln4 = [];
var dn4 = [];
var hn4 = [];
var Po4 = BigInt(0);
var Ue5 = BigInt(1);
var Bo3 = BigInt(2);
var Lo3 = BigInt(7);
var jo3 = BigInt(256);
var Co3 = BigInt(113);
for (let e = 0, t = Ue5, n3 = 1, r2 = 0; e < 24; e++) {
  [n3, r2] = [r2, (2 * n3 + 3 * r2) % 5], ln4.push(2 * (5 * r2 + n3)), dn4.push((e + 1) * (e + 2) / 2 % 64);
  let o3 = Po4;
  for (let s = 0; s < 7; s++) t = (t << Ue5 ^ (t >> Lo3) * Co3) % jo3, t & Bo3 && (o3 ^= Ue5 << (Ue5 << BigInt(s)) - Ue5);
  hn4.push(o3);
}
var [ko3, Do3] = Ao3(hn4, true);
var pn4 = (e, t, n3) => n3 > 32 ? Uo3(e, t, n3) : No3(e, t, n3);
var gn4 = (e, t, n3) => n3 > 32 ? _o3(e, t, n3) : So3(e, t, n3);
function Mo3(e, t = 24) {
  const n3 = new Uint32Array(10);
  for (let r2 = 24 - t; r2 < 24; r2++) {
    for (let i3 = 0; i3 < 10; i3++) n3[i3] = e[i3] ^ e[i3 + 10] ^ e[i3 + 20] ^ e[i3 + 30] ^ e[i3 + 40];
    for (let i3 = 0; i3 < 10; i3 += 2) {
      const c6 = (i3 + 8) % 10, u3 = (i3 + 2) % 10, a2 = n3[u3], l5 = n3[u3 + 1], f10 = pn4(a2, l5, 1) ^ n3[c6], d5 = gn4(a2, l5, 1) ^ n3[c6 + 1];
      for (let g3 = 0; g3 < 50; g3 += 10) e[i3 + g3] ^= f10, e[i3 + g3 + 1] ^= d5;
    }
    let o3 = e[2], s = e[3];
    for (let i3 = 0; i3 < 24; i3++) {
      const c6 = dn4[i3], u3 = pn4(o3, s, c6), a2 = gn4(o3, s, c6), l5 = ln4[i3];
      o3 = e[l5], s = e[l5 + 1], e[l5] = u3, e[l5 + 1] = a2;
    }
    for (let i3 = 0; i3 < 50; i3 += 10) {
      for (let c6 = 0; c6 < 10; c6++) n3[c6] = e[i3 + c6];
      for (let c6 = 0; c6 < 10; c6++) e[i3 + c6] ^= ~n3[(c6 + 2) % 10] & n3[(c6 + 4) % 10];
    }
    e[0] ^= ko3[r2], e[1] ^= Do3[r2];
  }
  n3.fill(0);
}
var Lt4 = class _Lt extends it3 {
  constructor(t, n3, r2, o3 = false, s = 24) {
    if (super(), this.blockLen = t, this.suffix = n3, this.outputLen = r2, this.enableXOF = o3, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, Ne4(r2), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = To3(this.state);
  }
  keccak() {
    an4 || un4(this.state32), Mo3(this.state32, this.rounds), an4 || un4(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    me4(this);
    const { blockLen: n3, state: r2 } = this;
    t = we4(t);
    const o3 = t.length;
    for (let s = 0; s < o3; ) {
      const i3 = Math.min(n3 - this.pos, o3 - s);
      for (let c6 = 0; c6 < i3; c6++) r2[this.pos++] ^= t[s++];
      this.pos === n3 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: t, suffix: n3, pos: r2, blockLen: o3 } = this;
    t[r2] ^= n3, (n3 & 128) !== 0 && r2 === o3 - 1 && this.keccak(), t[o3 - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    me4(this, false), je4(t), this.finish();
    const n3 = this.state, { blockLen: r2 } = this;
    for (let o3 = 0, s = t.length; o3 < s; ) {
      this.posOut >= r2 && this.keccak();
      const i3 = Math.min(r2 - this.posOut, s - o3);
      t.set(n3.subarray(this.posOut, this.posOut + i3), o3), this.posOut += i3, o3 += i3;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return Ne4(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (sn5(t, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: n3, suffix: r2, outputLen: o3, rounds: s, enableXOF: i3 } = this;
    return t || (t = new _Lt(n3, r2, o3, i3, s)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = s, t.suffix = r2, t.outputLen = o3, t.enableXOF = i3, t.destroyed = this.destroyed, t;
  }
};
var Vo3 = (e, t, n3) => fn4(() => new Lt4(t, e, n3));
var Ho3 = Vo3(1, 136, 256 / 8);
var Ko3 = "https://rpc.walletconnect.org/v1";
function ct3(e) {
  const t = `Ethereum Signed Message:
${e.length}`, n3 = new TextEncoder().encode(t + e);
  return "0x" + Buffer.from(Ho3(n3)).toString("hex");
}
async function yn4(e, t, n3, r2, o3, s) {
  switch (n3.t) {
    case "eip191":
      return await mn4(e, t, n3.s);
    case "eip1271":
      return await bn4(e, t, n3.s, r2, o3, s);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n3.t}`);
  }
}
async function mn4(e, t, n3) {
  return (await recoverAddress2({ hash: ct3(t), signature: n3 })).toLowerCase() === e.toLowerCase();
}
async function bn4(e, t, n3, r2, o3, s) {
  const i3 = Ye4(r2);
  if (!i3.namespace || !i3.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r2}`);
  try {
    const c6 = "0x1626ba7e", u3 = "0000000000000000000000000000000000000000000000000000000000000040", a2 = "0000000000000000000000000000000000000000000000000000000000000041", l5 = n3.substring(2), f10 = ct3(t).substring(2), d5 = c6 + f10 + u3 + a2 + l5, g3 = await fetch(`${s || Ko3}/?chainId=${r2}&projectId=${o3}`, { method: "POST", body: JSON.stringify({ id: Fo3(), jsonrpc: "2.0", method: "eth_call", params: [{ to: e, data: d5 }, "latest"] }) }), { result: y9 } = await g3.json();
    return y9 ? y9.slice(0, c6.length).toLowerCase() === c6.toLowerCase() : false;
  } catch (c6) {
    return console.error("isValidEip1271Signature: ", c6), false;
  }
}
function Fo3() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function qo3(e) {
  const t = atob(e), n3 = new Uint8Array(t.length);
  for (let i3 = 0; i3 < t.length; i3++) n3[i3] = t.charCodeAt(i3);
  const r2 = n3[0];
  if (r2 === 0) throw new Error("No signatures found");
  const o3 = 1 + r2 * 64;
  if (n3.length < o3) throw new Error("Transaction data too short for claimed signature count");
  if (n3.length < 100) throw new Error("Transaction too short");
  const s = Buffer.from(e, "base64").slice(1, 65);
  return esm_default4.encode(s);
}
var Go3 = Object.defineProperty;
var Wo3 = Object.defineProperties;
var zo3 = Object.getOwnPropertyDescriptors;
var wn4 = Object.getOwnPropertySymbols;
var Jo3 = Object.prototype.hasOwnProperty;
var Yo3 = Object.prototype.propertyIsEnumerable;
var En4 = (e, t, n3) => t in e ? Go3(e, t, { enumerable: true, configurable: true, writable: true, value: n3 }) : e[t] = n3;
var at3 = (e, t) => {
  for (var n3 in t || (t = {})) Jo3.call(t, n3) && En4(e, n3, t[n3]);
  if (wn4) for (var n3 of wn4(t)) Yo3.call(t, n3) && En4(e, n3, t[n3]);
  return e;
};
var vn4 = (e, t) => Wo3(e, zo3(t));
var Xo2 = "did:pkh:";
var ke5 = (e) => e == null ? void 0 : e.split(":");
var xn4 = (e) => {
  const t = e && ke5(e);
  if (t) return e.includes(Xo2) ? t[3] : t[1];
};
var In4 = (e) => {
  const t = e && ke5(e);
  if (t) return t[2] + ":" + t[3];
};
var ut4 = (e) => {
  const t = e && ke5(e);
  if (t) return t.pop();
};
async function Zo2(e) {
  const { cacao: t, projectId: n3 } = e, { s: r2, p: o3 } = t, s = On4(o3, o3.iss), i3 = ut4(o3.iss);
  return await yn4(i3, s, r2, In4(o3.iss), n3);
}
var On4 = (e, t) => {
  const n3 = `${e.domain} wants you to sign in with your Ethereum account:`, r2 = ut4(t);
  if (!e.aud && !e.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let o3 = e.statement || void 0;
  const s = `URI: ${e.aud || e.uri}`, i3 = `Version: ${e.version}`, c6 = `Chain ID: ${xn4(t)}`, u3 = `Nonce: ${e.nonce}`, a2 = `Issued At: ${e.iat}`, l5 = e.exp ? `Expiration Time: ${e.exp}` : void 0, f10 = e.nbf ? `Not Before: ${e.nbf}` : void 0, d5 = e.requestId ? `Request ID: ${e.requestId}` : void 0, g3 = e.resources ? `Resources:${e.resources.map((h6) => `
- ${h6}`).join("")}` : void 0, y9 = Me5(e.resources);
  if (y9) {
    const h6 = oe3(y9);
    o3 = dt4(o3, h6);
  }
  return [n3, r2, "", o3, "", s, i3, c6, u3, a2, l5, f10, d5, g3].filter((h6) => h6 != null).join(`
`);
};
function Un4(e) {
  return Buffer.from(JSON.stringify(e)).toString("base64");
}
function _n4(e) {
  return JSON.parse(Buffer.from(e, "base64").toString("utf-8"));
}
function Y4(e) {
  if (!e) throw new Error("No recap provided, value is undefined");
  if (!e.att) throw new Error("No `att` property found");
  const t = Object.keys(e.att);
  if (!(t != null && t.length)) throw new Error("No resources found in `att` property");
  t.forEach((n3) => {
    const r2 = e.att[n3];
    if (Array.isArray(r2)) throw new Error(`Resource must be an object: ${n3}`);
    if (typeof r2 != "object") throw new Error(`Resource must be an object: ${n3}`);
    if (!Object.keys(r2).length) throw new Error(`Resource object is empty: ${n3}`);
    Object.keys(r2).forEach((o3) => {
      const s = r2[o3];
      if (!Array.isArray(s)) throw new Error(`Ability limits ${o3} must be an array of objects, found: ${s}`);
      if (!s.length) throw new Error(`Value of ${o3} is empty array, must be an array with objects`);
      s.forEach((i3) => {
        if (typeof i3 != "object") throw new Error(`Ability limits (${o3}) must be an array of objects, found: ${i3}`);
      });
    });
  });
}
function Tn4(e, t, n3, r2 = {}) {
  return n3 == null ? void 0 : n3.sort((o3, s) => o3.localeCompare(s)), { att: { [e]: ft3(t, n3, r2) } };
}
function ft3(e, t, n3 = {}) {
  t = t == null ? void 0 : t.sort((o3, s) => o3.localeCompare(s));
  const r2 = t.map((o3) => ({ [`${e}/${o3}`]: [n3] }));
  return Object.assign({}, ...r2);
}
function De4(e) {
  return Y4(e), `urn:recap:${Un4(e).replace(/=/g, "")}`;
}
function oe3(e) {
  const t = _n4(e.replace("urn:recap:", ""));
  return Y4(t), t;
}
function rs3(e, t, n3) {
  const r2 = Tn4(e, t, n3);
  return De4(r2);
}
function lt3(e) {
  return e && e.includes("urn:recap:");
}
function os3(e, t) {
  const n3 = oe3(e), r2 = oe3(t), o3 = Rn4(n3, r2);
  return De4(o3);
}
function Rn4(e, t) {
  Y4(e), Y4(t);
  const n3 = Object.keys(e.att).concat(Object.keys(t.att)).sort((o3, s) => o3.localeCompare(s)), r2 = { att: {} };
  return n3.forEach((o3) => {
    var s, i3;
    Object.keys(((s = e.att) == null ? void 0 : s[o3]) || {}).concat(Object.keys(((i3 = t.att) == null ? void 0 : i3[o3]) || {})).sort((c6, u3) => c6.localeCompare(u3)).forEach((c6) => {
      var u3, a2;
      r2.att[o3] = vn4(at3({}, r2.att[o3]), { [c6]: ((u3 = e.att[o3]) == null ? void 0 : u3[c6]) || ((a2 = t.att[o3]) == null ? void 0 : a2[c6]) });
    });
  }), r2;
}
function dt4(e = "", t) {
  Y4(t);
  const n3 = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (e.includes(n3)) return e;
  const r2 = [];
  let o3 = 0;
  Object.keys(t.att).forEach((c6) => {
    const u3 = Object.keys(t.att[c6]).map((f10) => ({ ability: f10.split("/")[0], action: f10.split("/")[1] }));
    u3.sort((f10, d5) => f10.action.localeCompare(d5.action));
    const a2 = {};
    u3.forEach((f10) => {
      a2[f10.ability] || (a2[f10.ability] = []), a2[f10.ability].push(f10.action);
    });
    const l5 = Object.keys(a2).map((f10) => (o3++, `(${o3}) '${f10}': '${a2[f10].join("', '")}' for '${c6}'.`));
    r2.push(l5.join(", ").replace(".,", "."));
  });
  const s = r2.join(" "), i3 = `${n3}${s}`;
  return `${e ? e + " " : ""}${i3}`;
}
function ss3(e) {
  var t;
  const n3 = oe3(e);
  Y4(n3);
  const r2 = (t = n3.att) == null ? void 0 : t.eip155;
  return r2 ? Object.keys(r2).map((o3) => o3.split("/")[1]) : [];
}
function is3(e) {
  const t = oe3(e);
  Y4(t);
  const n3 = [];
  return Object.values(t.att).forEach((r2) => {
    Object.values(r2).forEach((o3) => {
      var s;
      (s = o3 == null ? void 0 : o3[0]) != null && s.chains && n3.push(o3[0].chains);
    });
  }), [...new Set(n3.flat())];
}
function Me5(e) {
  if (!e) return;
  const t = e == null ? void 0 : e[e.length - 1];
  return lt3(t) ? t : void 0;
}
function ht4(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error("positive integer expected, got " + e);
}
function Bn4(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function F4(e, ...t) {
  if (!Bn4(e)) throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length)) throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length);
}
function Ln4(e, t = true) {
  if (e.destroyed) throw new Error("Hash instance has been destroyed");
  if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function cs4(e, t) {
  F4(e);
  const n3 = t.outputLen;
  if (e.length < n3) throw new Error("digestInto() expects output buffer of length at least " + n3);
}
function jn4(e) {
  if (typeof e != "boolean") throw new Error(`boolean expected, not ${e}`);
}
var se4 = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
var as3 = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
var us3 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!us3) throw new Error("Non little-endian hardware is not supported");
function fs4(e) {
  if (typeof e != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(e));
}
function pt4(e) {
  if (typeof e == "string") e = fs4(e);
  else if (Bn4(e)) e = gt3(e);
  else throw new Error("Uint8Array expected, got " + typeof e);
  return e;
}
function ls4(e, t) {
  if (t == null || typeof t != "object") throw new Error("options must be defined");
  return Object.assign(e, t);
}
function ds3(e, t) {
  if (e.length !== t.length) return false;
  let n3 = 0;
  for (let r2 = 0; r2 < e.length; r2++) n3 |= e[r2] ^ t[r2];
  return n3 === 0;
}
var hs3 = (e, t) => {
  function n3(r2, ...o3) {
    if (F4(r2), e.nonceLength !== void 0) {
      const l5 = o3[0];
      if (!l5) throw new Error("nonce / iv required");
      e.varSizeNonce ? F4(l5) : F4(l5, e.nonceLength);
    }
    const s = e.tagLength;
    s && o3[1] !== void 0 && F4(o3[1]);
    const i3 = t(r2, ...o3), c6 = (l5, f10) => {
      if (f10 !== void 0) {
        if (l5 !== 2) throw new Error("cipher output not supported");
        F4(f10);
      }
    };
    let u3 = false;
    return { encrypt(l5, f10) {
      if (u3) throw new Error("cannot encrypt() twice with same key + nonce");
      return u3 = true, F4(l5), c6(i3.encrypt.length, f10), i3.encrypt(l5, f10);
    }, decrypt(l5, f10) {
      if (F4(l5), s && l5.length < s) throw new Error("invalid ciphertext length: smaller than tagLength=" + s);
      return c6(i3.decrypt.length, f10), i3.decrypt(l5, f10);
    } };
  }
  return Object.assign(n3, e), n3;
};
function Cn4(e, t, n3 = true) {
  if (t === void 0) return new Uint8Array(e);
  if (t.length !== e) throw new Error("invalid output length, expected " + e + ", got: " + t.length);
  if (n3 && !ps3(t)) throw new Error("invalid output, must be aligned");
  return t;
}
function kn4(e, t, n3, r2) {
  if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, n3, r2);
  const o3 = BigInt(32), s = BigInt(4294967295), i3 = Number(n3 >> o3 & s), c6 = Number(n3 & s), u3 = r2 ? 4 : 0, a2 = r2 ? 0 : 4;
  e.setUint32(t + u3, i3, r2), e.setUint32(t + a2, c6, r2);
}
function ps3(e) {
  return e.byteOffset % 4 === 0;
}
function gt3(e) {
  return Uint8Array.from(e);
}
function Ee5(...e) {
  for (let t = 0; t < e.length; t++) e[t].fill(0);
}
var Dn4 = (e) => Uint8Array.from(e.split("").map((t) => t.charCodeAt(0)));
var gs3 = Dn4("expand 16-byte k");
var ys3 = Dn4("expand 32-byte k");
var ms3 = se4(gs3);
var bs4 = se4(ys3);
function x7(e, t) {
  return e << t | e >>> 32 - t;
}
function yt3(e) {
  return e.byteOffset % 4 === 0;
}
var Ve4 = 64;
var ws3 = 16;
var Mn4 = 2 ** 32 - 1;
var Vn4 = new Uint32Array();
function Es3(e, t, n3, r2, o3, s, i3, c6) {
  const u3 = o3.length, a2 = new Uint8Array(Ve4), l5 = se4(a2), f10 = yt3(o3) && yt3(s), d5 = f10 ? se4(o3) : Vn4, g3 = f10 ? se4(s) : Vn4;
  for (let y9 = 0; y9 < u3; i3++) {
    if (e(t, n3, r2, l5, i3, c6), i3 >= Mn4) throw new Error("arx: counter overflow");
    const h6 = Math.min(Ve4, u3 - y9);
    if (f10 && h6 === Ve4) {
      const m3 = y9 / 4;
      if (y9 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let L5 = 0, b4; L5 < ws3; L5++) b4 = m3 + L5, g3[b4] = d5[b4] ^ l5[L5];
      y9 += Ve4;
      continue;
    }
    for (let m3 = 0, L5; m3 < h6; m3++) L5 = y9 + m3, s[L5] = o3[L5] ^ a2[m3];
    y9 += h6;
  }
}
function vs4(e, t) {
  const { allowShortKeys: n3, extendNonceFn: r2, counterLength: o3, counterRight: s, rounds: i3 } = ls4({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, t);
  if (typeof e != "function") throw new Error("core must be a function");
  return ht4(o3), ht4(i3), jn4(s), jn4(n3), (c6, u3, a2, l5, f10 = 0) => {
    F4(c6), F4(u3), F4(a2);
    const d5 = a2.length;
    if (l5 === void 0 && (l5 = new Uint8Array(d5)), F4(l5), ht4(f10), f10 < 0 || f10 >= Mn4) throw new Error("arx: counter overflow");
    if (l5.length < d5) throw new Error(`arx: output (${l5.length}) is shorter than data (${d5})`);
    const g3 = [];
    let y9 = c6.length, h6, m3;
    if (y9 === 32) g3.push(h6 = gt3(c6)), m3 = bs4;
    else if (y9 === 16 && n3) h6 = new Uint8Array(32), h6.set(c6), h6.set(c6, 16), m3 = ms3, g3.push(h6);
    else throw new Error(`arx: invalid 32-byte key, got length=${y9}`);
    yt3(u3) || g3.push(u3 = gt3(u3));
    const L5 = se4(h6);
    if (r2) {
      if (u3.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r2(m3, L5, se4(u3.subarray(0, 16)), L5), u3 = u3.subarray(16);
    }
    const b4 = 16 - o3;
    if (b4 !== u3.length) throw new Error(`arx: nonce must be ${b4} or 16 bytes`);
    if (b4 !== 12) {
      const O8 = new Uint8Array(12);
      O8.set(u3, s ? 0 : 12 - u3.length), u3 = O8, g3.push(u3);
    }
    const _7 = se4(u3);
    return Es3(e, m3, L5, _7, a2, l5, f10, i3), Ee5(...g3), l5;
  };
}
var M6 = (e, t) => e[t++] & 255 | (e[t++] & 255) << 8;
var xs4 = class {
  constructor(t) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, t = pt4(t), F4(t, 32);
    const n3 = M6(t, 0), r2 = M6(t, 2), o3 = M6(t, 4), s = M6(t, 6), i3 = M6(t, 8), c6 = M6(t, 10), u3 = M6(t, 12), a2 = M6(t, 14);
    this.r[0] = n3 & 8191, this.r[1] = (n3 >>> 13 | r2 << 3) & 8191, this.r[2] = (r2 >>> 10 | o3 << 6) & 7939, this.r[3] = (o3 >>> 7 | s << 9) & 8191, this.r[4] = (s >>> 4 | i3 << 12) & 255, this.r[5] = i3 >>> 1 & 8190, this.r[6] = (i3 >>> 14 | c6 << 2) & 8191, this.r[7] = (c6 >>> 11 | u3 << 5) & 8065, this.r[8] = (u3 >>> 8 | a2 << 8) & 8191, this.r[9] = a2 >>> 5 & 127;
    for (let l5 = 0; l5 < 8; l5++) this.pad[l5] = M6(t, 16 + 2 * l5);
  }
  process(t, n3, r2 = false) {
    const o3 = r2 ? 0 : 2048, { h: s, r: i3 } = this, c6 = i3[0], u3 = i3[1], a2 = i3[2], l5 = i3[3], f10 = i3[4], d5 = i3[5], g3 = i3[6], y9 = i3[7], h6 = i3[8], m3 = i3[9], L5 = M6(t, n3 + 0), b4 = M6(t, n3 + 2), _7 = M6(t, n3 + 4), O8 = M6(t, n3 + 6), k8 = M6(t, n3 + 8), E9 = M6(t, n3 + 10), B5 = M6(t, n3 + 12), j5 = M6(t, n3 + 14);
    let v6 = s[0] + (L5 & 8191), I5 = s[1] + ((L5 >>> 13 | b4 << 3) & 8191), w4 = s[2] + ((b4 >>> 10 | _7 << 6) & 8191), R6 = s[3] + ((_7 >>> 7 | O8 << 9) & 8191), A6 = s[4] + ((O8 >>> 4 | k8 << 12) & 8191), T4 = s[5] + (k8 >>> 1 & 8191), N7 = s[6] + ((k8 >>> 14 | E9 << 2) & 8191), S7 = s[7] + ((E9 >>> 11 | B5 << 5) & 8191), U3 = s[8] + ((B5 >>> 8 | j5 << 8) & 8191), $7 = s[9] + (j5 >>> 5 | o3), p6 = 0, C7 = p6 + v6 * c6 + I5 * (5 * m3) + w4 * (5 * h6) + R6 * (5 * y9) + A6 * (5 * g3);
    p6 = C7 >>> 13, C7 &= 8191, C7 += T4 * (5 * d5) + N7 * (5 * f10) + S7 * (5 * l5) + U3 * (5 * a2) + $7 * (5 * u3), p6 += C7 >>> 13, C7 &= 8191;
    let D6 = p6 + v6 * u3 + I5 * c6 + w4 * (5 * m3) + R6 * (5 * h6) + A6 * (5 * y9);
    p6 = D6 >>> 13, D6 &= 8191, D6 += T4 * (5 * g3) + N7 * (5 * d5) + S7 * (5 * f10) + U3 * (5 * l5) + $7 * (5 * a2), p6 += D6 >>> 13, D6 &= 8191;
    let P6 = p6 + v6 * a2 + I5 * u3 + w4 * c6 + R6 * (5 * m3) + A6 * (5 * h6);
    p6 = P6 >>> 13, P6 &= 8191, P6 += T4 * (5 * y9) + N7 * (5 * g3) + S7 * (5 * d5) + U3 * (5 * f10) + $7 * (5 * l5), p6 += P6 >>> 13, P6 &= 8191;
    let G5 = p6 + v6 * l5 + I5 * a2 + w4 * u3 + R6 * c6 + A6 * (5 * m3);
    p6 = G5 >>> 13, G5 &= 8191, G5 += T4 * (5 * h6) + N7 * (5 * y9) + S7 * (5 * g3) + U3 * (5 * d5) + $7 * (5 * f10), p6 += G5 >>> 13, G5 &= 8191;
    let X2 = p6 + v6 * f10 + I5 * l5 + w4 * a2 + R6 * u3 + A6 * c6;
    p6 = X2 >>> 13, X2 &= 8191, X2 += T4 * (5 * m3) + N7 * (5 * h6) + S7 * (5 * y9) + U3 * (5 * g3) + $7 * (5 * d5), p6 += X2 >>> 13, X2 &= 8191;
    let Z4 = p6 + v6 * d5 + I5 * f10 + w4 * l5 + R6 * a2 + A6 * u3;
    p6 = Z4 >>> 13, Z4 &= 8191, Z4 += T4 * c6 + N7 * (5 * m3) + S7 * (5 * h6) + U3 * (5 * y9) + $7 * (5 * g3), p6 += Z4 >>> 13, Z4 &= 8191;
    let he5 = p6 + v6 * g3 + I5 * d5 + w4 * f10 + R6 * l5 + A6 * a2;
    p6 = he5 >>> 13, he5 &= 8191, he5 += T4 * u3 + N7 * c6 + S7 * (5 * m3) + U3 * (5 * h6) + $7 * (5 * y9), p6 += he5 >>> 13, he5 &= 8191;
    let pe5 = p6 + v6 * y9 + I5 * g3 + w4 * d5 + R6 * f10 + A6 * l5;
    p6 = pe5 >>> 13, pe5 &= 8191, pe5 += T4 * a2 + N7 * u3 + S7 * c6 + U3 * (5 * m3) + $7 * (5 * h6), p6 += pe5 >>> 13, pe5 &= 8191;
    let ge3 = p6 + v6 * h6 + I5 * y9 + w4 * g3 + R6 * d5 + A6 * f10;
    p6 = ge3 >>> 13, ge3 &= 8191, ge3 += T4 * l5 + N7 * a2 + S7 * u3 + U3 * c6 + $7 * (5 * m3), p6 += ge3 >>> 13, ge3 &= 8191;
    let ye5 = p6 + v6 * m3 + I5 * h6 + w4 * y9 + R6 * g3 + A6 * d5;
    p6 = ye5 >>> 13, ye5 &= 8191, ye5 += T4 * f10 + N7 * l5 + S7 * a2 + U3 * u3 + $7 * c6, p6 += ye5 >>> 13, ye5 &= 8191, p6 = (p6 << 2) + p6 | 0, p6 = p6 + C7 | 0, C7 = p6 & 8191, p6 = p6 >>> 13, D6 += p6, s[0] = C7, s[1] = D6, s[2] = P6, s[3] = G5, s[4] = X2, s[5] = Z4, s[6] = he5, s[7] = pe5, s[8] = ge3, s[9] = ye5;
  }
  finalize() {
    const { h: t, pad: n3 } = this, r2 = new Uint16Array(10);
    let o3 = t[1] >>> 13;
    t[1] &= 8191;
    for (let c6 = 2; c6 < 10; c6++) t[c6] += o3, o3 = t[c6] >>> 13, t[c6] &= 8191;
    t[0] += o3 * 5, o3 = t[0] >>> 13, t[0] &= 8191, t[1] += o3, o3 = t[1] >>> 13, t[1] &= 8191, t[2] += o3, r2[0] = t[0] + 5, o3 = r2[0] >>> 13, r2[0] &= 8191;
    for (let c6 = 1; c6 < 10; c6++) r2[c6] = t[c6] + o3, o3 = r2[c6] >>> 13, r2[c6] &= 8191;
    r2[9] -= 8192;
    let s = (o3 ^ 1) - 1;
    for (let c6 = 0; c6 < 10; c6++) r2[c6] &= s;
    s = ~s;
    for (let c6 = 0; c6 < 10; c6++) t[c6] = t[c6] & s | r2[c6];
    t[0] = (t[0] | t[1] << 13) & 65535, t[1] = (t[1] >>> 3 | t[2] << 10) & 65535, t[2] = (t[2] >>> 6 | t[3] << 7) & 65535, t[3] = (t[3] >>> 9 | t[4] << 4) & 65535, t[4] = (t[4] >>> 12 | t[5] << 1 | t[6] << 14) & 65535, t[5] = (t[6] >>> 2 | t[7] << 11) & 65535, t[6] = (t[7] >>> 5 | t[8] << 8) & 65535, t[7] = (t[8] >>> 8 | t[9] << 5) & 65535;
    let i3 = t[0] + n3[0];
    t[0] = i3 & 65535;
    for (let c6 = 1; c6 < 8; c6++) i3 = (t[c6] + n3[c6] | 0) + (i3 >>> 16) | 0, t[c6] = i3 & 65535;
    Ee5(r2);
  }
  update(t) {
    Ln4(this);
    const { buffer: n3, blockLen: r2 } = this;
    t = pt4(t);
    const o3 = t.length;
    for (let s = 0; s < o3; ) {
      const i3 = Math.min(r2 - this.pos, o3 - s);
      if (i3 === r2) {
        for (; r2 <= o3 - s; s += r2) this.process(t, s);
        continue;
      }
      n3.set(t.subarray(s, s + i3), this.pos), this.pos += i3, s += i3, this.pos === r2 && (this.process(n3, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Ee5(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(t) {
    Ln4(this), cs4(t, this), this.finished = true;
    const { buffer: n3, h: r2 } = this;
    let { pos: o3 } = this;
    if (o3) {
      for (n3[o3++] = 1; o3 < 16; o3++) n3[o3] = 0;
      this.process(n3, 0, true);
    }
    this.finalize();
    let s = 0;
    for (let i3 = 0; i3 < 8; i3++) t[s++] = r2[i3] >>> 0, t[s++] = r2[i3] >>> 8;
    return t;
  }
  digest() {
    const { buffer: t, outputLen: n3 } = this;
    this.digestInto(t);
    const r2 = t.slice(0, n3);
    return this.destroy(), r2;
  }
};
function Is4(e) {
  const t = (r2, o3) => e(o3).update(pt4(r2)).digest(), n3 = e(new Uint8Array(32));
  return t.outputLen = n3.outputLen, t.blockLen = n3.blockLen, t.create = (r2) => e(r2), t;
}
var Os4 = Is4((e) => new xs4(e));
function As4(e, t, n3, r2, o3, s = 20) {
  let i3 = e[0], c6 = e[1], u3 = e[2], a2 = e[3], l5 = t[0], f10 = t[1], d5 = t[2], g3 = t[3], y9 = t[4], h6 = t[5], m3 = t[6], L5 = t[7], b4 = o3, _7 = n3[0], O8 = n3[1], k8 = n3[2], E9 = i3, B5 = c6, j5 = u3, v6 = a2, I5 = l5, w4 = f10, R6 = d5, A6 = g3, T4 = y9, N7 = h6, S7 = m3, U3 = L5, $7 = b4, p6 = _7, C7 = O8, D6 = k8;
  for (let G5 = 0; G5 < s; G5 += 2) E9 = E9 + I5 | 0, $7 = x7($7 ^ E9, 16), T4 = T4 + $7 | 0, I5 = x7(I5 ^ T4, 12), E9 = E9 + I5 | 0, $7 = x7($7 ^ E9, 8), T4 = T4 + $7 | 0, I5 = x7(I5 ^ T4, 7), B5 = B5 + w4 | 0, p6 = x7(p6 ^ B5, 16), N7 = N7 + p6 | 0, w4 = x7(w4 ^ N7, 12), B5 = B5 + w4 | 0, p6 = x7(p6 ^ B5, 8), N7 = N7 + p6 | 0, w4 = x7(w4 ^ N7, 7), j5 = j5 + R6 | 0, C7 = x7(C7 ^ j5, 16), S7 = S7 + C7 | 0, R6 = x7(R6 ^ S7, 12), j5 = j5 + R6 | 0, C7 = x7(C7 ^ j5, 8), S7 = S7 + C7 | 0, R6 = x7(R6 ^ S7, 7), v6 = v6 + A6 | 0, D6 = x7(D6 ^ v6, 16), U3 = U3 + D6 | 0, A6 = x7(A6 ^ U3, 12), v6 = v6 + A6 | 0, D6 = x7(D6 ^ v6, 8), U3 = U3 + D6 | 0, A6 = x7(A6 ^ U3, 7), E9 = E9 + w4 | 0, D6 = x7(D6 ^ E9, 16), S7 = S7 + D6 | 0, w4 = x7(w4 ^ S7, 12), E9 = E9 + w4 | 0, D6 = x7(D6 ^ E9, 8), S7 = S7 + D6 | 0, w4 = x7(w4 ^ S7, 7), B5 = B5 + R6 | 0, $7 = x7($7 ^ B5, 16), U3 = U3 + $7 | 0, R6 = x7(R6 ^ U3, 12), B5 = B5 + R6 | 0, $7 = x7($7 ^ B5, 8), U3 = U3 + $7 | 0, R6 = x7(R6 ^ U3, 7), j5 = j5 + A6 | 0, p6 = x7(p6 ^ j5, 16), T4 = T4 + p6 | 0, A6 = x7(A6 ^ T4, 12), j5 = j5 + A6 | 0, p6 = x7(p6 ^ j5, 8), T4 = T4 + p6 | 0, A6 = x7(A6 ^ T4, 7), v6 = v6 + I5 | 0, C7 = x7(C7 ^ v6, 16), N7 = N7 + C7 | 0, I5 = x7(I5 ^ N7, 12), v6 = v6 + I5 | 0, C7 = x7(C7 ^ v6, 8), N7 = N7 + C7 | 0, I5 = x7(I5 ^ N7, 7);
  let P6 = 0;
  r2[P6++] = i3 + E9 | 0, r2[P6++] = c6 + B5 | 0, r2[P6++] = u3 + j5 | 0, r2[P6++] = a2 + v6 | 0, r2[P6++] = l5 + I5 | 0, r2[P6++] = f10 + w4 | 0, r2[P6++] = d5 + R6 | 0, r2[P6++] = g3 + A6 | 0, r2[P6++] = y9 + T4 | 0, r2[P6++] = h6 + N7 | 0, r2[P6++] = m3 + S7 | 0, r2[P6++] = L5 + U3 | 0, r2[P6++] = b4 + $7 | 0, r2[P6++] = _7 + p6 | 0, r2[P6++] = O8 + C7 | 0, r2[P6++] = k8 + D6 | 0;
}
var Ns4 = vs4(As4, { counterRight: false, counterLength: 4, allowShortKeys: false });
var Ss3 = new Uint8Array(16);
var Hn4 = (e, t) => {
  e.update(t);
  const n3 = t.length % 16;
  n3 && e.update(Ss3.subarray(n3));
};
var Us3 = new Uint8Array(32);
function Kn4(e, t, n3, r2, o3) {
  const s = e(t, n3, Us3), i3 = Os4.create(s);
  o3 && Hn4(i3, o3), Hn4(i3, r2);
  const c6 = new Uint8Array(16), u3 = as3(c6);
  kn4(u3, 0, BigInt(o3 ? o3.length : 0), true), kn4(u3, 8, BigInt(r2.length), true), i3.update(c6);
  const a2 = i3.digest();
  return Ee5(s, c6), a2;
}
var _s3 = (e) => (t, n3, r2) => ({ encrypt(s, i3) {
  const c6 = s.length;
  i3 = Cn4(c6 + 16, i3, false), i3.set(s);
  const u3 = i3.subarray(0, -16);
  e(t, n3, u3, u3, 1);
  const a2 = Kn4(e, t, n3, u3, r2);
  return i3.set(a2, c6), Ee5(a2), i3;
}, decrypt(s, i3) {
  i3 = Cn4(s.length - 16, i3, false);
  const c6 = s.subarray(0, -16), u3 = s.subarray(-16), a2 = Kn4(e, t, n3, c6, r2);
  if (!ds3(u3, a2)) throw new Error("invalid tag");
  return i3.set(s.subarray(0, -16)), e(t, n3, i3, i3, 1), Ee5(a2), i3;
} });
var Fn4 = hs3({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _s3(Ns4));
var qn4 = class extends it3 {
  constructor(t, n3) {
    super(), this.finished = false, this.destroyed = false, ot3(t);
    const r2 = we4(n3);
    if (this.iHash = t.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o3 = this.blockLen, s = new Uint8Array(o3);
    s.set(r2.length > o3 ? t.create().update(r2).digest() : r2);
    for (let i3 = 0; i3 < s.length; i3++) s[i3] ^= 54;
    this.iHash.update(s), this.oHash = t.create();
    for (let i3 = 0; i3 < s.length; i3++) s[i3] ^= 106;
    this.oHash.update(s), s.fill(0);
  }
  update(t) {
    return me4(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    me4(this), je4(t, this.outputLen), this.finished = true, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n3, iHash: r2, finished: o3, destroyed: s, blockLen: i3, outputLen: c6 } = this;
    return t = t, t.finished = o3, t.destroyed = s, t.blockLen = i3, t.outputLen = c6, t.oHash = n3._cloneInto(t.oHash), t.iHash = r2._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var mt4 = (e, t, n3) => new qn4(e, t).update(n3).digest();
mt4.create = (e, t) => new qn4(e, t);
function Ts4(e, t, n3) {
  return ot3(e), n3 === void 0 && (n3 = new Uint8Array(e.outputLen)), mt4(e, we4(n3), we4(t));
}
var bt2 = new Uint8Array([0]);
var Gn4 = new Uint8Array();
function $s3(e, t, n3, r2 = 32) {
  if (ot3(e), Ne4(r2), r2 > 255 * e.outputLen) throw new Error("Length should be <= 255*HashLen");
  const o3 = Math.ceil(r2 / e.outputLen);
  n3 === void 0 && (n3 = Gn4);
  const s = new Uint8Array(o3 * e.outputLen), i3 = mt4.create(e, t), c6 = i3._cloneInto(), u3 = new Uint8Array(i3.outputLen);
  for (let a2 = 0; a2 < o3; a2++) bt2[0] = a2 + 1, c6.update(a2 === 0 ? Gn4 : u3).update(n3).update(bt2).digestInto(u3), s.set(u3, e.outputLen * a2), i3._cloneInto(c6);
  return i3.destroy(), c6.destroy(), u3.fill(0), bt2.fill(0), s.slice(0, r2);
}
var Rs4 = (e, t, n3, r2, o3) => $s3(e, Ts4(e, t, n3), r2, o3);
function Ps4(e, t, n3, r2) {
  if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, n3, r2);
  const o3 = BigInt(32), s = BigInt(4294967295), i3 = Number(n3 >> o3 & s), c6 = Number(n3 & s), u3 = r2 ? 4 : 0, a2 = r2 ? 0 : 4;
  e.setUint32(t + u3, i3, r2), e.setUint32(t + a2, c6, r2);
}
function Bs3(e, t, n3) {
  return e & t ^ ~e & n3;
}
function Ls5(e, t, n3) {
  return e & t ^ e & n3 ^ t & n3;
}
var js4 = class extends it3 {
  constructor(t, n3, r2, o3) {
    super(), this.blockLen = t, this.outputLen = n3, this.padOffset = r2, this.isLE = o3, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t), this.view = st3(this.buffer);
  }
  update(t) {
    me4(this);
    const { view: n3, buffer: r2, blockLen: o3 } = this;
    t = we4(t);
    const s = t.length;
    for (let i3 = 0; i3 < s; ) {
      const c6 = Math.min(o3 - this.pos, s - i3);
      if (c6 === o3) {
        const u3 = st3(t);
        for (; o3 <= s - i3; i3 += o3) this.process(u3, i3);
        continue;
      }
      r2.set(t.subarray(i3, i3 + c6), this.pos), this.pos += c6, i3 += c6, this.pos === o3 && (this.process(n3, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    me4(this), sn5(t, this), this.finished = true;
    const { buffer: n3, view: r2, blockLen: o3, isLE: s } = this;
    let { pos: i3 } = this;
    n3[i3++] = 128, this.buffer.subarray(i3).fill(0), this.padOffset > o3 - i3 && (this.process(r2, 0), i3 = 0);
    for (let f10 = i3; f10 < o3; f10++) n3[f10] = 0;
    Ps4(r2, o3 - 8, BigInt(this.length * 8), s), this.process(r2, 0);
    const c6 = st3(t), u3 = this.outputLen;
    if (u3 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const a2 = u3 / 4, l5 = this.get();
    if (a2 > l5.length) throw new Error("_sha2: outputLen bigger than state");
    for (let f10 = 0; f10 < a2; f10++) c6.setUint32(4 * f10, l5[f10], s);
  }
  digest() {
    const { buffer: t, outputLen: n3 } = this;
    this.digestInto(t);
    const r2 = t.slice(0, n3);
    return this.destroy(), r2;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n3, buffer: r2, length: o3, finished: s, destroyed: i3, pos: c6 } = this;
    return t.length = o3, t.pos = c6, t.finished = s, t.destroyed = i3, o3 % n3 && t.buffer.set(r2), t;
  }
};
var Cs4 = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var ie4 = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var ce4 = new Uint32Array(64);
var ks4 = class extends js4 {
  constructor() {
    super(64, 32, 8, false), this.A = ie4[0] | 0, this.B = ie4[1] | 0, this.C = ie4[2] | 0, this.D = ie4[3] | 0, this.E = ie4[4] | 0, this.F = ie4[5] | 0, this.G = ie4[6] | 0, this.H = ie4[7] | 0;
  }
  get() {
    const { A: t, B: n3, C: r2, D: o3, E: s, F: i3, G: c6, H: u3 } = this;
    return [t, n3, r2, o3, s, i3, c6, u3];
  }
  set(t, n3, r2, o3, s, i3, c6, u3) {
    this.A = t | 0, this.B = n3 | 0, this.C = r2 | 0, this.D = o3 | 0, this.E = s | 0, this.F = i3 | 0, this.G = c6 | 0, this.H = u3 | 0;
  }
  process(t, n3) {
    for (let f10 = 0; f10 < 16; f10++, n3 += 4) ce4[f10] = t.getUint32(n3, false);
    for (let f10 = 16; f10 < 64; f10++) {
      const d5 = ce4[f10 - 15], g3 = ce4[f10 - 2], y9 = J6(d5, 7) ^ J6(d5, 18) ^ d5 >>> 3, h6 = J6(g3, 17) ^ J6(g3, 19) ^ g3 >>> 10;
      ce4[f10] = h6 + ce4[f10 - 7] + y9 + ce4[f10 - 16] | 0;
    }
    let { A: r2, B: o3, C: s, D: i3, E: c6, F: u3, G: a2, H: l5 } = this;
    for (let f10 = 0; f10 < 64; f10++) {
      const d5 = J6(c6, 6) ^ J6(c6, 11) ^ J6(c6, 25), g3 = l5 + d5 + Bs3(c6, u3, a2) + Cs4[f10] + ce4[f10] | 0, h6 = (J6(r2, 2) ^ J6(r2, 13) ^ J6(r2, 22)) + Ls5(r2, o3, s) | 0;
      l5 = a2, a2 = u3, u3 = c6, c6 = i3 + g3 | 0, i3 = s, s = o3, o3 = r2, r2 = g3 + h6 | 0;
    }
    r2 = r2 + this.A | 0, o3 = o3 + this.B | 0, s = s + this.C | 0, i3 = i3 + this.D | 0, c6 = c6 + this.E | 0, u3 = u3 + this.F | 0, a2 = a2 + this.G | 0, l5 = l5 + this.H | 0, this.set(r2, o3, s, i3, c6, u3, a2, l5);
  }
  roundClean() {
    ce4.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var He3 = fn4(() => new ks4());
var Wn4 = BigInt(0);
function wt5(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function zn4(e) {
  if (!wt5(e)) throw new Error("Uint8Array expected");
}
var Ds4 = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Ms3(e) {
  zn4(e);
  let t = "";
  for (let n3 = 0; n3 < e.length; n3++) t += Ds4[e[n3]];
  return t;
}
function Vs4(e) {
  if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
  return e === "" ? Wn4 : BigInt("0x" + e);
}
var ee3 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Jn4(e) {
  if (e >= ee3._0 && e <= ee3._9) return e - ee3._0;
  if (e >= ee3.A && e <= ee3.F) return e - (ee3.A - 10);
  if (e >= ee3.a && e <= ee3.f) return e - (ee3.a - 10);
}
function Yn4(e) {
  if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
  const t = e.length, n3 = t / 2;
  if (t % 2) throw new Error("hex string expected, got unpadded hex of length " + t);
  const r2 = new Uint8Array(n3);
  for (let o3 = 0, s = 0; o3 < n3; o3++, s += 2) {
    const i3 = Jn4(e.charCodeAt(s)), c6 = Jn4(e.charCodeAt(s + 1));
    if (i3 === void 0 || c6 === void 0) {
      const u3 = e[s] + e[s + 1];
      throw new Error('hex string expected, got non-hex character "' + u3 + '" at index ' + s);
    }
    r2[o3] = i3 * 16 + c6;
  }
  return r2;
}
function Xn4(e) {
  return zn4(e), Vs4(Ms3(Uint8Array.from(e).reverse()));
}
function Hs4(e, t) {
  return Yn4(e.toString(16).padStart(t * 2, "0"));
}
function Ks3(e, t) {
  return Hs4(e, t).reverse();
}
function Zn4(e, t, n3) {
  let r2;
  if (typeof t == "string") try {
    r2 = Yn4(t);
  } catch (s) {
    throw new Error(e + " must be hex string or Uint8Array, cause: " + s);
  }
  else if (wt5(t)) r2 = Uint8Array.from(t);
  else throw new Error(e + " must be hex string or Uint8Array");
  const o3 = r2.length;
  if (typeof n3 == "number" && o3 !== n3) throw new Error(e + " of length " + n3 + " expected, got " + o3);
  return r2;
}
var Et5 = (e) => typeof e == "bigint" && Wn4 <= e;
function Fs3(e, t, n3) {
  return Et5(e) && Et5(t) && Et5(n3) && t <= e && e < n3;
}
function Qn4(e, t, n3, r2) {
  if (!Fs3(t, n3, r2)) throw new Error("expected valid " + e + ": " + n3 + " <= n < " + r2 + ", got " + t);
}
var qs5 = { bigint: (e) => typeof e == "bigint", function: (e) => typeof e == "function", boolean: (e) => typeof e == "boolean", string: (e) => typeof e == "string", stringOrUint8Array: (e) => typeof e == "string" || wt5(e), isSafeInteger: (e) => Number.isSafeInteger(e), array: (e) => Array.isArray(e), field: (e, t) => t.Fp.isValid(e), hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen) };
function Gs4(e, t, n3 = {}) {
  const r2 = (o3, s, i3) => {
    const c6 = qs5[s];
    if (typeof c6 != "function") throw new Error("invalid validator function");
    const u3 = e[o3];
    if (!(i3 && u3 === void 0) && !c6(u3, e)) throw new Error("param " + String(o3) + " is invalid. Expected " + s + ", got " + u3);
  };
  for (const [o3, s] of Object.entries(t)) r2(o3, s, false);
  for (const [o3, s] of Object.entries(n3)) r2(o3, s, true);
  return e;
}
var ve3 = BigInt(0);
var Ke5 = BigInt(1);
function er4(e, t) {
  const n3 = e % t;
  return n3 >= ve3 ? n3 : t + n3;
}
function Ws4(e, t, n3) {
  if (t < ve3) throw new Error("invalid exponent, negatives unsupported");
  if (n3 <= ve3) throw new Error("invalid modulus");
  if (n3 === Ke5) return ve3;
  let r2 = Ke5;
  for (; t > ve3; ) t & Ke5 && (r2 = r2 * e % n3), e = e * e % n3, t >>= Ke5;
  return r2;
}
function z6(e, t, n3) {
  let r2 = e;
  for (; t-- > ve3; ) r2 *= r2, r2 %= n3;
  return r2;
}
BigInt(0), BigInt(1), BigInt(0), BigInt(1), BigInt(2), BigInt(8);
var xe4 = BigInt(0);
var vt4 = BigInt(1);
function zs3(e) {
  return Gs4(e, { a: "bigint" }, { montgomeryBits: "isSafeInteger", nByteLength: "isSafeInteger", adjustScalarBytes: "function", domain: "function", powPminus2: "function", Gu: "bigint" }), Object.freeze({ ...e });
}
function Js4(e) {
  const t = zs3(e), { P: n3 } = t, r2 = (b4) => er4(b4, n3), o3 = t.montgomeryBits, s = Math.ceil(o3 / 8), i3 = t.nByteLength, c6 = t.adjustScalarBytes || ((b4) => b4), u3 = t.powPminus2 || ((b4) => Ws4(b4, n3 - BigInt(2), n3));
  function a2(b4, _7, O8) {
    const k8 = r2(b4 * (_7 - O8));
    return _7 = r2(_7 - k8), O8 = r2(O8 + k8), [_7, O8];
  }
  const l5 = (t.a - BigInt(2)) / BigInt(4);
  function f10(b4, _7) {
    Qn4("u", b4, xe4, n3), Qn4("scalar", _7, xe4, n3);
    const O8 = _7, k8 = b4;
    let E9 = vt4, B5 = xe4, j5 = b4, v6 = vt4, I5 = xe4, w4;
    for (let A6 = BigInt(o3 - 1); A6 >= xe4; A6--) {
      const T4 = O8 >> A6 & vt4;
      I5 ^= T4, w4 = a2(I5, E9, j5), E9 = w4[0], j5 = w4[1], w4 = a2(I5, B5, v6), B5 = w4[0], v6 = w4[1], I5 = T4;
      const N7 = E9 + B5, S7 = r2(N7 * N7), U3 = E9 - B5, $7 = r2(U3 * U3), p6 = S7 - $7, C7 = j5 + v6, D6 = j5 - v6, P6 = r2(D6 * N7), G5 = r2(C7 * U3), X2 = P6 + G5, Z4 = P6 - G5;
      j5 = r2(X2 * X2), v6 = r2(k8 * r2(Z4 * Z4)), E9 = r2(S7 * $7), B5 = r2(p6 * (S7 + r2(l5 * p6)));
    }
    w4 = a2(I5, E9, j5), E9 = w4[0], j5 = w4[1], w4 = a2(I5, B5, v6), B5 = w4[0], v6 = w4[1];
    const R6 = u3(B5);
    return r2(E9 * R6);
  }
  function d5(b4) {
    return Ks3(r2(b4), s);
  }
  function g3(b4) {
    const _7 = Zn4("u coordinate", b4, s);
    return i3 === 32 && (_7[31] &= 127), Xn4(_7);
  }
  function y9(b4) {
    const _7 = Zn4("scalar", b4), O8 = _7.length;
    if (O8 !== s && O8 !== i3) {
      let k8 = "" + s + " or " + i3;
      throw new Error("invalid scalar, expected " + k8 + " bytes, got " + O8);
    }
    return Xn4(c6(_7));
  }
  function h6(b4, _7) {
    const O8 = g3(_7), k8 = y9(b4), E9 = f10(O8, k8);
    if (E9 === xe4) throw new Error("invalid private or public key received");
    return d5(E9);
  }
  const m3 = d5(t.Gu);
  function L5(b4) {
    return h6(b4, m3);
  }
  return { scalarMult: h6, scalarMultBase: L5, getSharedSecret: (b4, _7) => h6(b4, _7), getPublicKey: (b4) => L5(b4), utils: { randomPrivateKey: () => t.randomBytes(t.nByteLength) }, GuBytes: m3 };
}
var xt4 = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
BigInt(0);
var Ys4 = BigInt(1);
var tr4 = BigInt(2);
var Xs4 = BigInt(3);
var Zs4 = BigInt(5);
BigInt(8);
function Qs4(e) {
  const t = BigInt(10), n3 = BigInt(20), r2 = BigInt(40), o3 = BigInt(80), s = xt4, c6 = e * e % s * e % s, u3 = z6(c6, tr4, s) * c6 % s, a2 = z6(u3, Ys4, s) * e % s, l5 = z6(a2, Zs4, s) * a2 % s, f10 = z6(l5, t, s) * l5 % s, d5 = z6(f10, n3, s) * f10 % s, g3 = z6(d5, r2, s) * d5 % s, y9 = z6(g3, o3, s) * g3 % s, h6 = z6(y9, o3, s) * g3 % s, m3 = z6(h6, t, s) * l5 % s;
  return { pow_p_5_8: z6(m3, tr4, s) * e % s, b2: c6 };
}
function ei4(e) {
  return e[0] &= 248, e[31] &= 127, e[31] |= 64, e;
}
var It4 = Js4({ P: xt4, a: BigInt(486662), montgomeryBits: 255, nByteLength: 32, Gu: BigInt(9), powPminus2: (e) => {
  const t = xt4, { pow_p_5_8: n3, b2: r2 } = Qs4(e);
  return er4(z6(n3, Xs4, t) * r2, t);
}, adjustScalarBytes: ei4, randomBytes: Se4 });
var Ot4 = "base10";
var V5 = "base16";
var At4 = "base64pad";
var ti4 = "base64url";
var Ie4 = "utf8";
var Nt4 = 0;
var Oe5 = 1;
var _e5 = 2;
var ni4 = 0;
var nr4 = 1;
var Te3 = 12;
var St5 = 32;
function ri4() {
  const e = It4.utils.randomPrivateKey(), t = It4.getPublicKey(e);
  return { privateKey: toString(e, V5), publicKey: toString(t, V5) };
}
function oi4() {
  const e = Se4(St5);
  return toString(e, V5);
}
function si4(e, t) {
  const n3 = It4.getSharedSecret(fromString(e, V5), fromString(t, V5)), r2 = Rs4(He3, n3, void 0, void 0, St5);
  return toString(r2, V5);
}
function ii4(e) {
  const t = He3(fromString(e, V5));
  return toString(t, V5);
}
function ci4(e) {
  const t = He3(fromString(e, Ie4));
  return toString(t, V5);
}
function Ut4(e) {
  return fromString(`${e}`, Ot4);
}
function fe3(e) {
  return Number(toString(e, Ot4));
}
function ai4(e) {
  const t = Ut4(typeof e.type < "u" ? e.type : Nt4);
  if (fe3(t) === Oe5 && typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const n3 = typeof e.senderPublicKey < "u" ? fromString(e.senderPublicKey, V5) : void 0, r2 = typeof e.iv < "u" ? fromString(e.iv, V5) : Se4(Te3), o3 = fromString(e.symKey, V5), s = Fn4(o3, r2).encrypt(fromString(e.message, Ie4));
  return _t5({ type: t, sealed: s, iv: r2, senderPublicKey: n3, encoding: e.encoding });
}
function ui4(e) {
  const t = fromString(e.symKey, V5), { sealed: n3, iv: r2 } = Fe4(e), o3 = Fn4(t, r2).decrypt(n3);
  if (o3 === null) throw new Error("Failed to decrypt");
  return toString(o3, Ie4);
}
function fi4(e, t) {
  const n3 = Ut4(_e5), r2 = Se4(Te3), o3 = fromString(e, Ie4);
  return _t5({ type: n3, sealed: o3, iv: r2, encoding: t });
}
function li4(e, t) {
  const { sealed: n3 } = Fe4({ encoded: e, encoding: t });
  return toString(n3, Ie4);
}
function _t5(e) {
  const { encoding: t = At4 } = e;
  if (fe3(e.type) === _e5) return toString(concat([e.type, e.sealed]), t);
  if (fe3(e.type) === Oe5) {
    if (typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e.type, e.senderPublicKey, e.iv, e.sealed]), t);
  }
  return toString(concat([e.type, e.iv, e.sealed]), t);
}
function Fe4(e) {
  const { encoded: t, encoding: n3 = At4 } = e, r2 = fromString(t, n3), o3 = r2.slice(ni4, nr4), s = nr4;
  if (fe3(o3) === Oe5) {
    const a2 = s + St5, l5 = a2 + Te3, f10 = r2.slice(s, a2), d5 = r2.slice(a2, l5), g3 = r2.slice(l5);
    return { type: o3, sealed: g3, iv: d5, senderPublicKey: f10 };
  }
  if (fe3(o3) === _e5) {
    const a2 = r2.slice(s), l5 = Se4(Te3);
    return { type: o3, sealed: a2, iv: l5 };
  }
  const i3 = s + Te3, c6 = r2.slice(s, i3), u3 = r2.slice(i3);
  return { type: o3, sealed: u3, iv: c6 };
}
function di4(e, t) {
  const n3 = Fe4({ encoded: e, encoding: t == null ? void 0 : t.encoding });
  return rr4({ type: fe3(n3.type), senderPublicKey: typeof n3.senderPublicKey < "u" ? toString(n3.senderPublicKey, V5) : void 0, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey });
}
function rr4(e) {
  const t = (e == null ? void 0 : e.type) || Nt4;
  if (t === Oe5) {
    if (typeof (e == null ? void 0 : e.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: t, senderPublicKey: e == null ? void 0 : e.senderPublicKey, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey };
}
function hi4(e) {
  return e.type === Oe5 && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
function pi4(e) {
  return e.type === _e5;
}
function or4(e) {
  return new import_elliptic2.ec("p256").keyFromPublic({ x: Buffer.from(e.x, "base64").toString("hex"), y: Buffer.from(e.y, "base64").toString("hex") }, "hex");
}
function gi4(e) {
  let t = e.replace(/-/g, "+").replace(/_/g, "/");
  const n3 = t.length % 4;
  return n3 > 0 && (t += "=".repeat(4 - n3)), t;
}
function yi4(e) {
  return Buffer.from(gi4(e), "base64");
}
function mi4(e, t) {
  const [n3, r2, o3] = e.split("."), s = yi4(o3);
  if (s.length !== 64) throw new Error("Invalid signature length");
  const i3 = s.slice(0, 32).toString("hex"), c6 = s.slice(32, 64).toString("hex"), u3 = `${n3}.${r2}`, a2 = He3(u3), l5 = or4(t), f10 = toString(a2, V5);
  if (!l5.verify(f10, { r: i3, s: c6 })) throw new Error("Invalid signature");
  return sn(e).payload;
}
var sr4 = "irn";
function bi4(e) {
  return (e == null ? void 0 : e.relay) || { protocol: sr4 };
}
function wi4(e) {
  const t = C[e];
  if (typeof t > "u") throw new Error(`Relay Protocol not supported: ${e}`);
  return t;
}
function ir4(e, t = "-") {
  const n3 = {}, r2 = "relay" + t;
  return Object.keys(e).forEach((o3) => {
    if (o3.startsWith(r2)) {
      const s = o3.replace(r2, ""), i3 = e[o3];
      n3[s] = i3;
    }
  }), n3;
}
function Ei4(e) {
  if (!e.includes("wc:")) {
    const a2 = rt3(e);
    a2 != null && a2.includes("wc:") && (e = a2);
  }
  e = e.includes("wc://") ? e.replace("wc://", "") : e, e = e.includes("wc:") ? e.replace("wc:", "") : e;
  const t = e.indexOf(":"), n3 = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r2 = e.substring(0, t), o3 = e.substring(t + 1, n3).split("@"), s = typeof n3 < "u" ? e.substring(n3) : "", i3 = new URLSearchParams(s), c6 = {};
  i3.forEach((a2, l5) => {
    c6[l5] = a2;
  });
  const u3 = typeof c6.methods == "string" ? c6.methods.split(",") : void 0;
  return { protocol: r2, topic: cr4(o3[0]), version: parseInt(o3[1], 10), symKey: c6.symKey, relay: ir4(c6), methods: u3, expiryTimestamp: c6.expiryTimestamp ? parseInt(c6.expiryTimestamp, 10) : void 0 };
}
function cr4(e) {
  return e.startsWith("//") ? e.substring(2) : e;
}
function ar4(e, t = "-") {
  const n3 = "relay", r2 = {};
  return Object.keys(e).forEach((o3) => {
    const s = o3, i3 = n3 + t + s;
    e[s] && (r2[i3] = e[s]);
  }), r2;
}
function vi3(e) {
  const t = new URLSearchParams(), n3 = ar4(e.relay);
  Object.keys(n3).sort().forEach((o3) => {
    t.set(o3, n3[o3]);
  }), t.set("symKey", e.symKey), e.expiryTimestamp && t.set("expiryTimestamp", e.expiryTimestamp.toString()), e.methods && t.set("methods", e.methods.join(","));
  const r2 = t.toString();
  return `${e.protocol}:${e.topic}@${e.version}?${r2}`;
}
function xi3(e, t, n3) {
  return `${e}?wc_ev=${n3}&topic=${t}`;
}
function le5(e) {
  const t = [];
  return e.forEach((n3) => {
    const [r2, o3] = n3.split(":");
    t.push(`${r2}:${o3}`);
  }), t;
}
function lr4(e) {
  const t = [];
  return Object.values(e).forEach((n3) => {
    t.push(...le5(n3.accounts));
  }), t;
}
function dr4(e, t) {
  const n3 = [];
  return Object.values(e).forEach((r2) => {
    le5(r2.accounts).includes(t) && n3.push(...r2.methods);
  }), n3;
}
function hr4(e, t) {
  const n3 = [];
  return Object.values(e).forEach((r2) => {
    le5(r2.accounts).includes(t) && n3.push(...r2.events);
  }), n3;
}
function Tt4(e) {
  return e.includes(":");
}
function pr4(e) {
  return Tt4(e) ? e.split(":")[0] : e;
}
function gr4(e) {
  const t = {};
  return e == null ? void 0 : e.forEach((n3) => {
    var r2;
    const [o3, s] = n3.split(":");
    t[o3] || (t[o3] = { accounts: [], chains: [], events: [], methods: [] }), t[o3].accounts.push(n3), (r2 = t[o3].chains) == null || r2.push(`${o3}:${s}`);
  }), t;
}
function Ri4(e, t) {
  t = t.map((r2) => r2.replace("did:pkh:", ""));
  const n3 = gr4(t);
  for (const [r2, o3] of Object.entries(n3)) o3.methods ? o3.methods = Q3(o3.methods, e) : o3.methods = e, o3.events = ["chainChanged", "accountsChanged"];
  return n3;
}
var yr4 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var mr4 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function te4(e, t) {
  const { message: n3, code: r2 } = mr4[e];
  return { message: t ? `${n3} ${t}` : n3, code: r2 };
}
function de4(e, t) {
  const { message: n3, code: r2 } = yr4[e];
  return { message: t ? `${n3} ${t}` : n3, code: r2 };
}
function $e5(e, t) {
  return Array.isArray(e) ? typeof t < "u" && e.length ? e.every(t) : true : false;
}
function qe4(e) {
  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;
}
function ae3(e) {
  return typeof e > "u";
}
function q4(e, t) {
  return t && ae3(e) ? true : typeof e == "string" && !!e.trim().length;
}
function Ge5(e, t) {
  return t && ae3(e) ? true : typeof e == "number" && !isNaN(e);
}
function Pi6(e, t) {
  const { requiredNamespaces: n3 } = t, r2 = Object.keys(e.namespaces), o3 = Object.keys(n3);
  let s = true;
  return re4(o3, r2) ? (r2.forEach((i3) => {
    const { accounts: c6, methods: u3, events: a2 } = e.namespaces[i3], l5 = le5(c6), f10 = n3[i3];
    (!re4(Be4(i3, f10), l5) || !re4(f10.methods, u3) || !re4(f10.events, a2)) && (s = false);
  }), s) : false;
}
function Re3(e) {
  return q4(e, false) && e.includes(":") ? e.split(":").length === 2 : false;
}
function br4(e) {
  if (q4(e, false) && e.includes(":")) {
    const t = e.split(":");
    if (t.length === 3) {
      const n3 = t[0] + ":" + t[1];
      return !!t[2] && Re3(n3);
    }
  }
  return false;
}
function Bi3(e) {
  function t(n3) {
    try {
      return typeof new URL(n3) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (q4(e, false)) {
      if (t(e)) return true;
      const n3 = rt3(e);
      return t(n3);
    }
  } catch {
  }
  return false;
}
function Li4(e) {
  var t;
  return (t = e == null ? void 0 : e.proposer) == null ? void 0 : t.publicKey;
}
function ji3(e) {
  return e == null ? void 0 : e.topic;
}
function Ci4(e, t) {
  let n3 = null;
  return q4(e == null ? void 0 : e.publicKey, false) || (n3 = te4("MISSING_OR_INVALID", `${t} controller public key should be a string`)), n3;
}
function Rt5(e) {
  let t = true;
  return $e5(e) ? e.length && (t = e.every((n3) => q4(n3, false))) : t = false, t;
}
function wr4(e, t, n3) {
  let r2 = null;
  return $e5(t) && t.length ? t.forEach((o3) => {
    r2 || Re3(o3) || (r2 = de4("UNSUPPORTED_CHAINS", `${n3}, chain ${o3} should be a string and conform to "namespace:chainId" format`));
  }) : Re3(e) || (r2 = de4("UNSUPPORTED_CHAINS", `${n3}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r2;
}
function Er4(e, t, n3) {
  let r2 = null;
  return Object.entries(e).forEach(([o3, s]) => {
    if (r2) return;
    const i3 = wr4(o3, Be4(o3, s), `${t} ${n3}`);
    i3 && (r2 = i3);
  }), r2;
}
function vr4(e, t) {
  let n3 = null;
  return $e5(e) ? e.forEach((r2) => {
    n3 || br4(r2) || (n3 = de4("UNSUPPORTED_ACCOUNTS", `${t}, account ${r2} should be a string and conform to "namespace:chainId:address" format`));
  }) : n3 = de4("UNSUPPORTED_ACCOUNTS", `${t}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), n3;
}
function xr4(e, t) {
  let n3 = null;
  return Object.values(e).forEach((r2) => {
    if (n3) return;
    const o3 = vr4(r2 == null ? void 0 : r2.accounts, `${t} namespace`);
    o3 && (n3 = o3);
  }), n3;
}
function Ir4(e, t) {
  let n3 = null;
  return Rt5(e == null ? void 0 : e.methods) ? Rt5(e == null ? void 0 : e.events) || (n3 = de4("UNSUPPORTED_EVENTS", `${t}, events should be an array of strings or empty array for no events`)) : n3 = de4("UNSUPPORTED_METHODS", `${t}, methods should be an array of strings or empty array for no methods`), n3;
}
function Pt3(e, t) {
  let n3 = null;
  return Object.values(e).forEach((r2) => {
    if (n3) return;
    const o3 = Ir4(r2, `${t}, namespace`);
    o3 && (n3 = o3);
  }), n3;
}
function ki4(e, t, n3) {
  let r2 = null;
  if (e && qe4(e)) {
    const o3 = Pt3(e, t);
    o3 && (r2 = o3);
    const s = Er4(e, t, n3);
    s && (r2 = s);
  } else r2 = te4("MISSING_OR_INVALID", `${t}, ${n3} should be an object with data`);
  return r2;
}
function Or4(e, t) {
  let n3 = null;
  if (e && qe4(e)) {
    const r2 = Pt3(e, t);
    r2 && (n3 = r2);
    const o3 = xr4(e, t);
    o3 && (n3 = o3);
  } else n3 = te4("MISSING_OR_INVALID", `${t}, namespaces should be an object with data`);
  return n3;
}
function Ar4(e) {
  return q4(e.protocol, true);
}
function Di4(e, t) {
  let n3 = false;
  return t && !e ? n3 = true : e && $e5(e) && e.length && e.forEach((r2) => {
    n3 = Ar4(r2);
  }), n3;
}
function Mi3(e) {
  return typeof e == "number";
}
function Vi3(e) {
  return typeof e < "u" && typeof e !== null;
}
function Hi3(e) {
  return !(!e || typeof e != "object" || !e.code || !Ge5(e.code, false) || !e.message || !q4(e.message, false));
}
function Ki3(e) {
  return !(ae3(e) || !q4(e.method, false));
}
function Fi3(e) {
  return !(ae3(e) || ae3(e.result) && ae3(e.error) || !Ge5(e.id, false) || !q4(e.jsonrpc, false));
}
function qi3(e) {
  return !(ae3(e) || !q4(e.name, false));
}
function Gi3(e, t) {
  return !(!Re3(t) || !lr4(e).includes(t));
}
function Wi3(e, t, n3) {
  return q4(n3, false) ? dr4(e, t).includes(n3) : false;
}
function zi4(e, t, n3) {
  return q4(n3, false) ? hr4(e, t).includes(n3) : false;
}
function Nr4(e, t, n3) {
  let r2 = null;
  const o3 = Ji3(e), s = Yi3(t), i3 = Object.keys(o3), c6 = Object.keys(s), u3 = Sr4(Object.keys(e)), a2 = Sr4(Object.keys(t)), l5 = u3.filter((f10) => !a2.includes(f10));
  return l5.length && (r2 = te4("NON_CONFORMING_NAMESPACES", `${n3} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l5.toString()}
      Received: ${Object.keys(t).toString()}`)), re4(i3, c6) || (r2 = te4("NON_CONFORMING_NAMESPACES", `${n3} namespaces chains don't satisfy required namespaces.
      Required: ${i3.toString()}
      Approved: ${c6.toString()}`)), Object.keys(t).forEach((f10) => {
    if (!f10.includes(":") || r2) return;
    const d5 = le5(t[f10].accounts);
    d5.includes(f10) || (r2 = te4("NON_CONFORMING_NAMESPACES", `${n3} namespaces accounts don't satisfy namespace accounts for ${f10}
        Required: ${f10}
        Approved: ${d5.toString()}`));
  }), i3.forEach((f10) => {
    r2 || (re4(o3[f10].methods, s[f10].methods) ? re4(o3[f10].events, s[f10].events) || (r2 = te4("NON_CONFORMING_NAMESPACES", `${n3} namespaces events don't satisfy namespace events for ${f10}`)) : r2 = te4("NON_CONFORMING_NAMESPACES", `${n3} namespaces methods don't satisfy namespace methods for ${f10}`));
  }), r2;
}
function Ji3(e) {
  const t = {};
  return Object.keys(e).forEach((n3) => {
    var r2;
    n3.includes(":") ? t[n3] = e[n3] : (r2 = e[n3].chains) == null || r2.forEach((o3) => {
      t[o3] = { methods: e[n3].methods, events: e[n3].events };
    });
  }), t;
}
function Sr4(e) {
  return [...new Set(e.map((t) => t.includes(":") ? t.split(":")[0] : t))];
}
function Yi3(e) {
  const t = {};
  return Object.keys(e).forEach((n3) => {
    if (n3.includes(":")) t[n3] = e[n3];
    else {
      const r2 = le5(e[n3].accounts);
      r2 == null ? void 0 : r2.forEach((o3) => {
        t[o3] = { accounts: e[n3].accounts.filter((s) => s.includes(`${o3}:`)), methods: e[n3].methods, events: e[n3].events };
      });
    }
  }), t;
}
function Xi3(e, t) {
  return Ge5(e, false) && e <= t.max && e >= t.min;
}
function Zi3() {
  const e = ue4();
  return new Promise((t) => {
    switch (e) {
      case H4.browser:
        t(Ur4());
        break;
      case H4.reactNative:
        t(_r4());
        break;
      case H4.node:
        t(Tr4());
        break;
      default:
        t(true);
    }
  });
}
function Ur4() {
  return Ae4() && (navigator == null ? void 0 : navigator.onLine);
}
async function _r4() {
  if (ne3() && typeof global < "u" && global != null && global.NetInfo) {
    const e = await (global == null ? void 0 : global.NetInfo.fetch());
    return e == null ? void 0 : e.isConnected;
  }
  return true;
}
function Tr4() {
  return true;
}
function Qi3(e) {
  switch (ue4()) {
    case H4.browser:
      $r4(e);
      break;
    case H4.reactNative:
      Rr4(e);
      break;
    case H4.node:
      break;
  }
}
function $r4(e) {
  !ne3() && Ae4() && (window.addEventListener("online", () => e(true)), window.addEventListener("offline", () => e(false)));
}
function Rr4(e) {
  ne3() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((t) => e(t == null ? void 0 : t.isConnected)));
}
var Bt4 = {};
var ec2 = class {
  static get(t) {
    return Bt4[t];
  }
  static set(t, n3) {
    Bt4[t] = n3;
  }
  static delete(t) {
    delete Bt4[t];
  }
};

// node_modules/@reown/appkit/node_modules/@walletconnect/core/dist/index.es.js
var import_window_getters4 = __toESM(require_cjs2());
var ze5 = "wc";
var Le5 = 2;
var he3 = "core";
var B3 = `${ze5}@2:${he3}:`;
var Et6 = { name: he3, logger: "error" };
var It5 = { database: ":memory:" };
var Tt5 = "crypto";
var ke6 = "client_ed25519_seed";
var Ct5 = import_time5.ONE_DAY;
var Pt4 = "keychain";
var St6 = "0.3";
var Rt6 = "messages";
var Ot5 = "0.3";
var je5 = import_time5.SIX_HOURS;
var At5 = "publisher";
var xt5 = "irn";
var Nt5 = "error";
var Ue6 = "wss://relay.walletconnect.org";
var $t2 = "relayer";
var C4 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var zt5 = "_subscription";
var L3 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var Lt5 = 0.1;
var _e6 = "2.19.1";
var Q4 = { link_mode: "link_mode", relay: "relay" };
var le6 = { inbound: "inbound", outbound: "outbound" };
var kt5 = "0.3";
var jt5 = "WALLETCONNECT_CLIENT_ID";
var Me6 = "WALLETCONNECT_LINK_MODE_APPS";
var $4 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var Ut5 = "subscription";
var Mt4 = "0.3";
var Hs5 = import_time5.FIVE_SECONDS * 1e3;
var Ft5 = "pairing";
var Kt3 = "0.3";
var ie5 = { wc_pairingDelete: { req: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time5.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time5.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time5.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time5.ONE_DAY, prompt: false, tag: 0 } } };
var se5 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var M7 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var Bt5 = "history";
var Vt3 = "0.3";
var qt3 = "expirer";
var F5 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var Gt5 = "0.3";
var Wt5 = "verify-api";
var Xs5 = "https://verify.walletconnect.com";
var Ht3 = "https://verify.walletconnect.org";
var ue5 = Ht3;
var Yt5 = `${ue5}/v3`;
var Jt5 = [Xs5, Ht3];
var Xt3 = "echo";
var Zt3 = "https://echo.walletconnect.com";
var G3 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var Y5 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var Qs5 = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" };
var er5 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" };
var tr5 = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" };
var ir5 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
var Qt3 = 0.1;
var ei5 = "event-client";
var ti5 = 86400;
var ii5 = "https://pulse.walletconnect.org/batch";
function sr5(r2, e) {
  if (r2.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), s = 0; s < t.length; s++) t[s] = 255;
  for (var i3 = 0; i3 < r2.length; i3++) {
    var n3 = r2.charAt(i3), o3 = n3.charCodeAt(0);
    if (t[o3] !== 255) throw new TypeError(n3 + " is ambiguous");
    t[o3] = i3;
  }
  var a2 = r2.length, c6 = r2.charAt(0), h6 = Math.log(a2) / Math.log(256), u3 = Math.log(256) / Math.log(a2);
  function d5(l5) {
    if (l5 instanceof Uint8Array || (ArrayBuffer.isView(l5) ? l5 = new Uint8Array(l5.buffer, l5.byteOffset, l5.byteLength) : Array.isArray(l5) && (l5 = Uint8Array.from(l5))), !(l5 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (l5.length === 0) return "";
    for (var b4 = 0, x9 = 0, I5 = 0, D6 = l5.length; I5 !== D6 && l5[I5] === 0; ) I5++, b4++;
    for (var j5 = (D6 - I5) * u3 + 1 >>> 0, T4 = new Uint8Array(j5); I5 !== D6; ) {
      for (var q5 = l5[I5], J9 = 0, K7 = j5 - 1; (q5 !== 0 || J9 < x9) && K7 !== -1; K7--, J9++) q5 += 256 * T4[K7] >>> 0, T4[K7] = q5 % a2 >>> 0, q5 = q5 / a2 >>> 0;
      if (q5 !== 0) throw new Error("Non-zero carry");
      x9 = J9, I5++;
    }
    for (var H6 = j5 - x9; H6 !== j5 && T4[H6] === 0; ) H6++;
    for (var me7 = c6.repeat(b4); H6 < j5; ++H6) me7 += r2.charAt(T4[H6]);
    return me7;
  }
  function g3(l5) {
    if (typeof l5 != "string") throw new TypeError("Expected String");
    if (l5.length === 0) return new Uint8Array();
    var b4 = 0;
    if (l5[b4] !== " ") {
      for (var x9 = 0, I5 = 0; l5[b4] === c6; ) x9++, b4++;
      for (var D6 = (l5.length - b4) * h6 + 1 >>> 0, j5 = new Uint8Array(D6); l5[b4]; ) {
        var T4 = t[l5.charCodeAt(b4)];
        if (T4 === 255) return;
        for (var q5 = 0, J9 = D6 - 1; (T4 !== 0 || q5 < I5) && J9 !== -1; J9--, q5++) T4 += a2 * j5[J9] >>> 0, j5[J9] = T4 % 256 >>> 0, T4 = T4 / 256 >>> 0;
        if (T4 !== 0) throw new Error("Non-zero carry");
        I5 = q5, b4++;
      }
      if (l5[b4] !== " ") {
        for (var K7 = D6 - I5; K7 !== D6 && j5[K7] === 0; ) K7++;
        for (var H6 = new Uint8Array(x9 + (D6 - K7)), me7 = x9; K7 !== D6; ) H6[me7++] = j5[K7++];
        return H6;
      }
    }
  }
  function _7(l5) {
    var b4 = g3(l5);
    if (b4) return b4;
    throw new Error(`Non-${e} character`);
  }
  return { encode: d5, decodeUnsafe: g3, decode: _7 };
}
var rr5 = sr5;
var nr5 = rr5;
var si5 = (r2) => {
  if (r2 instanceof Uint8Array && r2.constructor.name === "Uint8Array") return r2;
  if (r2 instanceof ArrayBuffer) return new Uint8Array(r2);
  if (ArrayBuffer.isView(r2)) return new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var or5 = (r2) => new TextEncoder().encode(r2);
var ar5 = (r2) => new TextDecoder().decode(r2);
var cr5 = class {
  constructor(e, t, s) {
    this.name = e, this.prefix = t, this.baseEncode = s;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var hr5 = class {
  constructor(e, t, s) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return ri5(this, e);
  }
};
var lr5 = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return ri5(this, e);
  }
  decode(e) {
    const t = e[0], s = this.decoders[t];
    if (s) return s.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ri5 = (r2, e) => new lr5({ ...r2.decoders || { [r2.prefix]: r2 }, ...e.decoders || { [e.prefix]: e } });
var ur3 = class {
  constructor(e, t, s, i3) {
    this.name = e, this.prefix = t, this.baseEncode = s, this.baseDecode = i3, this.encoder = new cr5(e, t, s), this.decoder = new hr5(e, t, i3);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var Ee6 = ({ name: r2, prefix: e, encode: t, decode: s }) => new ur3(r2, e, t, s);
var de5 = ({ prefix: r2, name: e, alphabet: t }) => {
  const { encode: s, decode: i3 } = nr5(t, e);
  return Ee6({ prefix: r2, name: e, encode: s, decode: (n3) => si5(i3(n3)) });
};
var dr5 = (r2, e, t, s) => {
  const i3 = {};
  for (let u3 = 0; u3 < e.length; ++u3) i3[e[u3]] = u3;
  let n3 = r2.length;
  for (; r2[n3 - 1] === "="; ) --n3;
  const o3 = new Uint8Array(n3 * t / 8 | 0);
  let a2 = 0, c6 = 0, h6 = 0;
  for (let u3 = 0; u3 < n3; ++u3) {
    const d5 = i3[r2[u3]];
    if (d5 === void 0) throw new SyntaxError(`Non-${s} character`);
    c6 = c6 << t | d5, a2 += t, a2 >= 8 && (a2 -= 8, o3[h6++] = 255 & c6 >> a2);
  }
  if (a2 >= t || 255 & c6 << 8 - a2) throw new SyntaxError("Unexpected end of data");
  return o3;
};
var gr5 = (r2, e, t) => {
  const s = e[e.length - 1] === "=", i3 = (1 << t) - 1;
  let n3 = "", o3 = 0, a2 = 0;
  for (let c6 = 0; c6 < r2.length; ++c6) for (a2 = a2 << 8 | r2[c6], o3 += 8; o3 > t; ) o3 -= t, n3 += e[i3 & a2 >> o3];
  if (o3 && (n3 += e[i3 & a2 << t - o3]), s) for (; n3.length * t & 7; ) n3 += "=";
  return n3;
};
var P4 = ({ name: r2, prefix: e, bitsPerChar: t, alphabet: s }) => Ee6({ prefix: e, name: r2, encode(i3) {
  return gr5(i3, s, t);
}, decode(i3) {
  return dr5(i3, s, t, r2);
} });
var pr5 = Ee6({ prefix: "\0", name: "identity", encode: (r2) => ar5(r2), decode: (r2) => or5(r2) });
var yr5 = Object.freeze({ __proto__: null, identity: pr5 });
var br5 = P4({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var mr5 = Object.freeze({ __proto__: null, base2: br5 });
var fr3 = P4({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Dr4 = Object.freeze({ __proto__: null, base8: fr3 });
var vr5 = de5({ prefix: "9", name: "base10", alphabet: "0123456789" });
var wr5 = Object.freeze({ __proto__: null, base10: vr5 });
var _r5 = P4({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Er5 = P4({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Ir5 = Object.freeze({ __proto__: null, base16: _r5, base16upper: Er5 });
var Tr5 = P4({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Cr3 = P4({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Pr3 = P4({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Sr5 = P4({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Rr5 = P4({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var Or5 = P4({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Ar5 = P4({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var xr5 = P4({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var Nr5 = P4({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var $r5 = Object.freeze({ __proto__: null, base32: Tr5, base32upper: Cr3, base32pad: Pr3, base32padupper: Sr5, base32hex: Rr5, base32hexupper: Or5, base32hexpad: Ar5, base32hexpadupper: xr5, base32z: Nr5 });
var zr5 = de5({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Lr5 = de5({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var kr4 = Object.freeze({ __proto__: null, base36: zr5, base36upper: Lr5 });
var jr3 = de5({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Ur5 = de5({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Mr3 = Object.freeze({ __proto__: null, base58btc: jr3, base58flickr: Ur5 });
var Fr3 = P4({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Kr5 = P4({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Br5 = P4({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Vr3 = P4({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var qr3 = Object.freeze({ __proto__: null, base64: Fr3, base64pad: Kr5, base64url: Br5, base64urlpad: Vr3 });
var ni5 = Array.from("");
var Gr3 = ni5.reduce((r2, e, t) => (r2[t] = e, r2), []);
var Wr4 = ni5.reduce((r2, e, t) => (r2[e.codePointAt(0)] = t, r2), []);
function Hr3(r2) {
  return r2.reduce((e, t) => (e += Gr3[t], e), "");
}
function Yr5(r2) {
  const e = [];
  for (const t of r2) {
    const s = Wr4[t.codePointAt(0)];
    if (s === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(s);
  }
  return new Uint8Array(e);
}
var Jr5 = Ee6({ prefix: "", name: "base256emoji", encode: Hr3, decode: Yr5 });
var Xr4 = Object.freeze({ __proto__: null, base256emoji: Jr5 });
var Zr4 = ai5;
var oi5 = 128;
var Qr4 = 127;
var en5 = ~Qr4;
var tn5 = Math.pow(2, 31);
function ai5(r2, e, t) {
  e = e || [], t = t || 0;
  for (var s = t; r2 >= tn5; ) e[t++] = r2 & 255 | oi5, r2 /= 128;
  for (; r2 & en5; ) e[t++] = r2 & 255 | oi5, r2 >>>= 7;
  return e[t] = r2 | 0, ai5.bytes = t - s + 1, e;
}
var sn6 = Fe5;
var rn5 = 128;
var ci5 = 127;
function Fe5(r2, s) {
  var t = 0, s = s || 0, i3 = 0, n3 = s, o3, a2 = r2.length;
  do {
    if (n3 >= a2) throw Fe5.bytes = 0, new RangeError("Could not decode varint");
    o3 = r2[n3++], t += i3 < 28 ? (o3 & ci5) << i3 : (o3 & ci5) * Math.pow(2, i3), i3 += 7;
  } while (o3 >= rn5);
  return Fe5.bytes = n3 - s, t;
}
var nn5 = Math.pow(2, 7);
var on5 = Math.pow(2, 14);
var an5 = Math.pow(2, 21);
var cn5 = Math.pow(2, 28);
var hn5 = Math.pow(2, 35);
var ln5 = Math.pow(2, 42);
var un5 = Math.pow(2, 49);
var dn5 = Math.pow(2, 56);
var gn5 = Math.pow(2, 63);
var pn5 = function(r2) {
  return r2 < nn5 ? 1 : r2 < on5 ? 2 : r2 < an5 ? 3 : r2 < cn5 ? 4 : r2 < hn5 ? 5 : r2 < ln5 ? 6 : r2 < un5 ? 7 : r2 < dn5 ? 8 : r2 < gn5 ? 9 : 10;
};
var yn5 = { encode: Zr4, decode: sn6, encodingLength: pn5 };
var hi5 = yn5;
var li5 = (r2, e, t = 0) => (hi5.encode(r2, e, t), e);
var ui5 = (r2) => hi5.encodingLength(r2);
var Ke6 = (r2, e) => {
  const t = e.byteLength, s = ui5(r2), i3 = s + ui5(t), n3 = new Uint8Array(i3 + t);
  return li5(r2, n3, 0), li5(t, n3, s), n3.set(e, i3), new bn5(r2, t, e, n3);
};
var bn5 = class {
  constructor(e, t, s, i3) {
    this.code = e, this.size = t, this.digest = s, this.bytes = i3;
  }
};
var di5 = ({ name: r2, code: e, encode: t }) => new mn5(r2, e, t);
var mn5 = class {
  constructor(e, t, s) {
    this.name = e, this.code = t, this.encode = s;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? Ke6(this.code, t) : t.then((s) => Ke6(this.code, s));
    } else throw Error("Unknown type, must be binary type");
  }
};
var gi5 = (r2) => async (e) => new Uint8Array(await crypto.subtle.digest(r2, e));
var fn5 = di5({ name: "sha2-256", code: 18, encode: gi5("SHA-256") });
var Dn5 = di5({ name: "sha2-512", code: 19, encode: gi5("SHA-512") });
var vn5 = Object.freeze({ __proto__: null, sha256: fn5, sha512: Dn5 });
var pi5 = 0;
var wn5 = "identity";
var yi5 = si5;
var _n5 = (r2) => Ke6(pi5, yi5(r2));
var En5 = { code: pi5, name: wn5, encode: yi5, digest: _n5 };
var In5 = Object.freeze({ __proto__: null, identity: En5 });
new TextEncoder(), new TextDecoder();
var bi5 = { ...yr5, ...mr5, ...Dr4, ...wr5, ...Ir5, ...$r5, ...kr4, ...Mr3, ...qr3, ...Xr4 };
({ ...vn5, ...In5 });
function Tn5(r2 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r2) : new Uint8Array(r2);
}
function mi5(r2, e, t, s) {
  return { name: r2, prefix: e, encoder: { name: r2, prefix: e, encode: t }, decoder: { decode: s } };
}
var fi5 = mi5("utf8", "u", (r2) => "u" + new TextDecoder("utf8").decode(r2), (r2) => new TextEncoder().encode(r2.substring(1)));
var Be5 = mi5("ascii", "a", (r2) => {
  let e = "a";
  for (let t = 0; t < r2.length; t++) e += String.fromCharCode(r2[t]);
  return e;
}, (r2) => {
  r2 = r2.substring(1);
  const e = Tn5(r2.length);
  for (let t = 0; t < r2.length; t++) e[t] = r2.charCodeAt(t);
  return e;
});
var Cn5 = { utf8: fi5, "utf-8": fi5, hex: bi5.base16, latin1: Be5, ascii: Be5, binary: Be5, ...bi5 };
function Pn3(r2, e = "utf8") {
  const t = Cn5[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r2, "utf8") : t.decoder.decode(`${t.prefix}${r2}`);
}
var Sn3 = Object.defineProperty;
var Rn5 = (r2, e, t) => e in r2 ? Sn3(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var W2 = (r2, e, t) => Rn5(r2, typeof e != "symbol" ? e + "" : e, t);
var Di5 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, W2(this, "keychain", /* @__PURE__ */ new Map()), W2(this, "name", Pt4), W2(this, "version", St6), W2(this, "initialized", false), W2(this, "storagePrefix", B3), W2(this, "init", async () => {
      if (!this.initialized) {
        const s = await this.getKeyChain();
        typeof s < "u" && (this.keychain = s), this.initialized = true;
      }
    }), W2(this, "has", (s) => (this.isInitialized(), this.keychain.has(s))), W2(this, "set", async (s, i3) => {
      this.isInitialized(), this.keychain.set(s, i3), await this.persist();
    }), W2(this, "get", (s) => {
      this.isInitialized();
      const i3 = this.keychain.get(s);
      if (typeof i3 > "u") {
        const { message: n3 } = te4("NO_MATCHING_KEY", `${this.name}: ${s}`);
        throw new Error(n3);
      }
      return i3;
    }), W2(this, "del", async (s) => {
      this.isInitialized(), this.keychain.delete(s), await this.persist();
    }), this.core = e, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, ro4(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? oo3(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var On5 = Object.defineProperty;
var An3 = (r2, e, t) => e in r2 ? On5(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var S5 = (r2, e, t) => An3(r2, typeof e != "symbol" ? e + "" : e, t);
var vi4 = class {
  constructor(e, t, s) {
    this.core = e, this.logger = t, S5(this, "name", Tt5), S5(this, "keychain"), S5(this, "randomSessionIdentifier", oi4()), S5(this, "initialized", false), S5(this, "init", async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }), S5(this, "hasKeys", (i3) => (this.isInitialized(), this.keychain.has(i3))), S5(this, "getClientId", async () => {
      this.isInitialized();
      const i3 = await this.getClientSeed(), n3 = Po(i3);
      return Qe(n3.publicKey);
    }), S5(this, "generateKeyPair", () => {
      this.isInitialized();
      const i3 = ri4();
      return this.setPrivateKey(i3.publicKey, i3.privateKey);
    }), S5(this, "signJWT", async (i3) => {
      this.isInitialized();
      const n3 = await this.getClientSeed(), o3 = Po(n3), a2 = this.randomSessionIdentifier, c6 = Ct5;
      return await Qo(a2, i3, c6, o3);
    }), S5(this, "generateSharedKey", (i3, n3, o3) => {
      this.isInitialized();
      const a2 = this.getPrivateKey(i3), c6 = si4(a2, n3);
      return this.setSymKey(c6, o3);
    }), S5(this, "setSymKey", async (i3, n3) => {
      this.isInitialized();
      const o3 = n3 || ii4(i3);
      return await this.keychain.set(o3, i3), o3;
    }), S5(this, "deleteKeyPair", async (i3) => {
      this.isInitialized(), await this.keychain.del(i3);
    }), S5(this, "deleteSymKey", async (i3) => {
      this.isInitialized(), await this.keychain.del(i3);
    }), S5(this, "encode", async (i3, n3, o3) => {
      this.isInitialized();
      const a2 = rr4(o3), c6 = safeJsonStringify(n3);
      if (pi4(a2)) return fi4(c6, o3 == null ? void 0 : o3.encoding);
      if (hi4(a2)) {
        const g3 = a2.senderPublicKey, _7 = a2.receiverPublicKey;
        i3 = await this.generateSharedKey(g3, _7);
      }
      const h6 = this.getSymKey(i3), { type: u3, senderPublicKey: d5 } = a2;
      return ai4({ type: u3, symKey: h6, message: c6, senderPublicKey: d5, encoding: o3 == null ? void 0 : o3.encoding });
    }), S5(this, "decode", async (i3, n3, o3) => {
      this.isInitialized();
      const a2 = di4(n3, o3);
      if (pi4(a2)) {
        const c6 = li4(n3, o3 == null ? void 0 : o3.encoding);
        return safeJsonParse(c6);
      }
      if (hi4(a2)) {
        const c6 = a2.receiverPublicKey, h6 = a2.senderPublicKey;
        i3 = await this.generateSharedKey(c6, h6);
      }
      try {
        const c6 = this.getSymKey(i3), h6 = ui4({ symKey: c6, encoded: n3, encoding: o3 == null ? void 0 : o3.encoding });
        return safeJsonParse(h6);
      } catch (c6) {
        this.logger.error(`Failed to decode message from topic: '${i3}', clientId: '${await this.getClientId()}'`), this.logger.error(c6);
      }
    }), S5(this, "getPayloadType", (i3, n3 = At4) => {
      const o3 = Fe4({ encoded: i3, encoding: n3 });
      return fe3(o3.type);
    }), S5(this, "getPayloadSenderPublicKey", (i3, n3 = At4) => {
      const o3 = Fe4({ encoded: i3, encoding: n3 });
      return o3.senderPublicKey ? toString(o3.senderPublicKey, V5) : void 0;
    }), this.core = e, this.logger = E(t, this.name), this.keychain = s || new Di5(this.core, this.logger);
  }
  get context() {
    return y(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(ke6);
    } catch {
      e = oi4(), await this.keychain.set(ke6, e);
    }
    return Pn3(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var xn5 = Object.defineProperty;
var Nn3 = Object.defineProperties;
var $n3 = Object.getOwnPropertyDescriptors;
var wi5 = Object.getOwnPropertySymbols;
var zn5 = Object.prototype.hasOwnProperty;
var Ln5 = Object.prototype.propertyIsEnumerable;
var Ve5 = (r2, e, t) => e in r2 ? xn5(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var kn5 = (r2, e) => {
  for (var t in e || (e = {})) zn5.call(e, t) && Ve5(r2, t, e[t]);
  if (wi5) for (var t of wi5(e)) Ln5.call(e, t) && Ve5(r2, t, e[t]);
  return r2;
};
var jn5 = (r2, e) => Nn3(r2, $n3(e));
var k6 = (r2, e, t) => Ve5(r2, typeof e != "symbol" ? e + "" : e, t);
var _i3 = class extends y2 {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, k6(this, "messages", /* @__PURE__ */ new Map()), k6(this, "messagesWithoutClientAck", /* @__PURE__ */ new Map()), k6(this, "name", Rt6), k6(this, "version", Ot5), k6(this, "initialized", false), k6(this, "storagePrefix", B3), k6(this, "init", async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const s = await this.getRelayerMessages();
          typeof s < "u" && (this.messages = s);
          const i3 = await this.getRelayerMessagesWithoutClientAck();
          typeof i3 < "u" && (this.messagesWithoutClientAck = i3), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (s) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s);
        } finally {
          this.initialized = true;
        }
      }
    }), k6(this, "set", async (s, i3, n3) => {
      this.isInitialized();
      const o3 = ci4(i3);
      let a2 = this.messages.get(s);
      if (typeof a2 > "u" && (a2 = {}), typeof a2[o3] < "u") return o3;
      if (a2[o3] = i3, this.messages.set(s, a2), n3 === le6.inbound) {
        const c6 = this.messagesWithoutClientAck.get(s) || {};
        this.messagesWithoutClientAck.set(s, jn5(kn5({}, c6), { [o3]: i3 }));
      }
      return await this.persist(), o3;
    }), k6(this, "get", (s) => {
      this.isInitialized();
      let i3 = this.messages.get(s);
      return typeof i3 > "u" && (i3 = {}), i3;
    }), k6(this, "getWithoutAck", (s) => {
      this.isInitialized();
      const i3 = {};
      for (const n3 of s) {
        const o3 = this.messagesWithoutClientAck.get(n3) || {};
        i3[n3] = Object.values(o3);
      }
      return i3;
    }), k6(this, "has", (s, i3) => {
      this.isInitialized();
      const n3 = this.get(s), o3 = ci4(i3);
      return typeof n3[o3] < "u";
    }), k6(this, "ack", async (s, i3) => {
      this.isInitialized();
      const n3 = this.messagesWithoutClientAck.get(s);
      if (typeof n3 > "u") return;
      const o3 = ci4(i3);
      delete n3[o3], Object.keys(n3).length === 0 ? this.messagesWithoutClientAck.delete(s) : this.messagesWithoutClientAck.set(s, n3), await this.persist();
    }), k6(this, "del", async (s) => {
      this.isInitialized(), this.messages.delete(s), this.messagesWithoutClientAck.delete(s), await this.persist();
    }), this.logger = E(e, this.name), this.core = t;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get storageKeyWithoutClientAck() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck";
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, ro4(e));
  }
  async setRelayerMessagesWithoutClientAck(e) {
    await this.core.storage.setItem(this.storageKeyWithoutClientAck, ro4(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? oo3(e) : void 0;
  }
  async getRelayerMessagesWithoutClientAck() {
    const e = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
    return typeof e < "u" ? oo3(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages), await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Un5 = Object.defineProperty;
var Mn5 = Object.defineProperties;
var Fn5 = Object.getOwnPropertyDescriptors;
var Ei5 = Object.getOwnPropertySymbols;
var Kn5 = Object.prototype.hasOwnProperty;
var Bn5 = Object.prototype.propertyIsEnumerable;
var qe5 = (r2, e, t) => e in r2 ? Un5(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Ie5 = (r2, e) => {
  for (var t in e || (e = {})) Kn5.call(e, t) && qe5(r2, t, e[t]);
  if (Ei5) for (var t of Ei5(e)) Bn5.call(e, t) && qe5(r2, t, e[t]);
  return r2;
};
var Ge6 = (r2, e) => Mn5(r2, Fn5(e));
var V6 = (r2, e, t) => qe5(r2, typeof e != "symbol" ? e + "" : e, t);
var Vn5 = class extends m {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, V6(this, "events", new import_events8.EventEmitter()), V6(this, "name", At5), V6(this, "queue", /* @__PURE__ */ new Map()), V6(this, "publishTimeout", (0, import_time5.toMiliseconds)(import_time5.ONE_MINUTE)), V6(this, "initialPublishTimeout", (0, import_time5.toMiliseconds)(import_time5.ONE_SECOND * 15)), V6(this, "needsTransportRestart", false), V6(this, "publish", async (s, i3, n3) => {
      var o3;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: s, message: i3, opts: n3 } });
      const a2 = (n3 == null ? void 0 : n3.ttl) || je5, c6 = bi4(n3), h6 = (n3 == null ? void 0 : n3.prompt) || false, u3 = (n3 == null ? void 0 : n3.tag) || 0, d5 = (n3 == null ? void 0 : n3.id) || getBigIntRpcId().toString(), g3 = { topic: s, message: i3, opts: { ttl: a2, relay: c6, prompt: h6, tag: u3, id: d5, attestation: n3 == null ? void 0 : n3.attestation, tvf: n3 == null ? void 0 : n3.tvf } }, _7 = `Failed to publish payload, please try again. id:${d5} tag:${u3}`;
      try {
        const l5 = new Promise(async (b4) => {
          const x9 = ({ id: D6 }) => {
            g3.opts.id === D6 && (this.removeRequestFromQueue(D6), this.relayer.events.removeListener(C4.publish, x9), b4(g3));
          };
          this.relayer.events.on(C4.publish, x9);
          const I5 = uo3(new Promise((D6, j5) => {
            this.rpcPublish({ topic: s, message: i3, ttl: a2, prompt: h6, tag: u3, id: d5, attestation: n3 == null ? void 0 : n3.attestation, tvf: n3 == null ? void 0 : n3.tvf }).then(D6).catch((T4) => {
              this.logger.warn(T4, T4 == null ? void 0 : T4.message), j5(T4);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${d5} tag:${u3}`);
          try {
            await I5, this.events.removeListener(C4.publish, x9);
          } catch (D6) {
            this.queue.set(d5, Ge6(Ie5({}, g3), { attempt: 1 })), this.logger.warn(D6, D6 == null ? void 0 : D6.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: d5, topic: s, message: i3, opts: n3 } }), await uo3(l5, this.publishTimeout, _7);
      } catch (l5) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(l5), (o3 = n3 == null ? void 0 : n3.internal) != null && o3.throwOnFailedPublish) throw l5;
      } finally {
        this.queue.delete(d5);
      }
    }), V6(this, "on", (s, i3) => {
      this.events.on(s, i3);
    }), V6(this, "once", (s, i3) => {
      this.events.once(s, i3);
    }), V6(this, "off", (s, i3) => {
      this.events.off(s, i3);
    }), V6(this, "removeListener", (s, i3) => {
      this.events.removeListener(s, i3);
    }), this.relayer = e, this.logger = E(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y(this.logger);
  }
  async rpcPublish(e) {
    var t, s, i3, n3;
    const { topic: o3, message: a2, ttl: c6 = je5, prompt: h6, tag: u3, id: d5, attestation: g3, tvf: _7 } = e, l5 = { method: wi4(bi4().protocol).publish, params: Ie5({ topic: o3, message: a2, ttl: c6, prompt: h6, tag: u3, attestation: g3 }, _7), id: d5 };
    ae3((t = l5.params) == null ? void 0 : t.prompt) && ((s = l5.params) == null || delete s.prompt), ae3((i3 = l5.params) == null ? void 0 : i3.tag) && ((n3 = l5.params) == null || delete n3.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: l5 });
    const b4 = await this.relayer.request(l5);
    return this.relayer.events.emit(C4.publish, e), this.logger.debug("Successfully Published Payload"), b4;
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e, t) => {
      const s = e.attempt + 1;
      this.queue.set(t, Ge6(Ie5({}, e), { attempt: s }));
      const { topic: i3, message: n3, opts: o3, attestation: a2 } = e;
      this.logger.warn({}, `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${s}`), await this.rpcPublish(Ge6(Ie5({}, e), { topic: i3, message: n3, ttl: o3.ttl, prompt: o3.prompt, tag: o3.tag, id: o3.id, attestation: a2, tvf: o3.tvf })), this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(C4.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(C4.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var qn5 = Object.defineProperty;
var Gn5 = (r2, e, t) => e in r2 ? qn5(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var re5 = (r2, e, t) => Gn5(r2, typeof e != "symbol" ? e + "" : e, t);
var Wn5 = class {
  constructor() {
    re5(this, "map", /* @__PURE__ */ new Map()), re5(this, "set", (e, t) => {
      const s = this.get(e);
      this.exists(e, t) || this.map.set(e, [...s, t]);
    }), re5(this, "get", (e) => this.map.get(e) || []), re5(this, "exists", (e, t) => this.get(e).includes(t)), re5(this, "delete", (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e)) return;
      const s = this.get(e);
      if (!this.exists(e, t)) return;
      const i3 = s.filter((n3) => n3 !== t);
      if (!i3.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, i3);
    }), re5(this, "clear", () => {
      this.map.clear();
    });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var Hn5 = Object.defineProperty;
var Yn5 = Object.defineProperties;
var Jn5 = Object.getOwnPropertyDescriptors;
var Ii3 = Object.getOwnPropertySymbols;
var Xn5 = Object.prototype.hasOwnProperty;
var Zn5 = Object.prototype.propertyIsEnumerable;
var We5 = (r2, e, t) => e in r2 ? Hn5(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var ge = (r2, e) => {
  for (var t in e || (e = {})) Xn5.call(e, t) && We5(r2, t, e[t]);
  if (Ii3) for (var t of Ii3(e)) Zn5.call(e, t) && We5(r2, t, e[t]);
  return r2;
};
var He4 = (r2, e) => Yn5(r2, Jn5(e));
var f9 = (r2, e, t) => We5(r2, typeof e != "symbol" ? e + "" : e, t);
var Ti4 = class extends P {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, f9(this, "subscriptions", /* @__PURE__ */ new Map()), f9(this, "topicMap", new Wn5()), f9(this, "events", new import_events8.EventEmitter()), f9(this, "name", Ut5), f9(this, "version", Mt4), f9(this, "pending", /* @__PURE__ */ new Map()), f9(this, "cached", []), f9(this, "initialized", false), f9(this, "storagePrefix", B3), f9(this, "subscribeTimeout", (0, import_time5.toMiliseconds)(import_time5.ONE_MINUTE)), f9(this, "initialSubscribeTimeout", (0, import_time5.toMiliseconds)(import_time5.ONE_SECOND * 15)), f9(this, "clientId"), f9(this, "batchSubscribeTopicsLimit", 500), f9(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = true;
    }), f9(this, "subscribe", async (s, i3) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s, opts: i3 } });
      try {
        const n3 = bi4(i3), o3 = { topic: s, relay: n3, transportType: i3 == null ? void 0 : i3.transportType };
        this.pending.set(s, o3);
        const a2 = await this.rpcSubscribe(s, n3, i3);
        return typeof a2 == "string" && (this.onSubscribe(a2, o3), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s, opts: i3 } })), a2;
      } catch (n3) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n3), n3;
      }
    }), f9(this, "unsubscribe", async (s, i3) => {
      this.isInitialized(), typeof (i3 == null ? void 0 : i3.id) < "u" ? await this.unsubscribeById(s, i3.id, i3) : await this.unsubscribeByTopic(s, i3);
    }), f9(this, "isSubscribed", (s) => new Promise((i3) => {
      i3(this.topicMap.topics.includes(s));
    })), f9(this, "isKnownTopic", (s) => new Promise((i3) => {
      i3(this.topicMap.topics.includes(s) || this.pending.has(s) || this.cached.some((n3) => n3.topic === s));
    })), f9(this, "on", (s, i3) => {
      this.events.on(s, i3);
    }), f9(this, "once", (s, i3) => {
      this.events.once(s, i3);
    }), f9(this, "off", (s, i3) => {
      this.events.off(s, i3);
    }), f9(this, "removeListener", (s, i3) => {
      this.events.removeListener(s, i3);
    }), f9(this, "start", async () => {
      await this.onConnect();
    }), f9(this, "stop", async () => {
      await this.onDisconnect();
    }), f9(this, "restart", async () => {
      await this.restore(), await this.onRestart();
    }), f9(this, "checkPending", async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
      const s = [];
      this.pending.forEach((i3) => {
        s.push(i3);
      }), await this.batchSubscribe(s);
    }), f9(this, "registerEventListeners", () => {
      this.relayer.core.heartbeat.on(r.pulse, async () => {
        await this.checkPending();
      }), this.events.on($4.created, async (s) => {
        const i3 = $4.created;
        this.logger.info(`Emitting ${i3}`), this.logger.debug({ type: "event", event: i3, data: s }), await this.persist();
      }), this.events.on($4.deleted, async (s) => {
        const i3 = $4.deleted;
        this.logger.info(`Emitting ${i3}`), this.logger.debug({ type: "event", event: i3, data: s }), await this.persist();
      });
    }), this.relayer = e, this.logger = E(t, this.name), this.clientId = "";
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  get hasAnyTopics() {
    return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
  }
  hasSubscription(e, t) {
    let s = false;
    try {
      s = this.getSubscription(e).topic === t;
    } catch {
    }
    return s;
  }
  reset() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const s = this.topicMap.get(e);
    await Promise.all(s.map(async (i3) => await this.unsubscribeById(e, i3, t)));
  }
  async unsubscribeById(e, t, s) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: s } });
    try {
      const i3 = bi4(s);
      await this.restartToComplete({ topic: e, id: t, relay: i3 }), await this.rpcUnsubscribe(e, t, i3);
      const n3 = de4("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, n3), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: s } });
    } catch (i3) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i3), i3;
    }
  }
  async rpcSubscribe(e, t, s) {
    var i3;
    (!s || (s == null ? void 0 : s.transportType) === Q4.relay) && await this.restartToComplete({ topic: e, id: e, relay: t });
    const n3 = { method: wi4(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n3 });
    const o3 = (i3 = s == null ? void 0 : s.internal) == null ? void 0 : i3.throwOnFailedPublish;
    try {
      const a2 = await this.getSubscriptionId(e);
      if ((s == null ? void 0 : s.transportType) === Q4.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(n3).catch((u3) => this.logger.warn(u3));
      }, (0, import_time5.toMiliseconds)(import_time5.ONE_SECOND)), a2;
      const c6 = new Promise(async (u3) => {
        const d5 = (g3) => {
          g3.topic === e && (this.events.removeListener($4.created, d5), u3(g3.id));
        };
        this.events.on($4.created, d5);
        try {
          const g3 = await uo3(new Promise((_7, l5) => {
            this.relayer.request(n3).catch((b4) => {
              this.logger.warn(b4, b4 == null ? void 0 : b4.message), l5(b4);
            }).then(_7);
          }), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);
          this.events.removeListener($4.created, d5), u3(g3);
        } catch {
        }
      }), h6 = await uo3(c6, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!h6 && o3) throw new Error(`Subscribing to ${e} failed, please try again`);
      return h6 ? a2 : null;
    } catch (a2) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(C4.connection_stalled), o3) throw a2;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const t = e[0].relay, s = { method: wi4(t.protocol).batchSubscribe, params: { topics: e.map((i3) => i3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s });
    try {
      await await uo3(new Promise((i3) => {
        this.relayer.request(s).catch((n3) => this.logger.warn(n3)).then(i3);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(C4.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const t = e[0].relay, s = { method: wi4(t.protocol).batchFetchMessages, params: { topics: e.map((n3) => n3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s });
    let i3;
    try {
      i3 = await await uo3(new Promise((n3, o3) => {
        this.relayer.request(s).catch((a2) => {
          this.logger.warn(a2), o3(a2);
        }).then(n3);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(C4.connection_stalled);
    }
    return i3;
  }
  rpcUnsubscribe(e, t, s) {
    const i3 = { method: wi4(s.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 }), this.relayer.request(i3);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, He4(ge({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, ge({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, s) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, s), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t);
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, ge({}, t)), this.topicMap.set(t.topic, e), this.events.emit($4.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: s } = te4("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(s);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const s = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(s.topic, e), this.events.emit($4.deleted, He4(ge({}, s), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit($4.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e = [...this.cached], t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let s = 0; s < t; s++) {
        const i3 = e.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i3);
      }
    }
    this.events.emit($4.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size) {
        const { message: t } = te4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(await Promise.all(e.map(async (t) => He4(ge({}, t), { id: await this.getSubscriptionId(t.topic) })))));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e);
    t && t.messages && (await xo3((0, import_time5.toMiliseconds)(import_time5.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete(e) {
    !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e), await this.relayer.transportOpen());
  }
  async getClientId() {
    return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
  }
  async getSubscriptionId(e) {
    return ci4(e + await this.getClientId());
  }
};
var Qn5 = Object.defineProperty;
var Ci5 = Object.getOwnPropertySymbols;
var eo3 = Object.prototype.hasOwnProperty;
var to3 = Object.prototype.propertyIsEnumerable;
var Ye5 = (r2, e, t) => e in r2 ? Qn5(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Pi7 = (r2, e) => {
  for (var t in e || (e = {})) eo3.call(e, t) && Ye5(r2, t, e[t]);
  if (Ci5) for (var t of Ci5(e)) to3.call(e, t) && Ye5(r2, t, e[t]);
  return r2;
};
var y7 = (r2, e, t) => Ye5(r2, typeof e != "symbol" ? e + "" : e, t);
var Si3 = class extends d {
  constructor(e) {
    super(e), y7(this, "protocol", "wc"), y7(this, "version", 2), y7(this, "core"), y7(this, "logger"), y7(this, "events", new import_events8.EventEmitter()), y7(this, "provider"), y7(this, "messages"), y7(this, "subscriber"), y7(this, "publisher"), y7(this, "name", $t2), y7(this, "transportExplicitlyClosed", false), y7(this, "initialized", false), y7(this, "connectionAttemptInProgress", false), y7(this, "relayUrl"), y7(this, "projectId"), y7(this, "packageName"), y7(this, "bundleId"), y7(this, "hasExperiencedNetworkDisruption", false), y7(this, "pingTimeout"), y7(this, "heartBeatTimeout", (0, import_time5.toMiliseconds)(import_time5.THIRTY_SECONDS + import_time5.FIVE_SECONDS)), y7(this, "reconnectTimeout"), y7(this, "connectPromise"), y7(this, "reconnectInProgress", false), y7(this, "requestsInFlight", []), y7(this, "connectTimeout", (0, import_time5.toMiliseconds)(import_time5.ONE_SECOND * 15)), y7(this, "request", async (t) => {
      var s, i3;
      this.logger.debug("Publishing Request Payload");
      const n3 = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: n3, method: t.method, topic: (s = t.params) == null ? void 0 : s.topic }, "relayer.request - publishing...");
        const o3 = `${n3}:${((i3 = t.params) == null ? void 0 : i3.tag) || ""}`;
        this.requestsInFlight.push(o3);
        const a2 = await this.provider.request(t);
        return this.requestsInFlight = this.requestsInFlight.filter((c6) => c6 !== o3), a2;
      } catch (o3) {
        throw this.logger.debug(`Failed to Publish Request: ${n3}`), o3;
      }
    }), y7(this, "resetPingTimeout", () => {
      et3() && (clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
        var t, s, i3, n3;
        try {
          this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (n3 = (i3 = (s = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : s.socket) == null ? void 0 : i3.terminate) == null || n3.call(i3);
        } catch (o3) {
          this.logger.warn(o3, o3 == null ? void 0 : o3.message);
        }
      }, this.heartBeatTimeout));
    }), y7(this, "onPayloadHandler", (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }), y7(this, "onConnectHandler", () => {
      this.logger.warn({}, "Relayer connected "), this.startPingTimeout(), this.events.emit(C4.connect);
    }), y7(this, "onDisconnectHandler", () => {
      this.logger.warn({}, "Relayer disconnected "), this.requestsInFlight = [], this.onProviderDisconnect();
    }), y7(this, "onProviderErrorHandler", (t) => {
      this.logger.fatal(`Fatal socket error: ${t.message}`), this.events.emit(C4.error, t), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }), y7(this, "registerProviderListeners", () => {
      this.provider.on(L3.payload, this.onPayloadHandler), this.provider.on(L3.connect, this.onConnectHandler), this.provider.on(L3.disconnect, this.onDisconnectHandler), this.provider.on(L3.error, this.onProviderErrorHandler);
    }), this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? E(e.logger, this.name) : (0, import_pino.default)(k({ level: e.logger || Nt5 })), this.messages = new _i3(this.logger, e.core), this.subscriber = new Ti4(this, this.logger), this.publisher = new Vn5(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || Ue6, this.projectId = e.projectId, zr4() ? this.packageName = Yr4() : Jr4() && (this.bundleId = Yr4()), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.subscriber.hasAnyTopics) try {
      await this.transportOpen();
    } catch (e) {
      this.logger.warn(e, e == null ? void 0 : e.message);
    }
  }
  get context() {
    return y(this.logger);
  }
  get connected() {
    var e, t, s;
    return ((s = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s.readyState) === 1 || false;
  }
  get connecting() {
    var e, t, s;
    return ((s = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s.readyState) === 0 || this.connectPromise !== void 0 || false;
  }
  async publish(e, t, s) {
    this.isInitialized(), await this.publisher.publish(e, t, s), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now(), transportType: Q4.relay }, le6.outbound);
  }
  async subscribe(e, t) {
    var s, i3, n3;
    this.isInitialized(), (!(t != null && t.transportType) || (t == null ? void 0 : t.transportType) === "relay") && await this.toEstablishConnection();
    const o3 = typeof ((s = t == null ? void 0 : t.internal) == null ? void 0 : s.throwOnFailedPublish) > "u" ? true : (i3 = t == null ? void 0 : t.internal) == null ? void 0 : i3.throwOnFailedPublish;
    let a2 = ((n3 = this.subscriber.topicMap.get(e)) == null ? void 0 : n3[0]) || "", c6;
    const h6 = (u3) => {
      u3.topic === e && (this.subscriber.off($4.created, h6), c6());
    };
    return await Promise.all([new Promise((u3) => {
      c6 = u3, this.subscriber.on($4.created, h6);
    }), new Promise(async (u3, d5) => {
      a2 = await this.subscriber.subscribe(e, Pi7({ internal: { throwOnFailedPublish: o3 } }, t)).catch((g3) => {
        o3 && d5(g3);
      }) || a2, u3();
    })]), a2;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await uo3(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.warn("Starting WS connection skipped because the client has no topics to work with.");
      return;
    }
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t, s) => {
      await this.connect(e).then(t).catch(s).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Zi3()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e.sort((s, i3) => s.publishedAt - i3.publishedAt);
    this.logger.debug(`Batch of ${t.length} message events sorted`);
    for (const s of t) try {
      await this.onMessageEvent(s);
    } catch (i3) {
      this.logger.warn(i3, "Error while processing batch message event: " + (i3 == null ? void 0 : i3.message));
    }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e, t) {
    const { topic: s } = e;
    if (!t.sessionExists) {
      const i3 = po3(import_time5.FIVE_MINUTES), n3 = { topic: s, expiry: i3, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(s, n3);
    }
    this.events.emit(C4.message, e), await this.recordMessageEvent(e, le6.inbound);
  }
  async connect(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    let t = 1;
    for (; t < 6; ) {
      try {
        if (this.transportExplicitlyClosed) break;
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`), await this.createProvider(), await new Promise(async (s, i3) => {
          const n3 = () => {
            i3(new Error("Connection interrupted while trying to subscribe"));
          };
          this.provider.once(L3.disconnect, n3), await uo3(new Promise((o3, a2) => {
            this.provider.connect().then(o3).catch(a2);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o3) => {
            i3(o3);
          }).finally(() => {
            this.provider.off(L3.disconnect, n3), clearTimeout(this.reconnectTimeout);
          }), await new Promise(async (o3, a2) => {
            const c6 = () => {
              a2(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(L3.disconnect, c6), await this.subscriber.start().then(o3).catch(a2).finally(() => {
              this.provider.off(L3.disconnect, c6);
            });
          }), this.hasExperiencedNetworkDisruption = false, s();
        });
      } catch (s) {
        await this.subscriber.stop();
        const i3 = s;
        this.logger.warn({}, i3.message), this.hasExperiencedNetworkDisruption = true;
      } finally {
        this.connectionAttemptInProgress = false;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);
        break;
      }
      await new Promise((s) => setTimeout(s, (0, import_time5.toMiliseconds)(t * 1))), t++;
    }
  }
  startPingTimeout() {
    var e, t, s, i3, n3;
    if (et3()) try {
      (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((n3 = (i3 = (s = this.provider) == null ? void 0 : s.connection) == null ? void 0 : i3.socket) == null || n3.on("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (o3) {
      this.logger.warn(o3, o3 == null ? void 0 : o3.message);
    }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o(new f(Qr3({ sdkVersion: _e6, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e, t) {
    const { topic: s, message: i3 } = e;
    await this.messages.set(s, i3, t);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: s } = e;
    if (!s || s.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${s}`), true;
    if (!await this.subscriber.isKnownTopic(t)) return this.logger.warn(`Ignoring message for unknown topic ${t}`), true;
    const i3 = this.messages.has(t, s);
    return i3 && this.logger.warn(`Ignoring duplicate message: ${s}`), i3;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(zt5)) return;
      const t = e.params, { topic: s, message: i3, publishedAt: n3, attestation: o3 } = t.data, a2 = { topic: s, message: i3, publishedAt: n3, transportType: Q4.relay, attestation: o3 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Pi7({ type: "event", event: t.id }, a2)), this.events.emit(t.id, a2), await this.acknowledgePayload(e), await this.onMessageEvent(a2);
    } else isJsonRpcResponse(e) && this.events.emit(C4.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (await this.recordMessageEvent(e, le6.inbound), this.events.emit(C4.message, e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(L3.payload, this.onPayloadHandler), this.provider.off(L3.connect, this.onConnectHandler), this.provider.off(L3.disconnect, this.onDisconnectHandler), this.provider.off(L3.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await Zi3();
    Qi3(async (t) => {
      e !== t && (e = t, t ? await this.transportOpen().catch((s) => this.logger.error(s, s == null ? void 0 : s.message)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    });
  }
  async onProviderDisconnect() {
    clearTimeout(this.pingTimeout), this.events.emit(C4.disconnect), this.connectionAttemptInProgress = false, !this.reconnectInProgress && (this.reconnectInProgress = true, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e, e == null ? void 0 : e.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = false;
    }, (0, import_time5.toMiliseconds)(Lt5)))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && await this.connect();
  }
};
function io3() {
}
function Ri5(r2) {
  if (!r2 || typeof r2 != "object") return false;
  const e = Object.getPrototypeOf(r2);
  return e === null || e === Object.prototype || Object.getPrototypeOf(e) === null ? Object.prototype.toString.call(r2) === "[object Object]" : false;
}
function Oi3(r2) {
  return Object.getOwnPropertySymbols(r2).filter((e) => Object.prototype.propertyIsEnumerable.call(r2, e));
}
function Ai3(r2) {
  return r2 == null ? r2 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r2);
}
var so3 = "[object RegExp]";
var ro5 = "[object String]";
var no4 = "[object Number]";
var oo4 = "[object Boolean]";
var xi4 = "[object Arguments]";
var ao5 = "[object Symbol]";
var co4 = "[object Date]";
var ho4 = "[object Map]";
var lo4 = "[object Set]";
var uo4 = "[object Array]";
var go4 = "[object Function]";
var po4 = "[object ArrayBuffer]";
var Je3 = "[object Object]";
var yo4 = "[object Error]";
var bo4 = "[object DataView]";
var mo4 = "[object Uint8Array]";
var fo4 = "[object Uint8ClampedArray]";
var Do4 = "[object Uint16Array]";
var vo4 = "[object Uint32Array]";
var wo4 = "[object BigUint64Array]";
var _o4 = "[object Int8Array]";
var Eo4 = "[object Int16Array]";
var Io4 = "[object Int32Array]";
var To4 = "[object BigInt64Array]";
var Co4 = "[object Float32Array]";
var Po5 = "[object Float64Array]";
function So4(r2, e) {
  return r2 === e || Number.isNaN(r2) && Number.isNaN(e);
}
function Ro4(r2, e, t) {
  return pe3(r2, e, void 0, void 0, void 0, void 0, t);
}
function pe3(r2, e, t, s, i3, n3, o3) {
  const a2 = o3(r2, e, t, s, i3, n3);
  if (a2 !== void 0) return a2;
  if (typeof r2 == typeof e) switch (typeof r2) {
    case "bigint":
    case "string":
    case "boolean":
    case "symbol":
    case "undefined":
      return r2 === e;
    case "number":
      return r2 === e || Object.is(r2, e);
    case "function":
      return r2 === e;
    case "object":
      return ye3(r2, e, n3, o3);
  }
  return ye3(r2, e, n3, o3);
}
function ye3(r2, e, t, s) {
  if (Object.is(r2, e)) return true;
  let i3 = Ai3(r2), n3 = Ai3(e);
  if (i3 === xi4 && (i3 = Je3), n3 === xi4 && (n3 = Je3), i3 !== n3) return false;
  switch (i3) {
    case ro5:
      return r2.toString() === e.toString();
    case no4: {
      const c6 = r2.valueOf(), h6 = e.valueOf();
      return So4(c6, h6);
    }
    case oo4:
    case co4:
    case ao5:
      return Object.is(r2.valueOf(), e.valueOf());
    case so3:
      return r2.source === e.source && r2.flags === e.flags;
    case go4:
      return r2 === e;
  }
  t = t ?? /* @__PURE__ */ new Map();
  const o3 = t.get(r2), a2 = t.get(e);
  if (o3 != null && a2 != null) return o3 === e;
  t.set(r2, e), t.set(e, r2);
  try {
    switch (i3) {
      case ho4: {
        if (r2.size !== e.size) return false;
        for (const [c6, h6] of r2.entries()) if (!e.has(c6) || !pe3(h6, e.get(c6), c6, r2, e, t, s)) return false;
        return true;
      }
      case lo4: {
        if (r2.size !== e.size) return false;
        const c6 = Array.from(r2.values()), h6 = Array.from(e.values());
        for (let u3 = 0; u3 < c6.length; u3++) {
          const d5 = c6[u3], g3 = h6.findIndex((_7) => pe3(d5, _7, void 0, r2, e, t, s));
          if (g3 === -1) return false;
          h6.splice(g3, 1);
        }
        return true;
      }
      case uo4:
      case mo4:
      case fo4:
      case Do4:
      case vo4:
      case wo4:
      case _o4:
      case Eo4:
      case Io4:
      case To4:
      case Co4:
      case Po5: {
        if (typeof Buffer < "u" && Buffer.isBuffer(r2) !== Buffer.isBuffer(e) || r2.length !== e.length) return false;
        for (let c6 = 0; c6 < r2.length; c6++) if (!pe3(r2[c6], e[c6], c6, r2, e, t, s)) return false;
        return true;
      }
      case po4:
        return r2.byteLength !== e.byteLength ? false : ye3(new Uint8Array(r2), new Uint8Array(e), t, s);
      case bo4:
        return r2.byteLength !== e.byteLength || r2.byteOffset !== e.byteOffset ? false : ye3(new Uint8Array(r2), new Uint8Array(e), t, s);
      case yo4:
        return r2.name === e.name && r2.message === e.message;
      case Je3: {
        if (!(ye3(r2.constructor, e.constructor, t, s) || Ri5(r2) && Ri5(e))) return false;
        const h6 = [...Object.keys(r2), ...Oi3(r2)], u3 = [...Object.keys(e), ...Oi3(e)];
        if (h6.length !== u3.length) return false;
        for (let d5 = 0; d5 < h6.length; d5++) {
          const g3 = h6[d5], _7 = r2[g3];
          if (!Object.hasOwn(e, g3)) return false;
          const l5 = e[g3];
          if (!pe3(_7, l5, g3, r2, e, t, s)) return false;
        }
        return true;
      }
      default:
        return false;
    }
  } finally {
    t.delete(r2), t.delete(e);
  }
}
function Oo4(r2, e) {
  return Ro4(r2, e, io3);
}
var Ao4 = Object.defineProperty;
var Ni3 = Object.getOwnPropertySymbols;
var xo4 = Object.prototype.hasOwnProperty;
var No4 = Object.prototype.propertyIsEnumerable;
var Xe3 = (r2, e, t) => e in r2 ? Ao4(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var $i4 = (r2, e) => {
  for (var t in e || (e = {})) xo4.call(e, t) && Xe3(r2, t, e[t]);
  if (Ni3) for (var t of Ni3(e)) No4.call(e, t) && Xe3(r2, t, e[t]);
  return r2;
};
var z7 = (r2, e, t) => Xe3(r2, typeof e != "symbol" ? e + "" : e, t);
var zi5 = class extends f3 {
  constructor(e, t, s, i3 = B3, n3 = void 0) {
    super(e, t, s, i3), this.core = e, this.logger = t, this.name = s, z7(this, "map", /* @__PURE__ */ new Map()), z7(this, "version", kt5), z7(this, "cached", []), z7(this, "initialized", false), z7(this, "getKey"), z7(this, "storagePrefix", B3), z7(this, "recentlyDeleted", []), z7(this, "recentlyDeletedLimit", 200), z7(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o3) => {
        this.getKey && o3 !== null && !ae3(o3) ? this.map.set(this.getKey(o3), o3) : Li4(o3) ? this.map.set(o3.id, o3) : ji3(o3) && this.map.set(o3.topic, o3);
      }), this.cached = [], this.initialized = true);
    }), z7(this, "set", async (o3, a2) => {
      this.isInitialized(), this.map.has(o3) ? await this.update(o3, a2) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o3, value: a2 }), this.map.set(o3, a2), await this.persist());
    }), z7(this, "get", (o3) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o3 }), this.getData(o3))), z7(this, "getAll", (o3) => (this.isInitialized(), o3 ? this.values.filter((a2) => Object.keys(o3).every((c6) => Oo4(a2[c6], o3[c6]))) : this.values)), z7(this, "update", async (o3, a2) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o3, update: a2 });
      const c6 = $i4($i4({}, this.getData(o3)), a2);
      this.map.set(o3, c6), await this.persist();
    }), z7(this, "delete", async (o3, a2) => {
      this.isInitialized(), this.map.has(o3) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o3, reason: a2 }), this.map.delete(o3), this.addToRecentlyDeleted(o3), await this.persist());
    }), this.logger = E(t, this.name), this.storagePrefix = i3, this.getKey = n3;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: i3 } = te4("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(i3), new Error(i3);
      }
      const { message: s } = te4("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(s), new Error(s);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: t } = te4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var $o4 = Object.defineProperty;
var zo4 = (r2, e, t) => e in r2 ? $o4(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var p4 = (r2, e, t) => zo4(r2, typeof e != "symbol" ? e + "" : e, t);
var Li5 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, p4(this, "name", Ft5), p4(this, "version", Kt3), p4(this, "events", new import_events8.default()), p4(this, "pairings"), p4(this, "initialized", false), p4(this, "storagePrefix", B3), p4(this, "ignoredPayloadTypes", [Oe5]), p4(this, "registeredMethods", []), p4(this, "init", async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }), p4(this, "register", ({ methods: s }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...s])];
    }), p4(this, "create", async (s) => {
      this.isInitialized();
      const i3 = oi4(), n3 = await this.core.crypto.setSymKey(i3), o3 = po3(import_time5.FIVE_MINUTES), a2 = { protocol: xt5 }, c6 = { topic: n3, expiry: o3, relay: a2, active: false, methods: s == null ? void 0 : s.methods }, h6 = vi3({ protocol: this.core.protocol, version: this.core.version, topic: n3, symKey: i3, relay: a2, expiryTimestamp: o3, methods: s == null ? void 0 : s.methods });
      return this.events.emit(se5.create, c6), this.core.expirer.set(n3, o3), await this.pairings.set(n3, c6), await this.core.relayer.subscribe(n3, { transportType: s == null ? void 0 : s.transportType }), { topic: n3, uri: h6 };
    }), p4(this, "pair", async (s) => {
      this.isInitialized();
      const i3 = this.core.eventClient.createEvent({ properties: { topic: s == null ? void 0 : s.uri, trace: [G3.pairing_started] } });
      this.isValidPair(s, i3);
      const { topic: n3, symKey: o3, relay: a2, expiryTimestamp: c6, methods: h6 } = Ei4(s.uri);
      i3.props.properties.topic = n3, i3.addTrace(G3.pairing_uri_validation_success), i3.addTrace(G3.pairing_uri_not_expired);
      let u3;
      if (this.pairings.keys.includes(n3)) {
        if (u3 = this.pairings.get(n3), i3.addTrace(G3.existing_pairing), u3.active) throw i3.setError(Y5.active_pairing_already_exists), new Error(`Pairing already exists: ${n3}. Please try again with a new connection URI.`);
        i3.addTrace(G3.pairing_not_expired);
      }
      const d5 = c6 || po3(import_time5.FIVE_MINUTES), g3 = { topic: n3, relay: a2, expiry: d5, active: false, methods: h6 };
      this.core.expirer.set(n3, d5), await this.pairings.set(n3, g3), i3.addTrace(G3.store_new_pairing), s.activatePairing && await this.activate({ topic: n3 }), this.events.emit(se5.create, g3), i3.addTrace(G3.emit_inactive_pairing), this.core.crypto.keychain.has(n3) || await this.core.crypto.setSymKey(o3, n3), i3.addTrace(G3.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        i3.setError(Y5.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(n3, { relay: a2 });
      } catch (_7) {
        throw i3.setError(Y5.subscribe_pairing_topic_failure), _7;
      }
      return i3.addTrace(G3.subscribe_pairing_topic_success), g3;
    }), p4(this, "activate", async ({ topic: s }) => {
      this.isInitialized();
      const i3 = po3(import_time5.FIVE_MINUTES);
      this.core.expirer.set(s, i3), await this.pairings.update(s, { active: true, expiry: i3 });
    }), p4(this, "ping", async (s) => {
      this.isInitialized(), await this.isValidPing(s), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
      const { topic: i3 } = s;
      if (this.pairings.keys.includes(i3)) {
        const n3 = await this.sendRequest(i3, "wc_pairingPing", {}), { done: o3, resolve: a2, reject: c6 } = ao4();
        this.events.once(yo3("pairing_ping", n3), ({ error: h6 }) => {
          h6 ? c6(h6) : a2();
        }), await o3();
      }
    }), p4(this, "updateExpiry", async ({ topic: s, expiry: i3 }) => {
      this.isInitialized(), await this.pairings.update(s, { expiry: i3 });
    }), p4(this, "updateMetadata", async ({ topic: s, metadata: i3 }) => {
      this.isInitialized(), await this.pairings.update(s, { peerMetadata: i3 });
    }), p4(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), p4(this, "disconnect", async (s) => {
      this.isInitialized(), await this.isValidDisconnect(s);
      const { topic: i3 } = s;
      this.pairings.keys.includes(i3) && (await this.sendRequest(i3, "wc_pairingDelete", de4("USER_DISCONNECTED")), await this.deletePairing(i3));
    }), p4(this, "formatUriFromPairing", (s) => {
      this.isInitialized();
      const { topic: i3, relay: n3, expiry: o3, methods: a2 } = s, c6 = this.core.crypto.keychain.get(i3);
      return vi3({ protocol: this.core.protocol, version: this.core.version, topic: i3, symKey: c6, relay: n3, expiryTimestamp: o3, methods: a2 });
    }), p4(this, "sendRequest", async (s, i3, n3) => {
      const o3 = formatJsonRpcRequest(i3, n3), a2 = await this.core.crypto.encode(s, o3), c6 = ie5[i3].req;
      return this.core.history.set(s, o3), this.core.relayer.publish(s, a2, c6), o3.id;
    }), p4(this, "sendResult", async (s, i3, n3) => {
      const o3 = formatJsonRpcResult(s, n3), a2 = await this.core.crypto.encode(i3, o3), c6 = (await this.core.history.get(i3, s)).request.method, h6 = ie5[c6].res;
      await this.core.relayer.publish(i3, a2, h6), await this.core.history.resolve(o3);
    }), p4(this, "sendError", async (s, i3, n3) => {
      const o3 = formatJsonRpcError(s, n3), a2 = await this.core.crypto.encode(i3, o3), c6 = (await this.core.history.get(i3, s)).request.method, h6 = ie5[c6] ? ie5[c6].res : ie5.unregistered_method.res;
      await this.core.relayer.publish(i3, a2, h6), await this.core.history.resolve(o3);
    }), p4(this, "deletePairing", async (s, i3) => {
      await this.core.relayer.unsubscribe(s), await Promise.all([this.pairings.delete(s, de4("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(s), i3 ? Promise.resolve() : this.core.expirer.del(s)]);
    }), p4(this, "cleanup", async () => {
      const s = this.pairings.getAll().filter((i3) => go3(i3.expiry));
      await Promise.all(s.map((i3) => this.deletePairing(i3.topic)));
    }), p4(this, "onRelayEventRequest", async (s) => {
      const { topic: i3, payload: n3 } = s;
      switch (n3.method) {
        case "wc_pairingPing":
          return await this.onPairingPingRequest(i3, n3);
        case "wc_pairingDelete":
          return await this.onPairingDeleteRequest(i3, n3);
        default:
          return await this.onUnknownRpcMethodRequest(i3, n3);
      }
    }), p4(this, "onRelayEventResponse", async (s) => {
      const { topic: i3, payload: n3 } = s, o3 = (await this.core.history.get(i3, n3.id)).request.method;
      switch (o3) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i3, n3);
        default:
          return this.onUnknownRpcMethodResponse(o3);
      }
    }), p4(this, "onPairingPingRequest", async (s, i3) => {
      const { id: n3 } = i3;
      try {
        this.isValidPing({ topic: s }), await this.sendResult(n3, s, true), this.events.emit(se5.ping, { id: n3, topic: s });
      } catch (o3) {
        await this.sendError(n3, s, o3), this.logger.error(o3);
      }
    }), p4(this, "onPairingPingResponse", (s, i3) => {
      const { id: n3 } = i3;
      setTimeout(() => {
        isJsonRpcResult(i3) ? this.events.emit(yo3("pairing_ping", n3), {}) : isJsonRpcError(i3) && this.events.emit(yo3("pairing_ping", n3), { error: i3.error });
      }, 500);
    }), p4(this, "onPairingDeleteRequest", async (s, i3) => {
      const { id: n3 } = i3;
      try {
        this.isValidDisconnect({ topic: s }), await this.deletePairing(s), this.events.emit(se5.delete, { id: n3, topic: s });
      } catch (o3) {
        await this.sendError(n3, s, o3), this.logger.error(o3);
      }
    }), p4(this, "onUnknownRpcMethodRequest", async (s, i3) => {
      const { id: n3, method: o3 } = i3;
      try {
        if (this.registeredMethods.includes(o3)) return;
        const a2 = de4("WC_METHOD_UNSUPPORTED", o3);
        await this.sendError(n3, s, a2), this.logger.error(a2);
      } catch (a2) {
        await this.sendError(n3, s, a2), this.logger.error(a2);
      }
    }), p4(this, "onUnknownRpcMethodResponse", (s) => {
      this.registeredMethods.includes(s) || this.logger.error(de4("WC_METHOD_UNSUPPORTED", s));
    }), p4(this, "isValidPair", (s, i3) => {
      var n3;
      if (!Vi3(s)) {
        const { message: a2 } = te4("MISSING_OR_INVALID", `pair() params: ${s}`);
        throw i3.setError(Y5.malformed_pairing_uri), new Error(a2);
      }
      if (!Bi3(s.uri)) {
        const { message: a2 } = te4("MISSING_OR_INVALID", `pair() uri: ${s.uri}`);
        throw i3.setError(Y5.malformed_pairing_uri), new Error(a2);
      }
      const o3 = Ei4(s == null ? void 0 : s.uri);
      if (!((n3 = o3 == null ? void 0 : o3.relay) != null && n3.protocol)) {
        const { message: a2 } = te4("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw i3.setError(Y5.malformed_pairing_uri), new Error(a2);
      }
      if (!(o3 != null && o3.symKey)) {
        const { message: a2 } = te4("MISSING_OR_INVALID", "pair() uri#symKey");
        throw i3.setError(Y5.malformed_pairing_uri), new Error(a2);
      }
      if (o3 != null && o3.expiryTimestamp && (0, import_time5.toMiliseconds)(o3 == null ? void 0 : o3.expiryTimestamp) < Date.now()) {
        i3.setError(Y5.pairing_expired);
        const { message: a2 } = te4("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a2);
      }
    }), p4(this, "isValidPing", async (s) => {
      if (!Vi3(s)) {
        const { message: n3 } = te4("MISSING_OR_INVALID", `ping() params: ${s}`);
        throw new Error(n3);
      }
      const { topic: i3 } = s;
      await this.isValidPairingTopic(i3);
    }), p4(this, "isValidDisconnect", async (s) => {
      if (!Vi3(s)) {
        const { message: n3 } = te4("MISSING_OR_INVALID", `disconnect() params: ${s}`);
        throw new Error(n3);
      }
      const { topic: i3 } = s;
      await this.isValidPairingTopic(i3);
    }), p4(this, "isValidPairingTopic", async (s) => {
      if (!q4(s, false)) {
        const { message: i3 } = te4("MISSING_OR_INVALID", `pairing topic should be a string: ${s}`);
        throw new Error(i3);
      }
      if (!this.pairings.keys.includes(s)) {
        const { message: i3 } = te4("NO_MATCHING_KEY", `pairing topic doesn't exist: ${s}`);
        throw new Error(i3);
      }
      if (go3(this.pairings.get(s).expiry)) {
        await this.deletePairing(s);
        const { message: i3 } = te4("EXPIRED", `pairing topic: ${s}`);
        throw new Error(i3);
      }
    }), this.core = e, this.logger = E(t, this.name), this.pairings = new zi5(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(C4.message, async (e) => {
      const { topic: t, message: s, transportType: i3 } = e;
      if (this.pairings.keys.includes(t) && i3 !== Q4.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s))) try {
        const n3 = await this.core.crypto.decode(t, s);
        isJsonRpcRequest(n3) ? (this.core.history.set(t, n3), await this.onRelayEventRequest({ topic: t, payload: n3 })) : isJsonRpcResponse(n3) && (await this.core.history.resolve(n3), await this.onRelayEventResponse({ topic: t, payload: n3 }), this.core.history.delete(t, n3.id)), await this.core.relayer.messages.ack(t, s);
      } catch (n3) {
        this.logger.error(n3);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(F5.expired, async (e) => {
      const { topic: t } = ho3(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(se5.expire, { topic: t }));
    });
  }
};
var Lo4 = Object.defineProperty;
var ko4 = (r2, e, t) => e in r2 ? Lo4(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var R5 = (r2, e, t) => ko4(r2, typeof e != "symbol" ? e + "" : e, t);
var ki5 = class extends I {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, R5(this, "records", /* @__PURE__ */ new Map()), R5(this, "events", new import_events8.EventEmitter()), R5(this, "name", Bt5), R5(this, "version", Vt3), R5(this, "cached", []), R5(this, "initialized", false), R5(this, "storagePrefix", B3), R5(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s) => this.records.set(s.id, s)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), R5(this, "set", (s, i3, n3) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: s, request: i3, chainId: n3 }), this.records.has(i3.id)) return;
      const o3 = { id: i3.id, topic: s, request: { method: i3.method, params: i3.params || null }, chainId: n3, expiry: po3(import_time5.THIRTY_DAYS) };
      this.records.set(o3.id, o3), this.persist(), this.events.emit(M7.created, o3);
    }), R5(this, "resolve", async (s) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: s }), !this.records.has(s.id)) return;
      const i3 = await this.getRecord(s.id);
      typeof i3.response > "u" && (i3.response = isJsonRpcError(s) ? { error: s.error } : { result: s.result }, this.records.set(i3.id, i3), this.persist(), this.events.emit(M7.updated, i3));
    }), R5(this, "get", async (s, i3) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: s, id: i3 }), await this.getRecord(i3))), R5(this, "delete", (s, i3) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i3 }), this.values.forEach((n3) => {
        if (n3.topic === s) {
          if (typeof i3 < "u" && n3.id !== i3) return;
          this.records.delete(n3.id), this.events.emit(M7.deleted, n3);
        }
      }), this.persist();
    }), R5(this, "exists", async (s, i3) => (this.isInitialized(), this.records.has(i3) ? (await this.getRecord(i3)).topic === s : false)), R5(this, "on", (s, i3) => {
      this.events.on(s, i3);
    }), R5(this, "once", (s, i3) => {
      this.events.once(s, i3);
    }), R5(this, "off", (s, i3) => {
      this.events.off(s, i3);
    }), R5(this, "removeListener", (s, i3) => {
      this.events.removeListener(s, i3);
    }), this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u") return;
      const s = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(s);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: s } = te4("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(s);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(M7.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: t } = te4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(M7.created, (e) => {
      const t = M7.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(M7.updated, (e) => {
      const t = M7.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(M7.deleted, (e) => {
      const t = M7.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.core.heartbeat.on(r.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = false;
      this.records.forEach((t) => {
        (0, import_time5.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(M7.deleted, t, false), e = true);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var jo4 = Object.defineProperty;
var Uo4 = (r2, e, t) => e in r2 ? jo4(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var A4 = (r2, e, t) => Uo4(r2, typeof e != "symbol" ? e + "" : e, t);
var ji4 = class extends S {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, A4(this, "expirations", /* @__PURE__ */ new Map()), A4(this, "events", new import_events8.EventEmitter()), A4(this, "name", qt3), A4(this, "version", Gt5), A4(this, "cached", []), A4(this, "initialized", false), A4(this, "storagePrefix", B3), A4(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s) => this.expirations.set(s.target, s)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), A4(this, "has", (s) => {
      try {
        const i3 = this.formatTarget(s);
        return typeof this.getExpiration(i3) < "u";
      } catch {
        return false;
      }
    }), A4(this, "set", (s, i3) => {
      this.isInitialized();
      const n3 = this.formatTarget(s), o3 = { target: n3, expiry: i3 };
      this.expirations.set(n3, o3), this.checkExpiry(n3, o3), this.events.emit(F5.created, { target: n3, expiration: o3 });
    }), A4(this, "get", (s) => {
      this.isInitialized();
      const i3 = this.formatTarget(s);
      return this.getExpiration(i3);
    }), A4(this, "del", (s) => {
      if (this.isInitialized(), this.has(s)) {
        const i3 = this.formatTarget(s), n3 = this.getExpiration(i3);
        this.expirations.delete(i3), this.events.emit(F5.deleted, { target: i3, expiration: n3 });
      }
    }), A4(this, "on", (s, i3) => {
      this.events.on(s, i3);
    }), A4(this, "once", (s, i3) => {
      this.events.once(s, i3);
    }), A4(this, "off", (s, i3) => {
      this.events.off(s, i3);
    }), A4(this, "removeListener", (s, i3) => {
      this.events.removeListener(s, i3);
    }), this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return fo3(e);
    if (typeof e == "number") return lo3(e);
    const { message: t } = te4("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(F5.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: t } = te4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: s } = te4("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(s), new Error(s);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: s } = t;
    (0, import_time5.toMiliseconds)(s) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(F5.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r.pulse, () => this.checkExpirations()), this.events.on(F5.created, (e) => {
      const t = F5.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(F5.expired, (e) => {
      const t = F5.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(F5.deleted, (e) => {
      const t = F5.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Mo4 = Object.defineProperty;
var Fo4 = (r2, e, t) => e in r2 ? Mo4(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var w2 = (r2, e, t) => Fo4(r2, typeof e != "symbol" ? e + "" : e, t);
var Ui2 = class extends M {
  constructor(e, t, s) {
    super(e, t, s), this.core = e, this.logger = t, this.store = s, w2(this, "name", Wt5), w2(this, "abortController"), w2(this, "isDevEnv"), w2(this, "verifyUrlV3", Yt5), w2(this, "storagePrefix", B3), w2(this, "version", Le5), w2(this, "publicKey"), w2(this, "fetchPromise"), w2(this, "init", async () => {
      var i3;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time5.toMiliseconds)((i3 = this.publicKey) == null ? void 0 : i3.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }), w2(this, "register", async (i3) => {
      if (!Ae4() || this.isDevEnv) return;
      const n3 = window.location.origin, { id: o3, decryptedId: a2 } = i3, c6 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${n3}&id=${o3}&decryptedId=${a2}`;
      try {
        const h6 = (0, import_window_getters4.getDocument)(), u3 = this.startAbortTimer(import_time5.ONE_SECOND * 5), d5 = await new Promise((g3, _7) => {
          const l5 = () => {
            window.removeEventListener("message", x9), h6.body.removeChild(b4), _7("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", l5);
          const b4 = h6.createElement("iframe");
          b4.src = c6, b4.style.display = "none", b4.addEventListener("error", l5, { signal: this.abortController.signal });
          const x9 = (I5) => {
            if (I5.data && typeof I5.data == "string") try {
              const D6 = JSON.parse(I5.data);
              if (D6.type === "verify_attestation") {
                if (sn(D6.attestation).payload.id !== o3) return;
                clearInterval(u3), h6.body.removeChild(b4), this.abortController.signal.removeEventListener("abort", l5), window.removeEventListener("message", x9), g3(D6.attestation === null ? "" : D6.attestation);
              }
            } catch (D6) {
              this.logger.warn(D6);
            }
          };
          h6.body.appendChild(b4), window.addEventListener("message", x9, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", d5), d5;
      } catch (h6) {
        this.logger.warn(h6);
      }
      return "";
    }), w2(this, "resolve", async (i3) => {
      if (this.isDevEnv) return "";
      const { attestationId: n3, hash: o3, encryptedId: a2 } = i3;
      if (n3 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (n3) {
        if (sn(n3).payload.id !== a2) return;
        const h6 = await this.isValidJwtAttestation(n3);
        if (h6) {
          if (!h6.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h6;
        }
      }
      if (!o3) return;
      const c6 = this.getVerifyUrl(i3 == null ? void 0 : i3.verifyUrl);
      return this.fetchAttestation(o3, c6);
    }), w2(this, "fetchAttestation", async (i3, n3) => {
      this.logger.debug(`resolving attestation: ${i3} from url: ${n3}`);
      const o3 = this.startAbortTimer(import_time5.ONE_SECOND * 5), a2 = await fetch(`${n3}/attestation/${i3}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o3), a2.status === 200 ? await a2.json() : void 0;
    }), w2(this, "getVerifyUrl", (i3) => {
      let n3 = i3 || ue5;
      return Jt5.includes(n3) || (this.logger.info(`verify url: ${n3}, not included in trusted list, assigning default: ${ue5}`), n3 = ue5), n3;
    }), w2(this, "fetchPublicKey", async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const i3 = this.startAbortTimer(import_time5.FIVE_SECONDS), n3 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(i3), await n3.json();
      } catch (i3) {
        this.logger.warn(i3);
      }
    }), w2(this, "persistPublicKey", async (i3) => {
      this.logger.debug("persisting public key to local storage", i3), await this.store.setItem(this.storeKey, i3), this.publicKey = i3;
    }), w2(this, "removePublicKey", async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }), w2(this, "isValidJwtAttestation", async (i3) => {
      const n3 = await this.getPublicKey();
      try {
        if (n3) return this.validateAttestation(i3, n3);
      } catch (a2) {
        this.logger.error(a2), this.logger.warn("error validating attestation");
      }
      const o3 = await this.fetchAndPersistPublicKey();
      try {
        if (o3) return this.validateAttestation(i3, o3);
      } catch (a2) {
        this.logger.error(a2), this.logger.warn("error validating attestation");
      }
    }), w2(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), w2(this, "fetchAndPersistPublicKey", async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (n3) => {
        const o3 = await this.fetchPublicKey();
        o3 && (await this.persistPublicKey(o3), n3(o3));
      });
      const i3 = await this.fetchPromise;
      return this.fetchPromise = void 0, i3;
    }), w2(this, "validateAttestation", (i3, n3) => {
      const o3 = mi4(i3, n3.publicKey), a2 = { hasExpired: (0, import_time5.toMiliseconds)(o3.exp) < Date.now(), payload: o3 };
      if (a2.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a2.payload.origin, isScam: a2.payload.isScam, isVerified: a2.payload.isVerified };
    }), this.logger = E(t, this.name), this.abortController = new AbortController(), this.isDevEnv = vo3(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time5.toMiliseconds)(e));
  }
};
var Ko4 = Object.defineProperty;
var Bo4 = (r2, e, t) => e in r2 ? Ko4(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Mi4 = (r2, e, t) => Bo4(r2, typeof e != "symbol" ? e + "" : e, t);
var Fi4 = class extends O {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, Mi4(this, "context", Xt3), Mi4(this, "registerDeviceToken", async (s) => {
      const { clientId: i3, token: n3, notificationType: o3, enableEncrypted: a2 = false } = s, c6 = `${Zt3}/${this.projectId}/clients`;
      await fetch(c6, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i3, type: o3, token: n3, always_raw: a2 }) });
    }), this.logger = E(t, this.context);
  }
};
var Vo4 = Object.defineProperty;
var Ki4 = Object.getOwnPropertySymbols;
var qo4 = Object.prototype.hasOwnProperty;
var Go4 = Object.prototype.propertyIsEnumerable;
var Ze3 = (r2, e, t) => e in r2 ? Vo4(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var be4 = (r2, e) => {
  for (var t in e || (e = {})) qo4.call(e, t) && Ze3(r2, t, e[t]);
  if (Ki4) for (var t of Ki4(e)) Go4.call(e, t) && Ze3(r2, t, e[t]);
  return r2;
};
var E6 = (r2, e, t) => Ze3(r2, typeof e != "symbol" ? e + "" : e, t);
var Bi4 = class extends R {
  constructor(e, t, s = true) {
    super(e, t, s), this.core = e, this.logger = t, E6(this, "context", ei5), E6(this, "storagePrefix", B3), E6(this, "storageVersion", Qt3), E6(this, "events", /* @__PURE__ */ new Map()), E6(this, "shouldPersist", false), E6(this, "init", async () => {
      if (!vo3()) try {
        const i3 = { eventId: Eo3(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Yt4(this.core.relayer.protocol, this.core.relayer.version, _e6) } } };
        await this.sendEvent([i3]);
      } catch (i3) {
        this.logger.warn(i3);
      }
    }), E6(this, "createEvent", (i3) => {
      const { event: n3 = "ERROR", type: o3 = "", properties: { topic: a2, trace: c6 } } = i3, h6 = Eo3(), u3 = this.core.projectId || "", d5 = Date.now(), g3 = be4({ eventId: h6, timestamp: d5, props: { event: n3, type: o3, properties: { topic: a2, trace: c6 } }, bundleId: u3, domain: this.getAppDomain() }, this.setMethods(h6));
      return this.telemetryEnabled && (this.events.set(h6, g3), this.shouldPersist = true), g3;
    }), E6(this, "getEvent", (i3) => {
      const { eventId: n3, topic: o3 } = i3;
      if (n3) return this.events.get(n3);
      const a2 = Array.from(this.events.values()).find((c6) => c6.props.properties.topic === o3);
      if (a2) return be4(be4({}, a2), this.setMethods(a2.eventId));
    }), E6(this, "deleteEvent", (i3) => {
      const { eventId: n3 } = i3;
      this.events.delete(n3), this.shouldPersist = true;
    }), E6(this, "setEventListeners", () => {
      this.core.heartbeat.on(r.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((i3) => {
          (0, import_time5.fromMiliseconds)(Date.now()) - (0, import_time5.fromMiliseconds)(i3.timestamp) > ti5 && (this.events.delete(i3.eventId), this.shouldPersist = true);
        });
      });
    }), E6(this, "setMethods", (i3) => ({ addTrace: (n3) => this.addTrace(i3, n3), setError: (n3) => this.setError(i3, n3) })), E6(this, "addTrace", (i3, n3) => {
      const o3 = this.events.get(i3);
      o3 && (o3.props.properties.trace.push(n3), this.events.set(i3, o3), this.shouldPersist = true);
    }), E6(this, "setError", (i3, n3) => {
      const o3 = this.events.get(i3);
      o3 && (o3.props.type = n3, o3.timestamp = Date.now(), this.events.set(i3, o3), this.shouldPersist = true);
    }), E6(this, "persist", async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }), E6(this, "restore", async () => {
      try {
        const i3 = await this.core.storage.getItem(this.storageKey) || [];
        if (!i3.length) return;
        i3.forEach((n3) => {
          this.events.set(n3.eventId, be4(be4({}, n3), this.setMethods(n3.eventId)));
        });
      } catch (i3) {
        this.logger.warn(i3);
      }
    }), E6(this, "submit", async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const i3 = [];
      for (const [n3, o3] of this.events) o3.props.type && i3.push(o3);
      if (i3.length !== 0) try {
        if ((await this.sendEvent(i3)).ok) for (const n3 of i3) this.events.delete(n3.eventId), this.shouldPersist = true;
      } catch (n3) {
        this.logger.warn(n3);
      }
    }), E6(this, "sendEvent", async (i3) => {
      const n3 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${ii5}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${_e6}${n3}`, { method: "POST", body: JSON.stringify(i3) });
    }), E6(this, "getAppDomain", () => Xr3().url), this.logger = E(t, this.context), this.telemetryEnabled = s, s ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var Wo4 = Object.defineProperty;
var Vi4 = Object.getOwnPropertySymbols;
var Ho4 = Object.prototype.hasOwnProperty;
var Yo4 = Object.prototype.propertyIsEnumerable;
var Qe3 = (r2, e, t) => e in r2 ? Wo4(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var qi4 = (r2, e) => {
  for (var t in e || (e = {})) Ho4.call(e, t) && Qe3(r2, t, e[t]);
  if (Vi4) for (var t of Vi4(e)) Yo4.call(e, t) && Qe3(r2, t, e[t]);
  return r2;
};
var v4 = (r2, e, t) => Qe3(r2, typeof e != "symbol" ? e + "" : e, t);
var Te4 = class _Te extends h {
  constructor(e) {
    var t;
    super(e), v4(this, "protocol", ze5), v4(this, "version", Le5), v4(this, "name", he3), v4(this, "relayUrl"), v4(this, "projectId"), v4(this, "customStoragePrefix"), v4(this, "events", new import_events8.EventEmitter()), v4(this, "logger"), v4(this, "heartbeat"), v4(this, "relayer"), v4(this, "crypto"), v4(this, "storage"), v4(this, "history"), v4(this, "expirer"), v4(this, "pairing"), v4(this, "verify"), v4(this, "echoClient"), v4(this, "linkModeSupportedApps"), v4(this, "eventClient"), v4(this, "initialized", false), v4(this, "logChunkController"), v4(this, "on", (o3, a2) => this.events.on(o3, a2)), v4(this, "once", (o3, a2) => this.events.once(o3, a2)), v4(this, "off", (o3, a2) => this.events.off(o3, a2)), v4(this, "removeListener", (o3, a2) => this.events.removeListener(o3, a2)), v4(this, "dispatchEnvelope", ({ topic: o3, message: a2, sessionExists: c6 }) => {
      if (!o3 || !a2) return;
      const h6 = { topic: o3, message: a2, publishedAt: Date.now(), transportType: Q4.link_mode };
      this.relayer.onLinkMessageEvent(h6, { sessionExists: c6 });
    }), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || Ue6, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const s = k({ level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : Et6.logger, name: he3 }), { logger: i3, chunkLoggerController: n3 } = A({ opts: s, maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes, loggerOverride: e == null ? void 0 : e.logger });
    this.logChunkController = n3, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var o3, a2;
      (o3 = this.logChunkController) != null && o3.downloadLogsBlobInBrowser && ((a2 = this.logChunkController) == null || a2.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E(i3, this.name), this.heartbeat = new i(), this.crypto = new vi4(this, this.logger, e == null ? void 0 : e.keychain), this.history = new ki5(this, this.logger), this.expirer = new ji4(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h5(qi4(qi4({}, It5), e == null ? void 0 : e.storageOptions)), this.relayer = new Si3({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Li5(this, this.logger), this.verify = new Ui2(this, this.logger, this.storage), this.echoClient = new Fi4(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new Bi4(this, this.logger, e == null ? void 0 : e.telemetryEnabled);
  }
  static async init(e) {
    const t = new _Te(e);
    await t.initialize();
    const s = await t.crypto.getClientId();
    return await t.storage.setItem(jt5, s), t;
  }
  get context() {
    return y(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(Me6, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(Me6) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
var Jo4 = Te4;

// node_modules/@reown/appkit/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_time6 = __toESM(require_cjs());
var import_events9 = __toESM(require_events());
var De5 = "wc";
var Le6 = 2;
var ke7 = "client";
var we5 = `${De5}@${Le6}:${ke7}:`;
var me5 = { name: ke7, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.org" };
var Me7 = "WALLETCONNECT_DEEPLINK_CHOICE";
var pt5 = "proposal";
var $e6 = "Proposal expired";
var ht5 = "session";
var J7 = import_time6.SEVEN_DAYS;
var dt5 = "engine";
var N5 = { wc_sessionPropose: { req: { ttl: import_time6.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time6.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time6.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time6.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time6.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var _e7 = { min: import_time6.FIVE_MINUTES, max: import_time6.SEVEN_DAYS };
var $5 = { idle: "IDLE", active: "ACTIVE" };
var Ue7 = { eth_sendTransaction: { key: "" }, eth_sendRawTransaction: { key: "" }, wallet_sendCalls: { key: "" }, solana_signTransaction: { key: "signature" }, solana_signAllTransactions: { key: "transactions" }, solana_signAndSendTransaction: { key: "signature" } };
var ut5 = "request";
var gt4 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var yt4 = "wc";
var wt6 = "auth";
var mt5 = "authKeys";
var _t6 = "pairingTopics";
var Et7 = "requests";
var ae4 = `${yt4}@${1.5}:${wt6}:`;
var ce5 = `${ae4}:PUB_KEY`;
var Rs5 = Object.defineProperty;
var vs5 = Object.defineProperties;
var Is5 = Object.getOwnPropertyDescriptors;
var ft4 = Object.getOwnPropertySymbols;
var Ts5 = Object.prototype.hasOwnProperty;
var qs6 = Object.prototype.propertyIsEnumerable;
var Ke7 = (S7, n3, e) => n3 in S7 ? Rs5(S7, n3, { enumerable: true, configurable: true, writable: true, value: e }) : S7[n3] = e;
var v5 = (S7, n3) => {
  for (var e in n3 || (n3 = {})) Ts5.call(n3, e) && Ke7(S7, e, n3[e]);
  if (ft4) for (var e of ft4(n3)) qs6.call(n3, e) && Ke7(S7, e, n3[e]);
  return S7;
};
var b2 = (S7, n3) => vs5(S7, Is5(n3));
var c5 = (S7, n3, e) => Ke7(S7, typeof n3 != "symbol" ? n3 + "" : n3, e);
var Ps5 = class extends V {
  constructor(n3) {
    super(n3), c5(this, "name", dt5), c5(this, "events", new import_events9.default()), c5(this, "initialized", false), c5(this, "requestQueue", { state: $5.idle, queue: [] }), c5(this, "sessionRequestQueue", { state: $5.idle, queue: [] }), c5(this, "requestQueueDelay", import_time6.ONE_SECOND), c5(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), c5(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), c5(this, "recentlyDeletedLimit", 200), c5(this, "relayMessageCache", []), c5(this, "pendingSessions", /* @__PURE__ */ new Map()), c5(this, "init", async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(N5) }), this.initialized = true, setTimeout(async () => {
        await this.processPendingMessageEvents(), this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time6.toMiliseconds)(this.requestQueueDelay)));
    }), c5(this, "connect", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const t = b2(v5({}, e), { requiredNamespaces: e.requiredNamespaces || {}, optionalNamespaces: e.optionalNamespaces || {} });
      await this.isValidConnect(t);
      const { pairingTopic: s, requiredNamespaces: i3, optionalNamespaces: r2, sessionProperties: o3, scopedProperties: a2, relays: l5 } = t;
      let p6 = s, h6, u3 = false;
      try {
        if (p6) {
          const T4 = this.client.core.pairing.pairings.get(p6);
          this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), u3 = T4.active;
        }
      } catch (T4) {
        throw this.client.logger.error(`connect() -> pairing.get(${p6}) failed`), T4;
      }
      if (!p6 || !u3) {
        const { topic: T4, uri: U3 } = await this.client.core.pairing.create();
        p6 = T4, h6 = U3;
      }
      if (!p6) {
        const { message: T4 } = te4("NO_MATCHING_KEY", `connect() pairing topic: ${p6}`);
        throw new Error(T4);
      }
      const d5 = await this.client.core.crypto.generateKeyPair(), w4 = N5.wc_sessionPropose.req.ttl || import_time6.FIVE_MINUTES, m3 = po3(w4), f10 = b2(v5(v5({ requiredNamespaces: i3, optionalNamespaces: r2, relays: l5 ?? [{ protocol: xt5 }], proposer: { publicKey: d5, metadata: this.client.metadata }, expiryTimestamp: m3, pairingTopic: p6 }, o3 && { sessionProperties: o3 }), a2 && { scopedProperties: a2 }), { id: payloadId() }), _7 = yo3("session_connect", f10.id), { reject: g3, resolve: A6, done: D6 } = ao4(w4, $e6), I5 = ({ id: T4 }) => {
        T4 === f10.id && (this.client.events.off("proposal_expire", I5), this.pendingSessions.delete(f10.id), this.events.emit(_7, { error: { message: $e6, code: 0 } }));
      };
      return this.client.events.on("proposal_expire", I5), this.events.once(_7, ({ error: T4, session: U3 }) => {
        this.client.events.off("proposal_expire", I5), T4 ? g3(T4) : U3 && A6(U3);
      }), await this.sendRequest({ topic: p6, method: "wc_sessionPropose", params: f10, throwOnFailedPublish: true, clientRpcId: f10.id }), await this.setProposal(f10.id, f10), { uri: h6, approval: D6 };
    }), c5(this, "pair", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(e);
      } catch (t) {
        throw this.client.logger.error("pair() failed"), t;
      }
    }), c5(this, "approve", async (e) => {
      var t, s, i3;
      const r2 = this.client.core.eventClient.createEvent({ properties: { topic: (t = e == null ? void 0 : e.id) == null ? void 0 : t.toString(), trace: [Qs5.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (q5) {
        throw r2.setError(er5.no_internet_connection), q5;
      }
      try {
        await this.isValidProposalId(e == null ? void 0 : e.id);
      } catch (q5) {
        throw this.client.logger.error(`approve() -> proposal.get(${e == null ? void 0 : e.id}) failed`), r2.setError(er5.proposal_not_found), q5;
      }
      try {
        await this.isValidApprove(e);
      } catch (q5) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), r2.setError(er5.session_approve_namespace_validation_failure), q5;
      }
      const { id: o3, relayProtocol: a2, namespaces: l5, sessionProperties: p6, scopedProperties: h6, sessionConfig: u3 } = e, d5 = this.client.proposal.get(o3);
      this.client.core.eventClient.deleteEvent({ eventId: r2.eventId });
      const { pairingTopic: w4, proposer: m3, requiredNamespaces: f10, optionalNamespaces: _7 } = d5;
      let g3 = (s = this.client.core.eventClient) == null ? void 0 : s.getEvent({ topic: w4 });
      g3 || (g3 = (i3 = this.client.core.eventClient) == null ? void 0 : i3.createEvent({ type: Qs5.session_approve_started, properties: { topic: w4, trace: [Qs5.session_approve_started, Qs5.session_namespaces_validation_success] } }));
      const A6 = await this.client.core.crypto.generateKeyPair(), D6 = m3.publicKey, I5 = await this.client.core.crypto.generateSharedKey(A6, D6), T4 = v5(v5(v5({ relay: { protocol: a2 ?? "irn" }, namespaces: l5, controller: { publicKey: A6, metadata: this.client.metadata }, expiry: po3(J7) }, p6 && { sessionProperties: p6 }), h6 && { scopedProperties: h6 }), u3 && { sessionConfig: u3 }), U3 = Q4.relay;
      g3.addTrace(Qs5.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(I5, { transportType: U3 });
      } catch (q5) {
        throw g3.setError(er5.subscribe_session_topic_failure), q5;
      }
      g3.addTrace(Qs5.subscribe_session_topic_success);
      const fe6 = b2(v5({}, T4), { topic: I5, requiredNamespaces: f10, optionalNamespaces: _7, pairingTopic: w4, acknowledged: false, self: T4.controller, peer: { publicKey: m3.publicKey, metadata: m3.metadata }, controller: A6, transportType: Q4.relay });
      await this.client.session.set(I5, fe6), g3.addTrace(Qs5.store_session);
      try {
        g3.addTrace(Qs5.publishing_session_settle), await this.sendRequest({ topic: I5, method: "wc_sessionSettle", params: T4, throwOnFailedPublish: true }).catch((q5) => {
          throw g3 == null ? void 0 : g3.setError(er5.session_settle_publish_failure), q5;
        }), g3.addTrace(Qs5.session_settle_publish_success), g3.addTrace(Qs5.publishing_session_approve), await this.sendResult({ id: o3, topic: w4, result: { relay: { protocol: a2 ?? "irn" }, responderPublicKey: A6 }, throwOnFailedPublish: true }).catch((q5) => {
          throw g3 == null ? void 0 : g3.setError(er5.session_approve_publish_failure), q5;
        }), g3.addTrace(Qs5.session_approve_publish_success);
      } catch (q5) {
        throw this.client.logger.error(q5), this.client.session.delete(I5, de4("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(I5), q5;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: g3.eventId }), await this.client.core.pairing.updateMetadata({ topic: w4, metadata: m3.metadata }), await this.client.proposal.delete(o3, de4("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: w4 }), await this.setExpiry(I5, po3(J7)), { topic: I5, acknowledged: () => Promise.resolve(this.client.session.get(I5)) };
    }), c5(this, "reject", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(e);
      } catch (r2) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r2;
      }
      const { id: t, reason: s } = e;
      let i3;
      try {
        i3 = this.client.proposal.get(t).pairingTopic;
      } catch (r2) {
        throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`), r2;
      }
      i3 && (await this.sendError({ id: t, topic: i3, error: s, rpcOpts: N5.wc_sessionPropose.reject }), await this.client.proposal.delete(t, de4("USER_DISCONNECTED")));
    }), c5(this, "update", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(e);
      } catch (h6) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), h6;
      }
      const { topic: t, namespaces: s } = e, { done: i3, resolve: r2, reject: o3 } = ao4(), a2 = payloadId(), l5 = getBigIntRpcId().toString(), p6 = this.client.session.get(t).namespaces;
      return this.events.once(yo3("session_update", a2), ({ error: h6 }) => {
        h6 ? o3(h6) : r2();
      }), await this.client.session.update(t, { namespaces: s }), await this.sendRequest({ topic: t, method: "wc_sessionUpdate", params: { namespaces: s }, throwOnFailedPublish: true, clientRpcId: a2, relayRpcId: l5 }).catch((h6) => {
        this.client.logger.error(h6), this.client.session.update(t, { namespaces: p6 }), o3(h6);
      }), { acknowledged: i3 };
    }), c5(this, "extend", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(e);
      } catch (a2) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a2;
      }
      const { topic: t } = e, s = payloadId(), { done: i3, resolve: r2, reject: o3 } = ao4();
      return this.events.once(yo3("session_extend", s), ({ error: a2 }) => {
        a2 ? o3(a2) : r2();
      }), await this.setExpiry(t, po3(J7)), this.sendRequest({ topic: t, method: "wc_sessionExtend", params: {}, clientRpcId: s, throwOnFailedPublish: true }).catch((a2) => {
        o3(a2);
      }), { acknowledged: i3 };
    }), c5(this, "request", async (e) => {
      this.isInitialized();
      try {
        await this.isValidRequest(e);
      } catch (_7) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), _7;
      }
      const { chainId: t, request: s, topic: i3, expiry: r2 = N5.wc_sessionRequest.req.ttl } = e, o3 = this.client.session.get(i3);
      (o3 == null ? void 0 : o3.transportType) === Q4.relay && await this.confirmOnlineStateOrThrow();
      const a2 = payloadId(), l5 = getBigIntRpcId().toString(), { done: p6, resolve: h6, reject: u3 } = ao4(r2, "Request expired. Please try again.");
      this.events.once(yo3("session_request", a2), ({ error: _7, result: g3 }) => {
        _7 ? u3(_7) : h6(g3);
      });
      const d5 = "wc_sessionRequest", w4 = this.getAppLinkIfEnabled(o3.peer.metadata, o3.transportType);
      if (w4) return await this.sendRequest({ clientRpcId: a2, relayRpcId: l5, topic: i3, method: d5, params: { request: b2(v5({}, s), { expiryTimestamp: po3(r2) }), chainId: t }, expiry: r2, throwOnFailedPublish: true, appLink: w4 }).catch((_7) => u3(_7)), this.client.events.emit("session_request_sent", { topic: i3, request: s, chainId: t, id: a2 }), await p6();
      const m3 = { request: b2(v5({}, s), { expiryTimestamp: po3(r2) }), chainId: t }, f10 = this.shouldSetTVF(d5, m3);
      return await Promise.all([new Promise(async (_7) => {
        await this.sendRequest(v5({ clientRpcId: a2, relayRpcId: l5, topic: i3, method: d5, params: m3, expiry: r2, throwOnFailedPublish: true }, f10 && { tvf: this.getTVFParams(a2, m3) })).catch((g3) => u3(g3)), this.client.events.emit("session_request_sent", { topic: i3, request: s, chainId: t, id: a2 }), _7();
      }), new Promise(async (_7) => {
        var g3;
        if (!((g3 = o3.sessionConfig) != null && g3.disableDeepLink)) {
          const A6 = await bo3(this.client.core.storage, Me7);
          await mo3({ id: a2, topic: i3, wcDeepLink: A6 });
        }
        _7();
      }), p6()]).then((_7) => _7[2]);
    }), c5(this, "respond", async (e) => {
      this.isInitialized(), await this.isValidRespond(e);
      const { topic: t, response: s } = e, { id: i3 } = s, r2 = this.client.session.get(t);
      r2.transportType === Q4.relay && await this.confirmOnlineStateOrThrow();
      const o3 = this.getAppLinkIfEnabled(r2.peer.metadata, r2.transportType);
      isJsonRpcResult(s) ? await this.sendResult({ id: i3, topic: t, result: s.result, throwOnFailedPublish: true, appLink: o3 }) : isJsonRpcError(s) && await this.sendError({ id: i3, topic: t, error: s.error, appLink: o3 }), this.cleanupAfterResponse(e);
    }), c5(this, "ping", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(e);
      } catch (s) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s;
      }
      const { topic: t } = e;
      if (this.client.session.keys.includes(t)) {
        const s = payloadId(), i3 = getBigIntRpcId().toString(), { done: r2, resolve: o3, reject: a2 } = ao4();
        this.events.once(yo3("session_ping", s), ({ error: l5 }) => {
          l5 ? a2(l5) : o3();
        }), await Promise.all([this.sendRequest({ topic: t, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s, relayRpcId: i3 }), r2()]);
      } else this.client.core.pairing.pairings.keys.includes(t) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: t }));
    }), c5(this, "emit", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e);
      const { topic: t, event: s, chainId: i3 } = e, r2 = getBigIntRpcId().toString(), o3 = payloadId();
      await this.sendRequest({ topic: t, method: "wc_sessionEvent", params: { event: s, chainId: i3 }, throwOnFailedPublish: true, relayRpcId: r2, clientRpcId: o3 });
    }), c5(this, "disconnect", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e);
      const { topic: t } = e;
      if (this.client.session.keys.includes(t)) await this.sendRequest({ topic: t, method: "wc_sessionDelete", params: de4("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: t, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(t)) await this.client.core.pairing.disconnect({ topic: t });
      else {
        const { message: s } = te4("MISMATCHED_TOPIC", `Session or pairing topic not found: ${t}`);
        throw new Error(s);
      }
    }), c5(this, "find", (e) => (this.isInitialized(), this.client.session.getAll().filter((t) => Pi6(t, e)))), c5(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), c5(this, "authenticate", async (e, t) => {
      var s;
      this.isInitialized(), this.isValidAuthenticate(e);
      const i3 = t && this.client.core.linkModeSupportedApps.includes(t) && ((s = this.client.metadata.redirect) == null ? void 0 : s.linkMode), r2 = i3 ? Q4.link_mode : Q4.relay;
      r2 === Q4.relay && await this.confirmOnlineStateOrThrow();
      const { chains: o3, statement: a2 = "", uri: l5, domain: p6, nonce: h6, type: u3, exp: d5, nbf: w4, methods: m3 = [], expiry: f10 } = e, _7 = [...e.resources || []], { topic: g3, uri: A6 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r2 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: g3, uri: A6 } });
      const D6 = await this.client.core.crypto.generateKeyPair(), I5 = ii4(D6);
      if (await Promise.all([this.client.auth.authKeys.set(ce5, { responseTopic: I5, publicKey: D6 }), this.client.auth.pairingTopics.set(I5, { topic: I5, pairingTopic: g3 })]), await this.client.core.relayer.subscribe(I5, { transportType: r2 }), this.client.logger.info(`sending request to new pairing topic: ${g3}`), m3.length > 0) {
        const { namespace: x9 } = Ye4(o3[0]);
        let L5 = rs3(x9, "request", m3);
        Me5(_7) && (L5 = os3(L5, _7.pop())), _7.push(L5);
      }
      const T4 = f10 && f10 > N5.wc_sessionAuthenticate.req.ttl ? f10 : N5.wc_sessionAuthenticate.req.ttl, U3 = { authPayload: { type: u3 ?? "caip122", chains: o3, statement: a2, aud: l5, domain: p6, version: "1", nonce: h6, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: d5, nbf: w4, resources: _7 }, requester: { publicKey: D6, metadata: this.client.metadata }, expiryTimestamp: po3(T4) }, fe6 = { eip155: { chains: o3, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...m3])], events: ["chainChanged", "accountsChanged"] } }, q5 = { requiredNamespaces: {}, optionalNamespaces: fe6, relays: [{ protocol: "irn" }], pairingTopic: g3, proposer: { publicKey: D6, metadata: this.client.metadata }, expiryTimestamp: po3(N5.wc_sessionPropose.req.ttl), id: payloadId() }, { done: Rt8, resolve: je7, reject: Se7 } = ao4(T4, "Request expired"), te7 = payloadId(), le8 = yo3("session_connect", q5.id), Re5 = yo3("session_request", te7), pe5 = async ({ error: x9, session: L5 }) => {
        this.events.off(Re5, ve5), x9 ? Se7(x9) : L5 && je7({ session: L5 });
      }, ve5 = async (x9) => {
        var L5, Fe7, Qe5;
        if (await this.deletePendingAuthRequest(te7, { message: "fulfilled", code: 0 }), x9.error) {
          const ie7 = de4("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return x9.error.code === ie7.code ? void 0 : (this.events.off(le8, pe5), Se7(x9.error.message));
        }
        await this.deleteProposal(q5.id), this.events.off(le8, pe5);
        const { cacaos: He6, responder: Q5 } = x9.result, Te6 = [], ze7 = [];
        for (const ie7 of He6) {
          await Zo2({ cacao: ie7, projectId: this.client.core.projectId }) || (this.client.logger.error(ie7, "Signature verification failed"), Se7(de4("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: qe7 } = ie7, Pe5 = Me5(qe7.resources), Ye7 = [In4(qe7.iss)], vt6 = ut4(qe7.iss);
          if (Pe5) {
            const Ne6 = ss3(Pe5), It6 = is3(Pe5);
            Te6.push(...Ne6), Ye7.push(...It6);
          }
          for (const Ne6 of Ye7) ze7.push(`${Ne6}:${vt6}`);
        }
        const se7 = await this.client.core.crypto.generateSharedKey(D6, Q5.publicKey);
        let he5;
        Te6.length > 0 && (he5 = { topic: se7, acknowledged: true, self: { publicKey: D6, metadata: this.client.metadata }, peer: Q5, controller: Q5.publicKey, expiry: po3(J7), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: g3, namespaces: Ri4([...new Set(Te6)], [...new Set(ze7)]), transportType: r2 }, await this.client.core.relayer.subscribe(se7, { transportType: r2 }), await this.client.session.set(se7, he5), g3 && await this.client.core.pairing.updateMetadata({ topic: g3, metadata: Q5.metadata }), he5 = this.client.session.get(se7)), (L5 = this.client.metadata.redirect) != null && L5.linkMode && (Fe7 = Q5.metadata.redirect) != null && Fe7.linkMode && (Qe5 = Q5.metadata.redirect) != null && Qe5.universal && t && (this.client.core.addLinkModeSupportedApp(Q5.metadata.redirect.universal), this.client.session.update(se7, { transportType: Q4.link_mode })), je7({ auths: He6, session: he5 });
      };
      this.events.once(le8, pe5), this.events.once(Re5, ve5);
      let Ie7;
      try {
        if (i3) {
          const x9 = formatJsonRpcRequest("wc_sessionAuthenticate", U3, te7);
          this.client.core.history.set(g3, x9);
          const L5 = await this.client.core.crypto.encode("", x9, { type: _e5, encoding: ti4 });
          Ie7 = xi3(t, g3, L5);
        } else await Promise.all([this.sendRequest({ topic: g3, method: "wc_sessionAuthenticate", params: U3, expiry: e.expiry, throwOnFailedPublish: true, clientRpcId: te7 }), this.sendRequest({ topic: g3, method: "wc_sessionPropose", params: q5, expiry: N5.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: q5.id })]);
      } catch (x9) {
        throw this.events.off(le8, pe5), this.events.off(Re5, ve5), x9;
      }
      return await this.setProposal(q5.id, q5), await this.setAuthRequest(te7, { request: b2(v5({}, U3), { verifyContext: {} }), pairingTopic: g3, transportType: r2 }), { uri: Ie7 ?? A6, response: Rt8 };
    }), c5(this, "approveSessionAuthenticate", async (e) => {
      const { id: t, auths: s } = e, i3 = this.client.core.eventClient.createEvent({ properties: { topic: t.toString(), trace: [tr5.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (f10) {
        throw i3.setError(ir5.no_internet_connection), f10;
      }
      const r2 = this.getPendingAuthRequest(t);
      if (!r2) throw i3.setError(ir5.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t}`);
      const o3 = r2.transportType || Q4.relay;
      o3 === Q4.relay && await this.confirmOnlineStateOrThrow();
      const a2 = r2.requester.publicKey, l5 = await this.client.core.crypto.generateKeyPair(), p6 = ii4(a2), h6 = { type: Oe5, receiverPublicKey: a2, senderPublicKey: l5 }, u3 = [], d5 = [];
      for (const f10 of s) {
        if (!await Zo2({ cacao: f10, projectId: this.client.core.projectId })) {
          i3.setError(ir5.invalid_cacao);
          const I5 = de4("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: t, topic: p6, error: I5, encodeOpts: h6 }), new Error(I5.message);
        }
        i3.addTrace(tr5.cacaos_verified);
        const { p: _7 } = f10, g3 = Me5(_7.resources), A6 = [In4(_7.iss)], D6 = ut4(_7.iss);
        if (g3) {
          const I5 = ss3(g3), T4 = is3(g3);
          u3.push(...I5), A6.push(...T4);
        }
        for (const I5 of A6) d5.push(`${I5}:${D6}`);
      }
      const w4 = await this.client.core.crypto.generateSharedKey(l5, a2);
      i3.addTrace(tr5.create_authenticated_session_topic);
      let m3;
      if ((u3 == null ? void 0 : u3.length) > 0) {
        m3 = { topic: w4, acknowledged: true, self: { publicKey: l5, metadata: this.client.metadata }, peer: { publicKey: a2, metadata: r2.requester.metadata }, controller: a2, expiry: po3(J7), authentication: s, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r2.pairingTopic, namespaces: Ri4([...new Set(u3)], [...new Set(d5)]), transportType: o3 }, i3.addTrace(tr5.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(w4, { transportType: o3 });
        } catch (f10) {
          throw i3.setError(ir5.subscribe_authenticated_session_topic_failure), f10;
        }
        i3.addTrace(tr5.subscribe_authenticated_session_topic_success), await this.client.session.set(w4, m3), i3.addTrace(tr5.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r2.pairingTopic, metadata: r2.requester.metadata });
      }
      i3.addTrace(tr5.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: p6, id: t, result: { cacaos: s, responder: { publicKey: l5, metadata: this.client.metadata } }, encodeOpts: h6, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r2.requester.metadata, o3) });
      } catch (f10) {
        throw i3.setError(ir5.authenticated_session_approve_publish_failure), f10;
      }
      return await this.client.auth.requests.delete(t, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r2.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i3.eventId }), { session: m3 };
    }), c5(this, "rejectSessionAuthenticate", async (e) => {
      this.isInitialized();
      const { id: t, reason: s } = e, i3 = this.getPendingAuthRequest(t);
      if (!i3) throw new Error(`Could not find pending auth request with id ${t}`);
      i3.transportType === Q4.relay && await this.confirmOnlineStateOrThrow();
      const r2 = i3.requester.publicKey, o3 = await this.client.core.crypto.generateKeyPair(), a2 = ii4(r2), l5 = { type: Oe5, receiverPublicKey: r2, senderPublicKey: o3 };
      await this.sendError({ id: t, topic: a2, error: s, encodeOpts: l5, rpcOpts: N5.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i3.requester.metadata, i3.transportType) }), await this.client.auth.requests.delete(t, { message: "rejected", code: 0 }), await this.client.proposal.delete(t, de4("USER_DISCONNECTED"));
    }), c5(this, "formatAuthMessage", (e) => {
      this.isInitialized();
      const { request: t, iss: s } = e;
      return On4(t, s);
    }), c5(this, "processRelayMessageCache", () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const e = this.relayMessageCache.shift();
          e && await this.onRelayMessage(e);
        } catch (e) {
          this.client.logger.error(e);
        }
      }, 50);
    }), c5(this, "cleanupDuplicatePairings", async (e) => {
      if (e.pairingTopic) try {
        const t = this.client.core.pairing.pairings.get(e.pairingTopic), s = this.client.core.pairing.pairings.getAll().filter((i3) => {
          var r2, o3;
          return ((r2 = i3.peerMetadata) == null ? void 0 : r2.url) && ((o3 = i3.peerMetadata) == null ? void 0 : o3.url) === e.peer.metadata.url && i3.topic && i3.topic !== t.topic;
        });
        if (s.length === 0) return;
        this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`), await Promise.all(s.map((i3) => this.client.core.pairing.disconnect({ topic: i3.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (t) {
        this.client.logger.error(t);
      }
    }), c5(this, "deleteSession", async (e) => {
      var t;
      const { topic: s, expirerHasDeleted: i3 = false, emitEvent: r2 = true, id: o3 = 0 } = e, { self: a2 } = this.client.session.get(s);
      await this.client.core.relayer.unsubscribe(s), await this.client.session.delete(s, de4("USER_DISCONNECTED")), this.addToRecentlyDeleted(s, "session"), this.client.core.crypto.keychain.has(a2.publicKey) && await this.client.core.crypto.deleteKeyPair(a2.publicKey), this.client.core.crypto.keychain.has(s) && await this.client.core.crypto.deleteSymKey(s), i3 || this.client.core.expirer.del(s), this.client.core.storage.removeItem(Me7).catch((l5) => this.client.logger.warn(l5)), this.getPendingSessionRequests().forEach((l5) => {
        l5.topic === s && this.deletePendingSessionRequest(l5.id, de4("USER_DISCONNECTED"));
      }), s === ((t = this.sessionRequestQueue.queue[0]) == null ? void 0 : t.topic) && (this.sessionRequestQueue.state = $5.idle), r2 && this.client.events.emit("session_delete", { id: o3, topic: s });
    }), c5(this, "deleteProposal", async (e, t) => {
      if (t) try {
        const s = this.client.proposal.get(e), i3 = this.client.core.eventClient.getEvent({ topic: s.pairingTopic });
        i3 == null ? void 0 : i3.setError(er5.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(e, de4("USER_DISCONNECTED")), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "proposal");
    }), c5(this, "deletePendingSessionRequest", async (e, t, s = false) => {
      await Promise.all([this.client.pendingRequest.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i3) => i3.id !== e), s && (this.sessionRequestQueue.state = $5.idle, this.client.events.emit("session_request_expire", { id: e }));
    }), c5(this, "deletePendingAuthRequest", async (e, t, s = false) => {
      await Promise.all([this.client.auth.requests.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]);
    }), c5(this, "setExpiry", async (e, t) => {
      this.client.session.keys.includes(e) && (this.client.core.expirer.set(e, t), await this.client.session.update(e, { expiry: t }));
    }), c5(this, "setProposal", async (e, t) => {
      this.client.core.expirer.set(e, po3(N5.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e, t);
    }), c5(this, "setAuthRequest", async (e, t) => {
      const { request: s, pairingTopic: i3, transportType: r2 = Q4.relay } = t;
      this.client.core.expirer.set(e, s.expiryTimestamp), await this.client.auth.requests.set(e, { authPayload: s.authPayload, requester: s.requester, expiryTimestamp: s.expiryTimestamp, id: e, pairingTopic: i3, verifyContext: s.verifyContext, transportType: r2 });
    }), c5(this, "setPendingSessionRequest", async (e) => {
      const { id: t, topic: s, params: i3, verifyContext: r2 } = e, o3 = i3.request.expiryTimestamp || po3(N5.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(t, o3), await this.client.pendingRequest.set(t, { id: t, topic: s, params: i3, verifyContext: r2 });
    }), c5(this, "sendRequest", async (e) => {
      const { topic: t, method: s, params: i3, expiry: r2, relayRpcId: o3, clientRpcId: a2, throwOnFailedPublish: l5, appLink: p6, tvf: h6 } = e, u3 = formatJsonRpcRequest(s, i3, a2);
      let d5;
      const w4 = !!p6;
      try {
        const _7 = w4 ? ti4 : At4;
        d5 = await this.client.core.crypto.encode(t, u3, { encoding: _7 });
      } catch (_7) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`), _7;
      }
      let m3;
      if (gt4.includes(s)) {
        const _7 = ci4(JSON.stringify(u3)), g3 = ci4(d5);
        m3 = await this.client.core.verify.register({ id: g3, decryptedId: _7 });
      }
      const f10 = N5[s].req;
      if (f10.attestation = m3, r2 && (f10.ttl = r2), o3 && (f10.id = o3), this.client.core.history.set(t, u3), w4) {
        const _7 = xi3(p6, t, d5);
        await global.Linking.openURL(_7, this.client.name);
      } else {
        const _7 = N5[s].req;
        r2 && (_7.ttl = r2), o3 && (_7.id = o3), _7.tvf = b2(v5({}, h6), { correlationId: u3.id }), l5 ? (_7.internal = b2(v5({}, _7.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t, d5, _7)) : this.client.core.relayer.publish(t, d5, _7).catch((g3) => this.client.logger.error(g3));
      }
      return u3.id;
    }), c5(this, "sendResult", async (e) => {
      const { id: t, topic: s, result: i3, throwOnFailedPublish: r2, encodeOpts: o3, appLink: a2 } = e, l5 = formatJsonRpcResult(t, i3);
      let p6;
      const h6 = a2 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const w4 = h6 ? ti4 : At4;
        p6 = await this.client.core.crypto.encode(s, l5, b2(v5({}, o3 || {}), { encoding: w4 }));
      } catch (w4) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`), w4;
      }
      let u3, d5;
      try {
        u3 = await this.client.core.history.get(s, t);
        const w4 = u3.request;
        try {
          this.shouldSetTVF(w4.method, w4.params) && (d5 = this.getTVFParams(t, w4.params, i3));
        } catch (m3) {
          this.client.logger.warn("sendResult() -> getTVFParams() failed", m3);
        }
      } catch (w4) {
        throw this.client.logger.error(`sendResult() -> history.get(${s}, ${t}) failed`), w4;
      }
      if (h6) {
        const w4 = xi3(a2, s, p6);
        await global.Linking.openURL(w4, this.client.name);
      } else {
        const w4 = u3.request.method, m3 = N5[w4].res;
        m3.tvf = b2(v5({}, d5), { correlationId: t }), r2 ? (m3.internal = b2(v5({}, m3.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s, p6, m3)) : this.client.core.relayer.publish(s, p6, m3).catch((f10) => this.client.logger.error(f10));
      }
      await this.client.core.history.resolve(l5);
    }), c5(this, "sendError", async (e) => {
      const { id: t, topic: s, error: i3, encodeOpts: r2, rpcOpts: o3, appLink: a2 } = e, l5 = formatJsonRpcError(t, i3);
      let p6;
      const h6 = a2 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const d5 = h6 ? ti4 : At4;
        p6 = await this.client.core.crypto.encode(s, l5, b2(v5({}, r2 || {}), { encoding: d5 }));
      } catch (d5) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`), d5;
      }
      let u3;
      try {
        u3 = await this.client.core.history.get(s, t);
      } catch (d5) {
        throw this.client.logger.error(`sendError() -> history.get(${s}, ${t}) failed`), d5;
      }
      if (h6) {
        const d5 = xi3(a2, s, p6);
        await global.Linking.openURL(d5, this.client.name);
      } else {
        const d5 = u3.request.method, w4 = o3 || N5[d5].res;
        this.client.core.relayer.publish(s, p6, w4);
      }
      await this.client.core.history.resolve(l5);
    }), c5(this, "cleanup", async () => {
      const e = [], t = [];
      this.client.session.getAll().forEach((s) => {
        let i3 = false;
        go3(s.expiry) && (i3 = true), this.client.core.crypto.keychain.has(s.topic) || (i3 = true), i3 && e.push(s.topic);
      }), this.client.proposal.getAll().forEach((s) => {
        go3(s.expiryTimestamp) && t.push(s.id);
      }), await Promise.all([...e.map((s) => this.deleteSession({ topic: s })), ...t.map((s) => this.deleteProposal(s))]);
    }), c5(this, "onProviderMessageEvent", async (e) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(e) : await this.onRelayMessage(e);
    }), c5(this, "onRelayEventRequest", async (e) => {
      this.requestQueue.queue.push(e), await this.processRequestsQueue();
    }), c5(this, "processRequestsQueue", async () => {
      if (this.requestQueue.state === $5.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = $5.active;
        const e = this.requestQueue.queue.shift();
        if (e) try {
          await this.processRequest(e);
        } catch (t) {
          this.client.logger.warn(t);
        }
      }
      this.requestQueue.state = $5.idle;
    }), c5(this, "processRequest", async (e) => {
      const { topic: t, payload: s, attestation: i3, transportType: r2, encryptedId: o3 } = e, a2 = s.method;
      if (!this.shouldIgnorePairingRequest({ topic: t, requestMethod: a2 })) switch (a2) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: t, payload: s, attestation: i3, encryptedId: o3 });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(t, s);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(t, s);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(t, s);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(t, s);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(t, s);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: t, payload: s, attestation: i3, encryptedId: o3, transportType: r2 });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(t, s);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: t, payload: s, attestation: i3, encryptedId: o3, transportType: r2 });
        default:
          return this.client.logger.info(`Unsupported request method ${a2}`);
      }
    }), c5(this, "onRelayEventResponse", async (e) => {
      const { topic: t, payload: s, transportType: i3 } = e, r2 = (await this.client.core.history.get(t, s.id)).request.method;
      switch (r2) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(t, s, i3);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(t, s);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(t, s);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(t, s);
        case "wc_sessionPing":
          return this.onSessionPingResponse(t, s);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(t, s);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(t, s);
        default:
          return this.client.logger.info(`Unsupported response method ${r2}`);
      }
    }), c5(this, "onRelayEventUnknownPayload", (e) => {
      const { topic: t } = e, { message: s } = te4("MISSING_OR_INVALID", `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s);
    }), c5(this, "shouldIgnorePairingRequest", (e) => {
      const { topic: t, requestMethod: s } = e, i3 = this.expectedPairingMethodMap.get(t);
      return !i3 || i3.includes(s) ? false : !!(i3.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }), c5(this, "onSessionProposeRequest", async (e) => {
      const { topic: t, payload: s, attestation: i3, encryptedId: r2 } = e, { params: o3, id: a2 } = s;
      try {
        const l5 = this.client.core.eventClient.getEvent({ topic: t });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l5 == null ? void 0 : l5.setError(Y5.proposal_listener_not_found)), this.isValidConnect(v5({}, s.params));
        const p6 = o3.expiryTimestamp || po3(N5.wc_sessionPropose.req.ttl), h6 = v5({ id: a2, pairingTopic: t, expiryTimestamp: p6 }, o3);
        await this.setProposal(a2, h6);
        const u3 = await this.getVerifyContext({ attestationId: i3, hash: ci4(JSON.stringify(s)), encryptedId: r2, metadata: h6.proposer.metadata });
        l5 == null ? void 0 : l5.addTrace(G3.emit_session_proposal), this.client.events.emit("session_proposal", { id: a2, params: h6, verifyContext: u3 });
      } catch (l5) {
        await this.sendError({ id: a2, topic: t, error: l5, rpcOpts: N5.wc_sessionPropose.autoReject }), this.client.logger.error(l5);
      }
    }), c5(this, "onSessionProposeResponse", async (e, t, s) => {
      const { id: i3 } = t;
      if (isJsonRpcResult(t)) {
        const { result: r2 } = t;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r2 });
        const o3 = this.client.proposal.get(i3);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: o3 });
        const a2 = o3.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a2 });
        const l5 = r2.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l5 });
        const p6 = await this.client.core.crypto.generateSharedKey(a2, l5);
        this.pendingSessions.set(i3, { sessionTopic: p6, pairingTopic: e, proposalId: i3, publicKey: a2 });
        const h6 = await this.client.core.relayer.subscribe(p6, { transportType: s });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: h6 }), await this.client.core.pairing.activate({ topic: e });
      } else if (isJsonRpcError(t)) {
        await this.client.proposal.delete(i3, de4("USER_DISCONNECTED"));
        const r2 = yo3("session_connect", i3);
        if (this.events.listenerCount(r2) === 0) throw new Error(`emitting ${r2} without any listeners, 954`);
        this.events.emit(r2, { error: t.error });
      }
    }), c5(this, "onSessionSettleRequest", async (e, t) => {
      const { id: s, params: i3 } = t;
      try {
        this.isValidSessionSettleRequest(i3);
        const { relay: r2, controller: o3, expiry: a2, namespaces: l5, sessionProperties: p6, scopedProperties: h6, sessionConfig: u3 } = t.params, d5 = [...this.pendingSessions.values()].find((f10) => f10.sessionTopic === e);
        if (!d5) return this.client.logger.error(`Pending session not found for topic ${e}`);
        const w4 = this.client.proposal.get(d5.proposalId), m3 = b2(v5(v5(v5({ topic: e, relay: r2, expiry: a2, namespaces: l5, acknowledged: true, pairingTopic: d5.pairingTopic, requiredNamespaces: w4.requiredNamespaces, optionalNamespaces: w4.optionalNamespaces, controller: o3.publicKey, self: { publicKey: d5.publicKey, metadata: this.client.metadata }, peer: { publicKey: o3.publicKey, metadata: o3.metadata } }, p6 && { sessionProperties: p6 }), h6 && { scopedProperties: h6 }), u3 && { sessionConfig: u3 }), { transportType: Q4.relay });
        await this.client.session.set(m3.topic, m3), await this.setExpiry(m3.topic, m3.expiry), await this.client.core.pairing.updateMetadata({ topic: d5.pairingTopic, metadata: m3.peer.metadata }), this.client.events.emit("session_connect", { session: m3 }), this.events.emit(yo3("session_connect", d5.proposalId), { session: m3 }), this.pendingSessions.delete(d5.proposalId), this.deleteProposal(d5.proposalId, false), this.cleanupDuplicatePairings(m3), await this.sendResult({ id: t.id, topic: e, result: true, throwOnFailedPublish: true });
      } catch (r2) {
        await this.sendError({ id: s, topic: e, error: r2 }), this.client.logger.error(r2);
      }
    }), c5(this, "onSessionSettleResponse", async (e, t) => {
      const { id: s } = t;
      isJsonRpcResult(t) ? (await this.client.session.update(e, { acknowledged: true }), this.events.emit(yo3("session_approve", s), {})) : isJsonRpcError(t) && (await this.client.session.delete(e, de4("USER_DISCONNECTED")), this.events.emit(yo3("session_approve", s), { error: t.error }));
    }), c5(this, "onSessionUpdateRequest", async (e, t) => {
      const { params: s, id: i3 } = t;
      try {
        const r2 = `${e}_session_update`, o3 = ec2.get(r2);
        if (o3 && this.isRequestOutOfSync(o3, i3)) {
          this.client.logger.warn(`Discarding out of sync request - ${i3}`), this.sendError({ id: i3, topic: e, error: de4("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(v5({ topic: e }, s));
        try {
          ec2.set(r2, i3), await this.client.session.update(e, { namespaces: s.namespaces }), await this.sendResult({ id: i3, topic: e, result: true, throwOnFailedPublish: true });
        } catch (a2) {
          throw ec2.delete(r2), a2;
        }
        this.client.events.emit("session_update", { id: i3, topic: e, params: s });
      } catch (r2) {
        await this.sendError({ id: i3, topic: e, error: r2 }), this.client.logger.error(r2);
      }
    }), c5(this, "isRequestOutOfSync", (e, t) => t.toString().slice(0, -3) < e.toString().slice(0, -3)), c5(this, "onSessionUpdateResponse", (e, t) => {
      const { id: s } = t, i3 = yo3("session_update", s);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(yo3("session_update", s), {}) : isJsonRpcError(t) && this.events.emit(yo3("session_update", s), { error: t.error });
    }), c5(this, "onSessionExtendRequest", async (e, t) => {
      const { id: s } = t;
      try {
        this.isValidExtend({ topic: e }), await this.setExpiry(e, po3(J7)), await this.sendResult({ id: s, topic: e, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_extend", { id: s, topic: e });
      } catch (i3) {
        await this.sendError({ id: s, topic: e, error: i3 }), this.client.logger.error(i3);
      }
    }), c5(this, "onSessionExtendResponse", (e, t) => {
      const { id: s } = t, i3 = yo3("session_extend", s);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(yo3("session_extend", s), {}) : isJsonRpcError(t) && this.events.emit(yo3("session_extend", s), { error: t.error });
    }), c5(this, "onSessionPingRequest", async (e, t) => {
      const { id: s } = t;
      try {
        this.isValidPing({ topic: e }), await this.sendResult({ id: s, topic: e, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s, topic: e });
      } catch (i3) {
        await this.sendError({ id: s, topic: e, error: i3 }), this.client.logger.error(i3);
      }
    }), c5(this, "onSessionPingResponse", (e, t) => {
      const { id: s } = t, i3 = yo3("session_ping", s);
      setTimeout(() => {
        if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners 2176`);
        isJsonRpcResult(t) ? this.events.emit(yo3("session_ping", s), {}) : isJsonRpcError(t) && this.events.emit(yo3("session_ping", s), { error: t.error });
      }, 500);
    }), c5(this, "onSessionDeleteRequest", async (e, t) => {
      const { id: s } = t;
      try {
        this.isValidDisconnect({ topic: e, reason: t.params }), Promise.all([new Promise((i3) => {
          this.client.core.relayer.once(C4.publish, async () => {
            i3(await this.deleteSession({ topic: e, id: s }));
          });
        }), this.sendResult({ id: s, topic: e, result: true, throwOnFailedPublish: true }), this.cleanupPendingSentRequestsForTopic({ topic: e, error: de4("USER_DISCONNECTED") })]).catch((i3) => this.client.logger.error(i3));
      } catch (i3) {
        this.client.logger.error(i3);
      }
    }), c5(this, "onSessionRequest", async (e) => {
      var t, s, i3;
      const { topic: r2, payload: o3, attestation: a2, encryptedId: l5, transportType: p6 } = e, { id: h6, params: u3 } = o3;
      try {
        await this.isValidRequest(v5({ topic: r2 }, u3));
        const d5 = this.client.session.get(r2), w4 = await this.getVerifyContext({ attestationId: a2, hash: ci4(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", u3, h6))), encryptedId: l5, metadata: d5.peer.metadata, transportType: p6 }), m3 = { id: h6, topic: r2, params: u3, verifyContext: w4 };
        await this.setPendingSessionRequest(m3), p6 === Q4.link_mode && (t = d5.peer.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp((s = d5.peer.metadata.redirect) == null ? void 0 : s.universal), (i3 = this.client.signConfig) != null && i3.disableRequestQueue ? this.emitSessionRequest(m3) : (this.addSessionRequestToSessionRequestQueue(m3), this.processSessionRequestQueue());
      } catch (d5) {
        await this.sendError({ id: h6, topic: r2, error: d5 }), this.client.logger.error(d5);
      }
    }), c5(this, "onSessionRequestResponse", (e, t) => {
      const { id: s } = t, i3 = yo3("session_request", s);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(yo3("session_request", s), { result: t.result }) : isJsonRpcError(t) && this.events.emit(yo3("session_request", s), { error: t.error });
    }), c5(this, "onSessionEventRequest", async (e, t) => {
      const { id: s, params: i3 } = t;
      try {
        const r2 = `${e}_session_event_${i3.event.name}`, o3 = ec2.get(r2);
        if (o3 && this.isRequestOutOfSync(o3, s)) {
          this.client.logger.info(`Discarding out of sync request - ${s}`);
          return;
        }
        this.isValidEmit(v5({ topic: e }, i3)), this.client.events.emit("session_event", { id: s, topic: e, params: i3 }), ec2.set(r2, s);
      } catch (r2) {
        await this.sendError({ id: s, topic: e, error: r2 }), this.client.logger.error(r2);
      }
    }), c5(this, "onSessionAuthenticateResponse", (e, t) => {
      const { id: s } = t;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: e, payload: t }), isJsonRpcResult(t) ? this.events.emit(yo3("session_request", s), { result: t.result }) : isJsonRpcError(t) && this.events.emit(yo3("session_request", s), { error: t.error });
    }), c5(this, "onSessionAuthenticateRequest", async (e) => {
      var t;
      const { topic: s, payload: i3, attestation: r2, encryptedId: o3, transportType: a2 } = e;
      try {
        const { requester: l5, authPayload: p6, expiryTimestamp: h6 } = i3.params, u3 = await this.getVerifyContext({ attestationId: r2, hash: ci4(JSON.stringify(i3)), encryptedId: o3, metadata: l5.metadata, transportType: a2 }), d5 = { requester: l5, pairingTopic: s, id: i3.id, authPayload: p6, verifyContext: u3, expiryTimestamp: h6 };
        await this.setAuthRequest(i3.id, { request: d5, pairingTopic: s, transportType: a2 }), a2 === Q4.link_mode && (t = l5.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp(l5.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s, params: i3.params, id: i3.id, verifyContext: u3 });
      } catch (l5) {
        this.client.logger.error(l5);
        const p6 = i3.params.requester.publicKey, h6 = await this.client.core.crypto.generateKeyPair(), u3 = this.getAppLinkIfEnabled(i3.params.requester.metadata, a2), d5 = { type: Oe5, receiverPublicKey: p6, senderPublicKey: h6 };
        await this.sendError({ id: i3.id, topic: s, error: l5, encodeOpts: d5, rpcOpts: N5.wc_sessionAuthenticate.autoReject, appLink: u3 });
      }
    }), c5(this, "addSessionRequestToSessionRequestQueue", (e) => {
      this.sessionRequestQueue.queue.push(e);
    }), c5(this, "cleanupAfterResponse", (e) => {
      this.deletePendingSessionRequest(e.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = $5.idle, this.processSessionRequestQueue();
      }, (0, import_time6.toMiliseconds)(this.requestQueueDelay));
    }), c5(this, "cleanupPendingSentRequestsForTopic", ({ topic: e, error: t }) => {
      const s = this.client.core.history.pending;
      s.length > 0 && s.filter((i3) => i3.topic === e && i3.request.method === "wc_sessionRequest").forEach((i3) => {
        const r2 = i3.request.id, o3 = yo3("session_request", r2);
        if (this.events.listenerCount(o3) === 0) throw new Error(`emitting ${o3} without any listeners`);
        this.events.emit(yo3("session_request", i3.request.id), { error: t });
      });
    }), c5(this, "processSessionRequestQueue", () => {
      if (this.sessionRequestQueue.state === $5.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e = this.sessionRequestQueue.queue[0];
      if (!e) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = $5.active, this.emitSessionRequest(e);
      } catch (t) {
        this.client.logger.error(t);
      }
    }), c5(this, "emitSessionRequest", (e) => {
      this.client.events.emit("session_request", e);
    }), c5(this, "onPairingCreated", (e) => {
      if (e.methods && this.expectedPairingMethodMap.set(e.topic, e.methods), e.active) return;
      const t = this.client.proposal.getAll().find((s) => s.pairingTopic === e.topic);
      t && this.onSessionProposeRequest({ topic: e.topic, payload: formatJsonRpcRequest("wc_sessionPropose", b2(v5({}, t), { requiredNamespaces: t.requiredNamespaces, optionalNamespaces: t.optionalNamespaces, relays: t.relays, proposer: t.proposer, sessionProperties: t.sessionProperties, scopedProperties: t.scopedProperties }), t.id) });
    }), c5(this, "isValidConnect", async (e) => {
      if (!Vi3(e)) {
        const { message: l5 } = te4("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e)}`);
        throw new Error(l5);
      }
      const { pairingTopic: t, requiredNamespaces: s, optionalNamespaces: i3, sessionProperties: r2, scopedProperties: o3, relays: a2 } = e;
      if (ae3(t) || await this.isValidPairingTopic(t), !Di4(a2, true)) {
        const { message: l5 } = te4("MISSING_OR_INVALID", `connect() relays: ${a2}`);
        throw new Error(l5);
      }
      if (!ae3(s) && qe4(s) !== 0 && this.validateNamespaces(s, "requiredNamespaces"), !ae3(i3) && qe4(i3) !== 0 && this.validateNamespaces(i3, "optionalNamespaces"), ae3(r2) || this.validateSessionProps(r2, "sessionProperties"), !ae3(o3)) {
        this.validateSessionProps(o3, "scopedProperties");
        const l5 = Object.keys(s || {}).concat(Object.keys(i3 || {}));
        if (!Object.keys(o3).every((p6) => l5.includes(p6))) throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(o3)}, required/optional namespaces: ${JSON.stringify(l5)}`);
      }
    }), c5(this, "validateNamespaces", (e, t) => {
      const s = ki4(e, "connect()", t);
      if (s) throw new Error(s.message);
    }), c5(this, "isValidApprove", async (e) => {
      if (!Vi3(e)) throw new Error(te4("MISSING_OR_INVALID", `approve() params: ${e}`).message);
      const { id: t, namespaces: s, relayProtocol: i3, sessionProperties: r2, scopedProperties: o3 } = e;
      this.checkRecentlyDeleted(t), await this.isValidProposalId(t);
      const a2 = this.client.proposal.get(t), l5 = Or4(s, "approve()");
      if (l5) throw new Error(l5.message);
      const p6 = Nr4(a2.requiredNamespaces, s, "approve()");
      if (p6) throw new Error(p6.message);
      if (!q4(i3, true)) {
        const { message: h6 } = te4("MISSING_OR_INVALID", `approve() relayProtocol: ${i3}`);
        throw new Error(h6);
      }
      if (ae3(r2) || this.validateSessionProps(r2, "sessionProperties"), !ae3(o3)) {
        this.validateSessionProps(o3, "scopedProperties");
        const h6 = new Set(Object.keys(s));
        if (!Object.keys(o3).every((u3) => h6.has(u3))) throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(o3)}, approved namespaces: ${Array.from(h6).join(", ")}`);
      }
    }), c5(this, "isValidReject", async (e) => {
      if (!Vi3(e)) {
        const { message: i3 } = te4("MISSING_OR_INVALID", `reject() params: ${e}`);
        throw new Error(i3);
      }
      const { id: t, reason: s } = e;
      if (this.checkRecentlyDeleted(t), await this.isValidProposalId(t), !Hi3(s)) {
        const { message: i3 } = te4("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s)}`);
        throw new Error(i3);
      }
    }), c5(this, "isValidSessionSettleRequest", (e) => {
      if (!Vi3(e)) {
        const { message: l5 } = te4("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e}`);
        throw new Error(l5);
      }
      const { relay: t, controller: s, namespaces: i3, expiry: r2 } = e;
      if (!Ar4(t)) {
        const { message: l5 } = te4("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l5);
      }
      const o3 = Ci4(s, "onSessionSettleRequest()");
      if (o3) throw new Error(o3.message);
      const a2 = Or4(i3, "onSessionSettleRequest()");
      if (a2) throw new Error(a2.message);
      if (go3(r2)) {
        const { message: l5 } = te4("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l5);
      }
    }), c5(this, "isValidUpdate", async (e) => {
      if (!Vi3(e)) {
        const { message: a2 } = te4("MISSING_OR_INVALID", `update() params: ${e}`);
        throw new Error(a2);
      }
      const { topic: t, namespaces: s } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const i3 = this.client.session.get(t), r2 = Or4(s, "update()");
      if (r2) throw new Error(r2.message);
      const o3 = Nr4(i3.requiredNamespaces, s, "update()");
      if (o3) throw new Error(o3.message);
    }), c5(this, "isValidExtend", async (e) => {
      if (!Vi3(e)) {
        const { message: s } = te4("MISSING_OR_INVALID", `extend() params: ${e}`);
        throw new Error(s);
      }
      const { topic: t } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
    }), c5(this, "isValidRequest", async (e) => {
      if (!Vi3(e)) {
        const { message: a2 } = te4("MISSING_OR_INVALID", `request() params: ${e}`);
        throw new Error(a2);
      }
      const { topic: t, request: s, chainId: i3, expiry: r2 } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const { namespaces: o3 } = this.client.session.get(t);
      if (!Gi3(o3, i3)) {
        const { message: a2 } = te4("MISSING_OR_INVALID", `request() chainId: ${i3}`);
        throw new Error(a2);
      }
      if (!Ki3(s)) {
        const { message: a2 } = te4("MISSING_OR_INVALID", `request() ${JSON.stringify(s)}`);
        throw new Error(a2);
      }
      if (!Wi3(o3, i3, s.method)) {
        const { message: a2 } = te4("MISSING_OR_INVALID", `request() method: ${s.method}`);
        throw new Error(a2);
      }
      if (r2 && !Xi3(r2, _e7)) {
        const { message: a2 } = te4("MISSING_OR_INVALID", `request() expiry: ${r2}. Expiry must be a number (in seconds) between ${_e7.min} and ${_e7.max}`);
        throw new Error(a2);
      }
    }), c5(this, "isValidRespond", async (e) => {
      var t;
      if (!Vi3(e)) {
        const { message: r2 } = te4("MISSING_OR_INVALID", `respond() params: ${e}`);
        throw new Error(r2);
      }
      const { topic: s, response: i3 } = e;
      try {
        await this.isValidSessionTopic(s);
      } catch (r2) {
        throw (t = e == null ? void 0 : e.response) != null && t.id && this.cleanupAfterResponse(e), r2;
      }
      if (!Fi3(i3)) {
        const { message: r2 } = te4("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i3)}`);
        throw new Error(r2);
      }
    }), c5(this, "isValidPing", async (e) => {
      if (!Vi3(e)) {
        const { message: s } = te4("MISSING_OR_INVALID", `ping() params: ${e}`);
        throw new Error(s);
      }
      const { topic: t } = e;
      await this.isValidSessionOrPairingTopic(t);
    }), c5(this, "isValidEmit", async (e) => {
      if (!Vi3(e)) {
        const { message: o3 } = te4("MISSING_OR_INVALID", `emit() params: ${e}`);
        throw new Error(o3);
      }
      const { topic: t, event: s, chainId: i3 } = e;
      await this.isValidSessionTopic(t);
      const { namespaces: r2 } = this.client.session.get(t);
      if (!Gi3(r2, i3)) {
        const { message: o3 } = te4("MISSING_OR_INVALID", `emit() chainId: ${i3}`);
        throw new Error(o3);
      }
      if (!qi3(s)) {
        const { message: o3 } = te4("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
        throw new Error(o3);
      }
      if (!zi4(r2, i3, s.name)) {
        const { message: o3 } = te4("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
        throw new Error(o3);
      }
    }), c5(this, "isValidDisconnect", async (e) => {
      if (!Vi3(e)) {
        const { message: s } = te4("MISSING_OR_INVALID", `disconnect() params: ${e}`);
        throw new Error(s);
      }
      const { topic: t } = e;
      await this.isValidSessionOrPairingTopic(t);
    }), c5(this, "isValidAuthenticate", (e) => {
      const { chains: t, uri: s, domain: i3, nonce: r2 } = e;
      if (!Array.isArray(t) || t.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!q4(s, false)) throw new Error("uri is required parameter");
      if (!q4(i3, false)) throw new Error("domain is required parameter");
      if (!q4(r2, false)) throw new Error("nonce is required parameter");
      if ([...new Set(t.map((a2) => Ye4(a2).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: o3 } = Ye4(t[0]);
      if (o3 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }), c5(this, "getVerifyContext", async (e) => {
      const { attestationId: t, hash: s, encryptedId: i3, metadata: r2, transportType: o3 } = e, a2 = { verified: { verifyUrl: r2.verifyUrl || ue5, validation: "UNKNOWN", origin: r2.url || "" } };
      try {
        if (o3 === Q4.link_mode) {
          const p6 = this.getAppLinkIfEnabled(r2, o3);
          return a2.verified.validation = p6 && new URL(p6).origin === new URL(r2.url).origin ? "VALID" : "INVALID", a2;
        }
        const l5 = await this.client.core.verify.resolve({ attestationId: t, hash: s, encryptedId: i3, verifyUrl: r2.verifyUrl });
        l5 && (a2.verified.origin = l5.origin, a2.verified.isScam = l5.isScam, a2.verified.validation = l5.origin === new URL(r2.url).origin ? "VALID" : "INVALID");
      } catch (l5) {
        this.client.logger.warn(l5);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a2)}`), a2;
    }), c5(this, "validateSessionProps", (e, t) => {
      Object.values(e).forEach((s, i3) => {
        if (s == null) {
          const { message: r2 } = te4("MISSING_OR_INVALID", `${t} must contain an existing value for each key. Received: ${s} for key ${Object.keys(e)[i3]}`);
          throw new Error(r2);
        }
      });
    }), c5(this, "getPendingAuthRequest", (e) => {
      const t = this.client.auth.requests.get(e);
      return typeof t == "object" ? t : void 0;
    }), c5(this, "addToRecentlyDeleted", (e, t) => {
      if (this.recentlyDeletedMap.set(e, t), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s = 0;
        const i3 = this.recentlyDeletedLimit / 2;
        for (const r2 of this.recentlyDeletedMap.keys()) {
          if (s++ >= i3) break;
          this.recentlyDeletedMap.delete(r2);
        }
      }
    }), c5(this, "checkRecentlyDeleted", (e) => {
      const t = this.recentlyDeletedMap.get(e);
      if (t) {
        const { message: s } = te4("MISSING_OR_INVALID", `Record was recently deleted - ${t}: ${e}`);
        throw new Error(s);
      }
    }), c5(this, "isLinkModeEnabled", (e, t) => {
      var s, i3, r2, o3, a2, l5, p6, h6, u3;
      return !e || t !== Q4.link_mode ? false : ((i3 = (s = this.client.metadata) == null ? void 0 : s.redirect) == null ? void 0 : i3.linkMode) === true && ((o3 = (r2 = this.client.metadata) == null ? void 0 : r2.redirect) == null ? void 0 : o3.universal) !== void 0 && ((l5 = (a2 = this.client.metadata) == null ? void 0 : a2.redirect) == null ? void 0 : l5.universal) !== "" && ((p6 = e == null ? void 0 : e.redirect) == null ? void 0 : p6.universal) !== void 0 && ((h6 = e == null ? void 0 : e.redirect) == null ? void 0 : h6.universal) !== "" && ((u3 = e == null ? void 0 : e.redirect) == null ? void 0 : u3.linkMode) === true && this.client.core.linkModeSupportedApps.includes(e.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }), c5(this, "getAppLinkIfEnabled", (e, t) => {
      var s;
      return this.isLinkModeEnabled(e, t) ? (s = e == null ? void 0 : e.redirect) == null ? void 0 : s.universal : void 0;
    }), c5(this, "handleLinkModeMessage", ({ url: e }) => {
      if (!e || !e.includes("wc_ev") || !e.includes("topic")) return;
      const t = wo3(e, "topic") || "", s = decodeURIComponent(wo3(e, "wc_ev") || ""), i3 = this.client.session.keys.includes(t);
      i3 && this.client.session.update(t, { transportType: Q4.link_mode }), this.client.core.dispatchEnvelope({ topic: t, message: s, sessionExists: i3 });
    }), c5(this, "registerLinkModeListeners", async () => {
      var e;
      if (vo3() || ne3() && (e = this.client.metadata.redirect) != null && e.linkMode) {
        const t = global == null ? void 0 : global.Linking;
        if (typeof t < "u") {
          t.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s = await t.getInitialURL();
          s && setTimeout(() => {
            this.handleLinkModeMessage({ url: s });
          }, 50);
        }
      }
    }), c5(this, "shouldSetTVF", (e, t) => {
      if (!t || e !== "wc_sessionRequest") return false;
      const { request: s } = t;
      return Object.keys(Ue7).includes(s.method);
    }), c5(this, "getTVFParams", (e, t, s) => {
      var i3, r2;
      try {
        const o3 = t.request.method, a2 = this.extractTxHashesFromResult(o3, s);
        return b2(v5({ correlationId: e, rpcMethods: [o3], chainId: t.chainId }, this.isValidContractData(t.request.params) && { contractAddresses: [(r2 = (i3 = t.request.params) == null ? void 0 : i3[0]) == null ? void 0 : r2.to] }), { txHashes: a2 });
      } catch (o3) {
        this.client.logger.warn("Error getting TVF params", o3);
      }
      return {};
    }), c5(this, "isValidContractData", (e) => {
      var t;
      if (!e) return false;
      try {
        const s = (e == null ? void 0 : e.data) || ((t = e == null ? void 0 : e[0]) == null ? void 0 : t.data);
        if (!s.startsWith("0x")) return false;
        const i3 = s.slice(2);
        return /^[0-9a-fA-F]*$/.test(i3) ? i3.length % 2 === 0 : false;
      } catch {
      }
      return false;
    }), c5(this, "extractTxHashesFromResult", (e, t) => {
      try {
        const s = Ue7[e];
        if (typeof t == "string") return [t];
        const i3 = t[s.key];
        if ($e5(i3)) return e === "solana_signAllTransactions" ? i3.map((r2) => qo3(r2)) : i3;
        if (typeof i3 == "string") return [i3];
      } catch (s) {
        this.client.logger.warn("Error extracting tx hashes from result", s);
      }
      return [];
    });
  }
  async processPendingMessageEvents() {
    try {
      const n3 = this.client.session.keys, e = this.client.core.relayer.messages.getWithoutAck(n3);
      for (const [t, s] of Object.entries(e)) for (const i3 of s) try {
        await this.onProviderMessageEvent({ topic: t, message: i3, publishedAt: Date.now() });
      } catch {
        this.client.logger.warn(`Error processing pending message event for topic: ${t}, message: ${i3}`);
      }
    } catch (n3) {
      this.client.logger.warn("processPendingMessageEvents failed", n3);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: n3 } = te4("NOT_INITIALIZED", this.name);
      throw new Error(n3);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(C4.message, (n3) => {
      this.onProviderMessageEvent(n3);
    });
  }
  async onRelayMessage(n3) {
    const { topic: e, message: t, attestation: s, transportType: i3 } = n3, { publicKey: r2 } = this.client.auth.authKeys.keys.includes(ce5) ? this.client.auth.authKeys.get(ce5) : { responseTopic: void 0, publicKey: void 0 };
    try {
      const o3 = await this.client.core.crypto.decode(e, t, { receiverPublicKey: r2, encoding: i3 === Q4.link_mode ? ti4 : At4 });
      isJsonRpcRequest(o3) ? (this.client.core.history.set(e, o3), await this.onRelayEventRequest({ topic: e, payload: o3, attestation: s, transportType: i3, encryptedId: ci4(t) })) : isJsonRpcResponse(o3) ? (await this.client.core.history.resolve(o3), await this.onRelayEventResponse({ topic: e, payload: o3, transportType: i3 }), this.client.core.history.delete(e, o3.id)) : await this.onRelayEventUnknownPayload({ topic: e, payload: o3, transportType: i3 }), await this.client.core.relayer.messages.ack(e, t);
    } catch (o3) {
      this.client.logger.error(o3);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(F5.expired, async (n3) => {
      const { topic: e, id: t } = ho3(n3.target);
      if (t && this.client.pendingRequest.keys.includes(t)) return await this.deletePendingSessionRequest(t, te4("EXPIRED"), true);
      if (t && this.client.auth.requests.keys.includes(t)) return await this.deletePendingAuthRequest(t, te4("EXPIRED"), true);
      e ? this.client.session.keys.includes(e) && (await this.deleteSession({ topic: e, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: e })) : t && (await this.deleteProposal(t, true), this.client.events.emit("proposal_expire", { id: t }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(se5.create, (n3) => this.onPairingCreated(n3)), this.client.core.pairing.events.on(se5.delete, (n3) => {
      this.addToRecentlyDeleted(n3.topic, "pairing");
    });
  }
  isValidPairingTopic(n3) {
    if (!q4(n3, false)) {
      const { message: e } = te4("MISSING_OR_INVALID", `pairing topic should be a string: ${n3}`);
      throw new Error(e);
    }
    if (!this.client.core.pairing.pairings.keys.includes(n3)) {
      const { message: e } = te4("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n3}`);
      throw new Error(e);
    }
    if (go3(this.client.core.pairing.pairings.get(n3).expiry)) {
      const { message: e } = te4("EXPIRED", `pairing topic: ${n3}`);
      throw new Error(e);
    }
  }
  async isValidSessionTopic(n3) {
    if (!q4(n3, false)) {
      const { message: e } = te4("MISSING_OR_INVALID", `session topic should be a string: ${n3}`);
      throw new Error(e);
    }
    if (this.checkRecentlyDeleted(n3), !this.client.session.keys.includes(n3)) {
      const { message: e } = te4("NO_MATCHING_KEY", `session topic doesn't exist: ${n3}`);
      throw new Error(e);
    }
    if (go3(this.client.session.get(n3).expiry)) {
      await this.deleteSession({ topic: n3 });
      const { message: e } = te4("EXPIRED", `session topic: ${n3}`);
      throw new Error(e);
    }
    if (!this.client.core.crypto.keychain.has(n3)) {
      const { message: e } = te4("MISSING_OR_INVALID", `session topic does not exist in keychain: ${n3}`);
      throw await this.deleteSession({ topic: n3 }), new Error(e);
    }
  }
  async isValidSessionOrPairingTopic(n3) {
    if (this.checkRecentlyDeleted(n3), this.client.session.keys.includes(n3)) await this.isValidSessionTopic(n3);
    else if (this.client.core.pairing.pairings.keys.includes(n3)) this.isValidPairingTopic(n3);
    else if (q4(n3, false)) {
      const { message: e } = te4("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${n3}`);
      throw new Error(e);
    } else {
      const { message: e } = te4("MISSING_OR_INVALID", `session or pairing topic should be a string: ${n3}`);
      throw new Error(e);
    }
  }
  async isValidProposalId(n3) {
    if (!Mi3(n3)) {
      const { message: e } = te4("MISSING_OR_INVALID", `proposal id should be a number: ${n3}`);
      throw new Error(e);
    }
    if (!this.client.proposal.keys.includes(n3)) {
      const { message: e } = te4("NO_MATCHING_KEY", `proposal id doesn't exist: ${n3}`);
      throw new Error(e);
    }
    if (go3(this.client.proposal.get(n3).expiryTimestamp)) {
      await this.deleteProposal(n3);
      const { message: e } = te4("EXPIRED", `proposal id: ${n3}`);
      throw new Error(e);
    }
  }
};
var Ns5 = class extends zi5 {
  constructor(n3, e) {
    super(n3, e, pt5, we5), this.core = n3, this.logger = e;
  }
};
var St7 = class extends zi5 {
  constructor(n3, e) {
    super(n3, e, ht5, we5), this.core = n3, this.logger = e;
  }
};
var Os5 = class extends zi5 {
  constructor(n3, e) {
    super(n3, e, ut5, we5, (t) => t.id), this.core = n3, this.logger = e;
  }
};
var bs5 = class extends zi5 {
  constructor(n3, e) {
    super(n3, e, mt5, ae4, () => ce5), this.core = n3, this.logger = e;
  }
};
var As5 = class extends zi5 {
  constructor(n3, e) {
    super(n3, e, _t6, ae4), this.core = n3, this.logger = e;
  }
};
var xs5 = class extends zi5 {
  constructor(n3, e) {
    super(n3, e, Et7, ae4, (t) => t.id), this.core = n3, this.logger = e;
  }
};
var Cs5 = Object.defineProperty;
var Vs6 = (S7, n3, e) => n3 in S7 ? Cs5(S7, n3, { enumerable: true, configurable: true, writable: true, value: e }) : S7[n3] = e;
var Ge7 = (S7, n3, e) => Vs6(S7, typeof n3 != "symbol" ? n3 + "" : n3, e);
var Ds5 = class {
  constructor(n3, e) {
    this.core = n3, this.logger = e, Ge7(this, "authKeys"), Ge7(this, "pairingTopics"), Ge7(this, "requests"), this.authKeys = new bs5(this.core, this.logger), this.pairingTopics = new As5(this.core, this.logger), this.requests = new xs5(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var Ls6 = Object.defineProperty;
var ks5 = (S7, n3, e) => n3 in S7 ? Ls6(S7, n3, { enumerable: true, configurable: true, writable: true, value: e }) : S7[n3] = e;
var E7 = (S7, n3, e) => ks5(S7, typeof n3 != "symbol" ? n3 + "" : n3, e);
var Ee7 = class _Ee extends J {
  constructor(n3) {
    super(n3), E7(this, "protocol", De5), E7(this, "version", Le6), E7(this, "name", me5.name), E7(this, "metadata"), E7(this, "core"), E7(this, "logger"), E7(this, "events", new import_events9.EventEmitter()), E7(this, "engine"), E7(this, "session"), E7(this, "proposal"), E7(this, "pendingRequest"), E7(this, "auth"), E7(this, "signConfig"), E7(this, "on", (t, s) => this.events.on(t, s)), E7(this, "once", (t, s) => this.events.once(t, s)), E7(this, "off", (t, s) => this.events.off(t, s)), E7(this, "removeListener", (t, s) => this.events.removeListener(t, s)), E7(this, "removeAllListeners", (t) => this.events.removeAllListeners(t)), E7(this, "connect", async (t) => {
      try {
        return await this.engine.connect(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E7(this, "pair", async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E7(this, "approve", async (t) => {
      try {
        return await this.engine.approve(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E7(this, "reject", async (t) => {
      try {
        return await this.engine.reject(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E7(this, "update", async (t) => {
      try {
        return await this.engine.update(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E7(this, "extend", async (t) => {
      try {
        return await this.engine.extend(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E7(this, "request", async (t) => {
      try {
        return await this.engine.request(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E7(this, "respond", async (t) => {
      try {
        return await this.engine.respond(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E7(this, "ping", async (t) => {
      try {
        return await this.engine.ping(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E7(this, "emit", async (t) => {
      try {
        return await this.engine.emit(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E7(this, "disconnect", async (t) => {
      try {
        return await this.engine.disconnect(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E7(this, "find", (t) => {
      try {
        return this.engine.find(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E7(this, "getPendingSessionRequests", () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }), E7(this, "authenticate", async (t, s) => {
      try {
        return await this.engine.authenticate(t, s);
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }), E7(this, "formatAuthMessage", (t) => {
      try {
        return this.engine.formatAuthMessage(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E7(this, "approveSessionAuthenticate", async (t) => {
      try {
        return await this.engine.approveSessionAuthenticate(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E7(this, "rejectSessionAuthenticate", async (t) => {
      try {
        return await this.engine.rejectSessionAuthenticate(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), this.name = (n3 == null ? void 0 : n3.name) || me5.name, this.metadata = (n3 == null ? void 0 : n3.metadata) || Xr3(), this.signConfig = n3 == null ? void 0 : n3.signConfig;
    const e = typeof (n3 == null ? void 0 : n3.logger) < "u" && typeof (n3 == null ? void 0 : n3.logger) != "string" ? n3.logger : (0, import_pino.default)(k({ level: (n3 == null ? void 0 : n3.logger) || me5.logger }));
    this.core = (n3 == null ? void 0 : n3.core) || new Jo4(n3), this.logger = E(e, this.name), this.session = new St7(this.core, this.logger), this.proposal = new Ns5(this.core, this.logger), this.pendingRequest = new Os5(this.core, this.logger), this.engine = new Ps5(this), this.auth = new Ds5(this.core, this.logger);
  }
  static async init(n3) {
    const e = new _Ee(n3);
    return await e.initialize(), e;
  }
  get context() {
    return y(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), setTimeout(() => {
        this.engine.processRelayMessageCache();
      }, (0, import_time6.toMiliseconds)(import_time6.ONE_SECOND));
    } catch (n3) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(n3.message), n3;
    }
  }
};

// node_modules/@reown/appkit/node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_events10 = __toESM(require_events());
var tt5 = "error";
var Nt6 = "wss://relay.walletconnect.org";
var St8 = "wc";
var Dt2 = "universal_provider";
var _6 = `${St8}@2:${Dt2}:`;
var et4 = "https://rpc.walletconnect.org/v1/";
var w3 = "generic";
var qt4 = `${et4}bundler`;
var d4 = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
function jt6() {
}
function B4(s) {
  return s == null || typeof s != "object" && typeof s != "function";
}
function G4(s) {
  return ArrayBuffer.isView(s) && !(s instanceof DataView);
}
function Rt7(s) {
  if (B4(s)) return s;
  if (Array.isArray(s) || G4(s) || s instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer) return s.slice(0);
  const t = Object.getPrototypeOf(s), e = t.constructor;
  if (s instanceof Date || s instanceof Map || s instanceof Set) return new e(s);
  if (s instanceof RegExp) {
    const i3 = new e(s);
    return i3.lastIndex = s.lastIndex, i3;
  }
  if (s instanceof DataView) return new e(s.buffer.slice(0));
  if (s instanceof Error) {
    const i3 = new e(s.message);
    return i3.stack = s.stack, i3.name = s.name, i3.cause = s.cause, i3;
  }
  if (typeof File < "u" && s instanceof File) return new e([s], s.name, { type: s.type, lastModified: s.lastModified });
  if (typeof s == "object") {
    const i3 = Object.create(t);
    return Object.assign(i3, s);
  }
  return s;
}
function st4(s) {
  return typeof s == "object" && s !== null;
}
function it5(s) {
  return Object.getOwnPropertySymbols(s).filter((t) => Object.prototype.propertyIsEnumerable.call(s, t));
}
function rt4(s) {
  return s == null ? s === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(s);
}
var _t7 = "[object RegExp]";
var nt2 = "[object String]";
var at4 = "[object Number]";
var ct4 = "[object Boolean]";
var ot4 = "[object Arguments]";
var Ut6 = "[object Symbol]";
var Ft6 = "[object Date]";
var Lt6 = "[object Map]";
var xt6 = "[object Set]";
var Mt5 = "[object Array]";
var Bt6 = "[object ArrayBuffer]";
var Gt6 = "[object Object]";
var Jt6 = "[object DataView]";
var zt6 = "[object Uint8Array]";
var kt7 = "[object Uint8ClampedArray]";
var Wt6 = "[object Uint16Array]";
var Kt4 = "[object Uint32Array]";
var Vt4 = "[object Int8Array]";
var Xt4 = "[object Int16Array]";
var Yt6 = "[object Int32Array]";
var Qt4 = "[object Float32Array]";
var Zt4 = "[object Float64Array]";
function Tt6(s, t) {
  return y8(s, void 0, s, /* @__PURE__ */ new Map(), t);
}
function y8(s, t, e, i3 = /* @__PURE__ */ new Map(), r2 = void 0) {
  const a2 = r2 == null ? void 0 : r2(s, t, e, i3);
  if (a2 != null) return a2;
  if (B4(s)) return s;
  if (i3.has(s)) return i3.get(s);
  if (Array.isArray(s)) {
    const n3 = new Array(s.length);
    i3.set(s, n3);
    for (let c6 = 0; c6 < s.length; c6++) n3[c6] = y8(s[c6], c6, e, i3, r2);
    return Object.hasOwn(s, "index") && (n3.index = s.index), Object.hasOwn(s, "input") && (n3.input = s.input), n3;
  }
  if (s instanceof Date) return new Date(s.getTime());
  if (s instanceof RegExp) {
    const n3 = new RegExp(s.source, s.flags);
    return n3.lastIndex = s.lastIndex, n3;
  }
  if (s instanceof Map) {
    const n3 = /* @__PURE__ */ new Map();
    i3.set(s, n3);
    for (const [c6, h6] of s) n3.set(c6, y8(h6, c6, e, i3, r2));
    return n3;
  }
  if (s instanceof Set) {
    const n3 = /* @__PURE__ */ new Set();
    i3.set(s, n3);
    for (const c6 of s) n3.add(y8(c6, void 0, e, i3, r2));
    return n3;
  }
  if (typeof Buffer < "u" && Buffer.isBuffer(s)) return s.subarray();
  if (G4(s)) {
    const n3 = new (Object.getPrototypeOf(s)).constructor(s.length);
    i3.set(s, n3);
    for (let c6 = 0; c6 < s.length; c6++) n3[c6] = y8(s[c6], c6, e, i3, r2);
    return n3;
  }
  if (s instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer) return s.slice(0);
  if (s instanceof DataView) {
    const n3 = new DataView(s.buffer.slice(0), s.byteOffset, s.byteLength);
    return i3.set(s, n3), g2(n3, s, e, i3, r2), n3;
  }
  if (typeof File < "u" && s instanceof File) {
    const n3 = new File([s], s.name, { type: s.type });
    return i3.set(s, n3), g2(n3, s, e, i3, r2), n3;
  }
  if (s instanceof Blob) {
    const n3 = new Blob([s], { type: s.type });
    return i3.set(s, n3), g2(n3, s, e, i3, r2), n3;
  }
  if (s instanceof Error) {
    const n3 = new s.constructor();
    return i3.set(s, n3), n3.message = s.message, n3.name = s.name, n3.stack = s.stack, n3.cause = s.cause, g2(n3, s, e, i3, r2), n3;
  }
  if (typeof s == "object" && te6(s)) {
    const n3 = Object.create(Object.getPrototypeOf(s));
    return i3.set(s, n3), g2(n3, s, e, i3, r2), n3;
  }
  return s;
}
function g2(s, t, e = s, i3, r2) {
  const a2 = [...Object.keys(t), ...it5(t)];
  for (let n3 = 0; n3 < a2.length; n3++) {
    const c6 = a2[n3], h6 = Object.getOwnPropertyDescriptor(s, c6);
    (h6 == null || h6.writable) && (s[c6] = y8(t[c6], c6, e, i3, r2));
  }
}
function te6(s) {
  switch (rt4(s)) {
    case ot4:
    case Mt5:
    case Bt6:
    case Jt6:
    case ct4:
    case Ft6:
    case Qt4:
    case Zt4:
    case Vt4:
    case Xt4:
    case Yt6:
    case Lt6:
    case at4:
    case Gt6:
    case _t7:
    case xt6:
    case nt2:
    case Ut6:
    case zt6:
    case kt7:
    case Wt6:
    case Kt4:
      return true;
    default:
      return false;
  }
}
function ee5(s, t) {
  return Tt6(s, (e, i3, r2, a2) => {
    const n3 = t == null ? void 0 : t(e, i3, r2, a2);
    if (n3 != null) return n3;
    if (typeof s == "object") switch (Object.prototype.toString.call(s)) {
      case at4:
      case nt2:
      case ct4: {
        const c6 = new s.constructor(s == null ? void 0 : s.valueOf());
        return g2(c6, s), c6;
      }
      case ot4: {
        const c6 = {};
        return g2(c6, s), c6.length = s.length, c6[Symbol.iterator] = s[Symbol.iterator], c6;
      }
      default:
        return;
    }
  });
}
function ht6(s) {
  return ee5(s);
}
function pt6(s) {
  return s !== null && typeof s == "object" && rt4(s) === "[object Arguments]";
}
function se6(s) {
  return G4(s);
}
function ie6(s) {
  var _a2;
  if (typeof s != "object" || s == null) return false;
  if (Object.getPrototypeOf(s) === null) return true;
  if (Object.prototype.toString.call(s) !== "[object Object]") {
    const e = s[Symbol.toStringTag];
    return e == null || !((_a2 = Object.getOwnPropertyDescriptor(s, Symbol.toStringTag)) == null ? void 0 : _a2.writable) ? false : s.toString() === `[object ${e}]`;
  }
  let t = s;
  for (; Object.getPrototypeOf(t) !== null; ) t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(s) === t;
}
function re6(s, ...t) {
  const e = t.slice(0, -1), i3 = t[t.length - 1];
  let r2 = s;
  for (let a2 = 0; a2 < e.length; a2++) {
    const n3 = e[a2];
    r2 = U2(r2, n3, i3, /* @__PURE__ */ new Map());
  }
  return r2;
}
function U2(s, t, e, i3) {
  if (B4(s) && (s = Object(s)), t == null || typeof t != "object") return s;
  if (i3.has(t)) return Rt7(i3.get(t));
  if (i3.set(t, s), Array.isArray(t)) {
    t = t.slice();
    for (let a2 = 0; a2 < t.length; a2++) t[a2] = t[a2] ?? void 0;
  }
  const r2 = [...Object.keys(t), ...it5(t)];
  for (let a2 = 0; a2 < r2.length; a2++) {
    const n3 = r2[a2];
    let c6 = t[n3], h6 = s[n3];
    if (pt6(c6) && (c6 = { ...c6 }), pt6(h6) && (h6 = { ...h6 }), typeof Buffer < "u" && Buffer.isBuffer(c6) && (c6 = ht6(c6)), Array.isArray(c6)) if (typeof h6 == "object" && h6 != null) {
      const j5 = [], R6 = Reflect.ownKeys(h6);
      for (let f10 = 0; f10 < R6.length; f10++) {
        const X2 = R6[f10];
        j5[X2] = h6[X2];
      }
      h6 = j5;
    } else h6 = [];
    const v6 = e(h6, c6, n3, s, t, i3);
    v6 != null ? s[n3] = v6 : Array.isArray(c6) || st4(h6) && st4(c6) ? s[n3] = U2(h6, c6, e, i3) : h6 == null && ie6(c6) ? s[n3] = U2({}, c6, e, i3) : h6 == null && se6(c6) ? s[n3] = ht6(c6) : (h6 === void 0 || c6 !== void 0) && (s[n3] = c6);
  }
  return s;
}
function ne4(s, ...t) {
  return re6(s, ...t, jt6);
}
var ae5 = Object.defineProperty;
var ce6 = Object.defineProperties;
var oe4 = Object.getOwnPropertyDescriptors;
var dt6 = Object.getOwnPropertySymbols;
var he4 = Object.prototype.hasOwnProperty;
var pe4 = Object.prototype.propertyIsEnumerable;
var ut6 = (s, t, e) => t in s ? ae5(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var F6 = (s, t) => {
  for (var e in t || (t = {})) he4.call(t, e) && ut6(s, e, t[e]);
  if (dt6) for (var e of dt6(t)) pe4.call(t, e) && ut6(s, e, t[e]);
  return s;
};
var de6 = (s, t) => ce6(s, oe4(t));
function p5(s, t, e) {
  var i3;
  const r2 = Ye4(s);
  return ((i3 = t.rpcMap) == null ? void 0 : i3[r2.reference]) || `${et4}?chainId=${r2.namespace}:${r2.reference}&projectId=${e}`;
}
function P5(s) {
  return s.includes(":") ? s.split(":")[1] : s;
}
function lt4(s) {
  return s.map((t) => `${t.split(":")[0]}:${t.split(":")[1]}`);
}
function ue6(s, t) {
  const e = Object.keys(t.namespaces).filter((r2) => r2.includes(s));
  if (!e.length) return [];
  const i3 = [];
  return e.forEach((r2) => {
    const a2 = t.namespaces[r2].accounts;
    i3.push(...a2);
  }), i3;
}
function J8(s = {}, t = {}) {
  const e = ft5(s), i3 = ft5(t);
  return ne4(e, i3);
}
function ft5(s) {
  var t, e, i3, r2;
  const a2 = {};
  if (!qe4(s)) return a2;
  for (const [n3, c6] of Object.entries(s)) {
    const h6 = Tt4(n3) ? [n3] : c6.chains, v6 = c6.methods || [], j5 = c6.events || [], R6 = c6.rpcMap || {}, f10 = pr4(n3);
    a2[f10] = de6(F6(F6({}, a2[f10]), c6), { chains: Q3(h6, (t = a2[f10]) == null ? void 0 : t.chains), methods: Q3(v6, (e = a2[f10]) == null ? void 0 : e.methods), events: Q3(j5, (i3 = a2[f10]) == null ? void 0 : i3.events), rpcMap: F6(F6({}, R6), (r2 = a2[f10]) == null ? void 0 : r2.rpcMap) });
  }
  return a2;
}
function le7(s) {
  return s.includes(":") ? s.split(":")[2] : s;
}
function mt6(s) {
  const t = {};
  for (const [e, i3] of Object.entries(s)) {
    const r2 = i3.methods || [], a2 = i3.events || [], n3 = i3.accounts || [], c6 = Tt4(e) ? [e] : i3.chains ? i3.chains : lt4(i3.accounts);
    t[e] = { chains: c6, methods: r2, events: a2, accounts: n3 };
  }
  return t;
}
function z8(s) {
  return typeof s == "number" ? s : s.includes("0x") ? parseInt(s, 16) : (s = s.includes(":") ? s.split(":")[1] : s, isNaN(Number(s)) ? s : Number(s));
}
var vt5 = {};
var o2 = (s) => vt5[s];
var k7 = (s, t) => {
  vt5[s] = t;
};
var fe5 = Object.defineProperty;
var me6 = (s, t, e) => t in s ? fe5(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var b3 = (s, t, e) => me6(s, typeof t != "symbol" ? t + "" : t, e);
var ve4 = class {
  constructor(t) {
    b3(this, "name", "polkadot"), b3(this, "client"), b3(this, "httpProviders"), b3(this, "events"), b3(this, "namespace"), b3(this, "chainId"), this.namespace = t.namespace, this.events = o2("events"), this.client = o2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d4.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      const r2 = P5(e);
      t[r2] = this.createHttpProvider(r2, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || p5(t, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i3, o2("disableProviderPing")));
  }
};
var ge2 = Object.defineProperty;
var Pe4 = Object.defineProperties;
var we6 = Object.getOwnPropertyDescriptors;
var gt5 = Object.getOwnPropertySymbols;
var ye4 = Object.prototype.hasOwnProperty;
var be5 = Object.prototype.propertyIsEnumerable;
var W3 = (s, t, e) => t in s ? ge2(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var Pt5 = (s, t) => {
  for (var e in t || (t = {})) ye4.call(t, e) && W3(s, e, t[e]);
  if (gt5) for (var e of gt5(t)) be5.call(t, e) && W3(s, e, t[e]);
  return s;
};
var wt7 = (s, t) => Pe4(s, we6(t));
var I4 = (s, t, e) => W3(s, typeof t != "symbol" ? t + "" : t, e);
var Ie6 = class {
  constructor(t) {
    I4(this, "name", "eip155"), I4(this, "client"), I4(this, "chainId"), I4(this, "namespace"), I4(this, "httpProviders"), I4(this, "events"), this.namespace = t.namespace, this.events = o2("events"), this.client = o2("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(t) {
    switch (t.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(t);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(t);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(t);
    }
    return this.namespace.methods.includes(t.request.method) ? await this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(parseInt(t), e), this.chainId = parseInt(t), this.events.emit(d4.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  createHttpProvider(t, e) {
    const i3 = e || p5(`${this.name}:${t}`, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i3, o2("disableProviderPing")));
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      const r2 = parseInt(P5(e));
      t[r2] = this.createHttpProvider(r2, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const t = this.chainId, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  async handleSwitchChain(t) {
    var e, i3;
    let r2 = t.request.params ? (e = t.request.params[0]) == null ? void 0 : e.chainId : "0x0";
    r2 = r2.startsWith("0x") ? r2 : `0x${r2}`;
    const a2 = parseInt(r2, 16);
    if (this.isChainApproved(a2)) this.setDefaultChain(`${a2}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: t.topic, request: { method: t.request.method, params: [{ chainId: r2 }] }, chainId: (i3 = this.namespace.chains) == null ? void 0 : i3[0] }), this.setDefaultChain(`${a2}`);
    else throw new Error(`Failed to switch to chain 'eip155:${a2}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(t) {
    return this.namespace.chains.includes(`${this.name}:${t}`);
  }
  async getCapabilities(t) {
    var e, i3, r2;
    const a2 = (i3 = (e = t.request) == null ? void 0 : e.params) == null ? void 0 : i3[0];
    if (!a2) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
    const n3 = this.client.session.get(t.topic), c6 = ((r2 = n3 == null ? void 0 : n3.sessionProperties) == null ? void 0 : r2.capabilities) || {};
    if (c6 != null && c6[a2]) return c6 == null ? void 0 : c6[a2];
    const h6 = await this.client.request(t);
    try {
      await this.client.session.update(t.topic, { sessionProperties: wt7(Pt5({}, n3.sessionProperties || {}), { capabilities: wt7(Pt5({}, c6 || {}), { [a2]: h6 }) }) });
    } catch (v6) {
      console.warn("Failed to update session with capabilities", v6);
    }
    return h6;
  }
  async getCallStatus(t) {
    var e, i3;
    const r2 = this.client.session.get(t.topic), a2 = (e = r2.sessionProperties) == null ? void 0 : e.bundler_name;
    if (a2) {
      const c6 = this.getBundlerUrl(t.chainId, a2);
      try {
        return await this.getUserOperationReceipt(c6, t);
      } catch (h6) {
        console.warn("Failed to fetch call status from bundler", h6, c6);
      }
    }
    const n3 = (i3 = r2.sessionProperties) == null ? void 0 : i3.bundler_url;
    if (n3) try {
      return await this.getUserOperationReceipt(n3, t);
    } catch (c6) {
      console.warn("Failed to fetch call status from custom bundler", c6, n3);
    }
    if (this.namespace.methods.includes(t.request.method)) return await this.client.request(t);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(t, e) {
    var i3;
    const r2 = new URL(t), a2 = await fetch(r2, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(formatJsonRpcRequest("eth_getUserOperationReceipt", [(i3 = e.request.params) == null ? void 0 : i3[0]])) });
    if (!a2.ok) throw new Error(`Failed to fetch user operation receipt - ${a2.status}`);
    return await a2.json();
  }
  getBundlerUrl(t, e) {
    return `${qt4}?projectId=${this.client.core.projectId}&chainId=${t}&bundler=${e}`;
  }
};
var $e7 = Object.defineProperty;
var Oe7 = (s, t, e) => t in s ? $e7(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var $6 = (s, t, e) => Oe7(s, typeof t != "symbol" ? t + "" : t, e);
var Ae5 = class {
  constructor(t) {
    $6(this, "name", "solana"), $6(this, "client"), $6(this, "httpProviders"), $6(this, "events"), $6(this, "namespace"), $6(this, "chainId"), this.namespace = t.namespace, this.events = o2("events"), this.client = o2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d4.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      const r2 = P5(e);
      t[r2] = this.createHttpProvider(r2, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || p5(t, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i3, o2("disableProviderPing")));
  }
};
var He5 = Object.defineProperty;
var Ee8 = (s, t, e) => t in s ? He5(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var O7 = (s, t, e) => Ee8(s, typeof t != "symbol" ? t + "" : t, e);
var Ce5 = class {
  constructor(t) {
    O7(this, "name", "cosmos"), O7(this, "client"), O7(this, "httpProviders"), O7(this, "events"), O7(this, "namespace"), O7(this, "chainId"), this.namespace = t.namespace, this.events = o2("events"), this.client = o2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d4.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      const r2 = P5(e);
      t[r2] = this.createHttpProvider(r2, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || p5(t, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i3, o2("disableProviderPing")));
  }
};
var Ne5 = Object.defineProperty;
var Se6 = (s, t, e) => t in s ? Ne5(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var A5 = (s, t, e) => Se6(s, typeof t != "symbol" ? t + "" : t, e);
var De6 = class {
  constructor(t) {
    A5(this, "name", "algorand"), A5(this, "client"), A5(this, "httpProviders"), A5(this, "events"), A5(this, "namespace"), A5(this, "chainId"), this.namespace = t.namespace, this.events = o2("events"), this.client = o2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    if (!this.httpProviders[t]) {
      const i3 = e || p5(`${this.name}:${t}`, this.namespace, this.client.core.projectId);
      if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
      this.setHttpProvider(t, i3);
    }
    this.chainId = t, this.events.emit(d4.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      t[e] = this.createHttpProvider(e, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || p5(t, this.namespace, this.client.core.projectId);
    return typeof i3 > "u" ? void 0 : new o(new f2(i3, o2("disableProviderPing")));
  }
};
var qe6 = Object.defineProperty;
var je6 = (s, t, e) => t in s ? qe6(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var H5 = (s, t, e) => je6(s, typeof t != "symbol" ? t + "" : t, e);
var Re4 = class {
  constructor(t) {
    H5(this, "name", "cip34"), H5(this, "client"), H5(this, "httpProviders"), H5(this, "events"), H5(this, "namespace"), H5(this, "chainId"), this.namespace = t.namespace, this.events = o2("events"), this.client = o2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d4.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      const i3 = this.getCardanoRPCUrl(e), r2 = P5(e);
      t[r2] = this.createHttpProvider(r2, i3);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  getCardanoRPCUrl(t) {
    const e = this.namespace.rpcMap;
    if (e) return e[t];
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || this.getCardanoRPCUrl(t);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i3, o2("disableProviderPing")));
  }
};
var _e8 = Object.defineProperty;
var Ue8 = (s, t, e) => t in s ? _e8(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var E8 = (s, t, e) => Ue8(s, typeof t != "symbol" ? t + "" : t, e);
var Fe6 = class {
  constructor(t) {
    E8(this, "name", "elrond"), E8(this, "client"), E8(this, "httpProviders"), E8(this, "events"), E8(this, "namespace"), E8(this, "chainId"), this.namespace = t.namespace, this.events = o2("events"), this.client = o2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d4.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      const r2 = P5(e);
      t[r2] = this.createHttpProvider(r2, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || p5(t, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i3, o2("disableProviderPing")));
  }
};
var Le7 = Object.defineProperty;
var xe5 = (s, t, e) => t in s ? Le7(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var C6 = (s, t, e) => xe5(s, typeof t != "symbol" ? t + "" : t, e);
var Me8 = class {
  constructor(t) {
    C6(this, "name", "multiversx"), C6(this, "client"), C6(this, "httpProviders"), C6(this, "events"), C6(this, "namespace"), C6(this, "chainId"), this.namespace = t.namespace, this.events = o2("events"), this.client = o2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d4.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      const r2 = P5(e);
      t[r2] = this.createHttpProvider(r2, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || p5(t, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i3, o2("disableProviderPing")));
  }
};
var Be7 = Object.defineProperty;
var Ge8 = (s, t, e) => t in s ? Be7(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var N6 = (s, t, e) => Ge8(s, typeof t != "symbol" ? t + "" : t, e);
var Je4 = class {
  constructor(t) {
    N6(this, "name", "near"), N6(this, "client"), N6(this, "httpProviders"), N6(this, "events"), N6(this, "namespace"), N6(this, "chainId"), this.namespace = t.namespace, this.events = o2("events"), this.client = o2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    if (this.chainId = t, !this.httpProviders[t]) {
      const i3 = e || p5(`${this.name}:${t}`, this.namespace);
      if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
      this.setHttpProvider(t, i3);
    }
    this.events.emit(d4.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      t[e] = this.createHttpProvider(e, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || p5(t, this.namespace);
    return typeof i3 > "u" ? void 0 : new o(new f2(i3, o2("disableProviderPing")));
  }
};
var ze6 = Object.defineProperty;
var ke8 = (s, t, e) => t in s ? ze6(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var S6 = (s, t, e) => ke8(s, typeof t != "symbol" ? t + "" : t, e);
var We7 = class {
  constructor(t) {
    S6(this, "name", "tezos"), S6(this, "client"), S6(this, "httpProviders"), S6(this, "events"), S6(this, "namespace"), S6(this, "chainId"), this.namespace = t.namespace, this.events = o2("events"), this.client = o2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    if (this.chainId = t, !this.httpProviders[t]) {
      const i3 = e || p5(`${this.name}:${t}`, this.namespace);
      if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
      this.setHttpProvider(t, i3);
    }
    this.events.emit(d4.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      t[e] = this.createHttpProvider(e);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || p5(t, this.namespace);
    return typeof i3 > "u" ? void 0 : new o(new f2(i3));
  }
};
var Ke8 = Object.defineProperty;
var Ve6 = (s, t, e) => t in s ? Ke8(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var D5 = (s, t, e) => Ve6(s, typeof t != "symbol" ? t + "" : t, e);
var Xe4 = class {
  constructor(t) {
    D5(this, "name", w3), D5(this, "client"), D5(this, "httpProviders"), D5(this, "events"), D5(this, "namespace"), D5(this, "chainId"), this.namespace = t.namespace, this.events = o2("events"), this.client = o2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(t.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(t.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(t.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(t.events || []))], this.httpProviders = this.createHttpProviders();
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider(t.chainId).request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d4.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    var t, e;
    const i3 = {};
    return (e = (t = this.namespace) == null ? void 0 : t.accounts) == null || e.forEach((r2) => {
      const a2 = Ye4(r2);
      i3[`${a2.namespace}:${a2.reference}`] = this.createHttpProvider(r2);
    }), i3;
  }
  getHttpProvider(t) {
    const e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || p5(t, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i3, o2("disableProviderPing")));
  }
};
var Ye6 = Object.defineProperty;
var Qe4 = Object.defineProperties;
var Ze5 = Object.getOwnPropertyDescriptors;
var yt5 = Object.getOwnPropertySymbols;
var Te5 = Object.prototype.hasOwnProperty;
var ts3 = Object.prototype.propertyIsEnumerable;
var K6 = (s, t, e) => t in s ? Ye6(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var L4 = (s, t) => {
  for (var e in t || (t = {})) Te5.call(t, e) && K6(s, e, t[e]);
  if (yt5) for (var e of yt5(t)) ts3.call(t, e) && K6(s, e, t[e]);
  return s;
};
var V7 = (s, t) => Qe4(s, Ze5(t));
var u2 = (s, t, e) => K6(s, typeof t != "symbol" ? t + "" : t, e);
var x8 = class _x {
  constructor(t) {
    u2(this, "client"), u2(this, "namespaces"), u2(this, "optionalNamespaces"), u2(this, "sessionProperties"), u2(this, "scopedProperties"), u2(this, "events", new import_events10.default()), u2(this, "rpcProviders", {}), u2(this, "session"), u2(this, "providerOpts"), u2(this, "logger"), u2(this, "uri"), u2(this, "disableProviderPing", false), this.providerOpts = t, this.logger = typeof (t == null ? void 0 : t.logger) < "u" && typeof (t == null ? void 0 : t.logger) != "string" ? t.logger : (0, import_pino.default)(k({ level: (t == null ? void 0 : t.logger) || tt5 })), this.disableProviderPing = (t == null ? void 0 : t.disableProviderPing) || false;
  }
  static async init(t) {
    const e = new _x(t);
    return await e.initialize(), e;
  }
  async request(t, e, i3) {
    const [r2, a2] = this.validateChain(e);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(r2).request({ request: L4({}, t), chainId: `${r2}:${a2}`, topic: this.session.topic, expiry: i3 });
  }
  sendAsync(t, e, i3, r2) {
    const a2 = (/* @__PURE__ */ new Date()).getTime();
    this.request(t, i3, r2).then((n3) => e(null, formatJsonRpcResult(a2, n3))).catch((n3) => e(n3, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var t;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (t = this.session) == null ? void 0 : t.topic, reason: de4("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(t) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(t), await this.cleanupPendingPairings(), !t.skipPairing) return await this.pair(t.pairingTopic);
  }
  async authenticate(t, e) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(t), await this.cleanupPendingPairings();
    const { uri: i3, response: r2 } = await this.client.authenticate(t, e);
    i3 && (this.uri = i3, this.events.emit("display_uri", i3));
    const a2 = await r2();
    if (this.session = a2.session, this.session) {
      const n3 = mt6(this.session.namespaces);
      this.namespaces = J8(this.namespaces, n3), await this.persist("namespaces", this.namespaces), this.onConnect();
    }
    return a2;
  }
  on(t, e) {
    this.events.on(t, e);
  }
  once(t, e) {
    this.events.once(t, e);
  }
  removeListener(t, e) {
    this.events.removeListener(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
  get isWalletConnect() {
    return true;
  }
  async pair(t) {
    const { uri: e, approval: i3 } = await this.client.connect({ pairingTopic: t, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties });
    e && (this.uri = e, this.events.emit("display_uri", e));
    const r2 = await i3();
    this.session = r2;
    const a2 = mt6(r2.namespaces);
    return this.namespaces = J8(this.namespaces, a2), await this.persist("namespaces", this.namespaces), await this.persist("optionalNamespaces", this.optionalNamespaces), this.onConnect(), this.session;
  }
  setDefaultChain(t, e) {
    try {
      if (!this.session) return;
      const [i3, r2] = this.validateChain(t), a2 = this.getProvider(i3);
      a2.name === w3 ? a2.setDefaultChain(`${i3}:${r2}`, e) : a2.setDefaultChain(r2, e);
    } catch (i3) {
      if (!/Please call connect/.test(i3.message)) throw i3;
    }
  }
  async cleanupPendingPairings(t = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const e = this.client.pairing.getAll();
    if ($e5(e)) {
      for (const i3 of e) t.deletePairings ? this.client.core.expirer.set(i3.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(i3.topic);
      this.logger.info(`Inactive pairings cleared: ${e.length}`);
    }
  }
  abortPairingAttempt() {
    this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.");
  }
  async checkStorage() {
    this.namespaces = await this.getFromStore("namespaces") || {}, this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.session && this.createProviders();
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    var t, e;
    if (this.client = this.providerOpts.client || await Ee7.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || tt5, relayUrl: this.providerOpts.relayUrl || Nt6, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.providerOpts.session) try {
      this.session = this.client.session.get(this.providerOpts.session.topic);
    } catch (i3) {
      throw this.logger.error("Failed to get session", i3), new Error(`The provided session: ${(e = (t = this.providerOpts) == null ? void 0 : t.session) == null ? void 0 : e.topic} doesn't exist in the Sign client`);
    }
    else {
      const i3 = this.client.session.getAll();
      this.session = i3[0];
    }
    this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const t = [...new Set(Object.keys(this.session.namespaces).map((e) => pr4(e)))];
    k7("client", this.client), k7("events", this.events), k7("disableProviderPing", this.disableProviderPing), t.forEach((e) => {
      if (!this.session) return;
      const i3 = ue6(e, this.session), r2 = lt4(i3), a2 = J8(this.namespaces, this.optionalNamespaces), n3 = V7(L4({}, a2[e]), { accounts: i3, chains: r2 });
      switch (e) {
        case "eip155":
          this.rpcProviders[e] = new Ie6({ namespace: n3 });
          break;
        case "algorand":
          this.rpcProviders[e] = new De6({ namespace: n3 });
          break;
        case "solana":
          this.rpcProviders[e] = new Ae5({ namespace: n3 });
          break;
        case "cosmos":
          this.rpcProviders[e] = new Ce5({ namespace: n3 });
          break;
        case "polkadot":
          this.rpcProviders[e] = new ve4({ namespace: n3 });
          break;
        case "cip34":
          this.rpcProviders[e] = new Re4({ namespace: n3 });
          break;
        case "elrond":
          this.rpcProviders[e] = new Fe6({ namespace: n3 });
          break;
        case "multiversx":
          this.rpcProviders[e] = new Me8({ namespace: n3 });
          break;
        case "near":
          this.rpcProviders[e] = new Je4({ namespace: n3 });
          break;
        case "tezos":
          this.rpcProviders[e] = new We7({ namespace: n3 });
          break;
        default:
          this.rpcProviders[w3] ? this.rpcProviders[w3].updateNamespace(n3) : this.rpcProviders[w3] = new Xe4({ namespace: n3 });
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (t) => {
      var e;
      const { topic: i3 } = t;
      i3 === ((e = this.session) == null ? void 0 : e.topic) && this.events.emit("session_ping", t);
    }), this.client.on("session_event", (t) => {
      var e;
      const { params: i3, topic: r2 } = t;
      if (r2 !== ((e = this.session) == null ? void 0 : e.topic)) return;
      const { event: a2 } = i3;
      if (a2.name === "accountsChanged") {
        const n3 = a2.data;
        n3 && $e5(n3) && this.events.emit("accountsChanged", n3.map(le7));
      } else if (a2.name === "chainChanged") {
        const n3 = i3.chainId, c6 = i3.event.data, h6 = pr4(n3), v6 = z8(n3) !== z8(c6) ? `${h6}:${z8(c6)}` : n3;
        this.onChainChanged(v6);
      } else this.events.emit(a2.name, a2.data);
      this.events.emit("session_event", t);
    }), this.client.on("session_update", ({ topic: t, params: e }) => {
      var i3, r2;
      if (t !== ((i3 = this.session) == null ? void 0 : i3.topic)) return;
      const { namespaces: a2 } = e, n3 = (r2 = this.client) == null ? void 0 : r2.session.get(t);
      this.session = V7(L4({}, n3), { namespaces: a2 }), this.onSessionUpdate(), this.events.emit("session_update", { topic: t, params: e });
    }), this.client.on("session_delete", async (t) => {
      var e;
      t.topic === ((e = this.session) == null ? void 0 : e.topic) && (await this.cleanup(), this.events.emit("session_delete", t), this.events.emit("disconnect", V7(L4({}, de4("USER_DISCONNECTED")), { data: t.topic })));
    }), this.on(d4.DEFAULT_CHAIN_CHANGED, (t) => {
      this.onChainChanged(t, true);
    });
  }
  getProvider(t) {
    return this.rpcProviders[t] || this.rpcProviders[w3];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((t) => {
      var e;
      this.getProvider(t).updateNamespace((e = this.session) == null ? void 0 : e.namespaces[t]);
    });
  }
  setNamespaces(t) {
    const { namespaces: e, optionalNamespaces: i3, sessionProperties: r2, scopedProperties: a2 } = t;
    e && Object.keys(e).length && (this.namespaces = e), i3 && Object.keys(i3).length && (this.optionalNamespaces = i3), this.sessionProperties = r2, this.scopedProperties = a2;
  }
  validateChain(t) {
    const [e, i3] = (t == null ? void 0 : t.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [e, i3];
    if (e && !Object.keys(this.namespaces || {}).map((n3) => pr4(n3)).includes(e)) throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);
    if (e && i3) return [e, i3];
    const r2 = pr4(Object.keys(this.namespaces)[0]), a2 = this.rpcProviders[r2].getDefaultChain();
    return [r2, a2];
  }
  async requestAccounts() {
    const [t] = this.validateChain();
    return await this.getProvider(t).requestAccounts();
  }
  async onChainChanged(t, e = false) {
    if (!this.namespaces) return;
    const [i3, r2] = this.validateChain(t);
    r2 && (e || this.getProvider(i3).setDefaultChain(r2), this.namespaces[i3] ? this.namespaces[i3].defaultChain = r2 : this.namespaces[`${i3}:${r2}`] ? this.namespaces[`${i3}:${r2}`].defaultChain = r2 : this.namespaces[`${i3}:${r2}`] = { defaultChain: r2 }, this.events.emit("chainChanged", r2), await this.persist("namespaces", this.namespaces));
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, await this.deleteFromStore("namespaces"), await this.deleteFromStore("optionalNamespaces"), await this.deleteFromStore("sessionProperties"), this.session = void 0, await this.cleanupPendingPairings({ deletePairings: true }), await this.cleanupStorage();
  }
  async persist(t, e) {
    var i3;
    const r2 = ((i3 = this.session) == null ? void 0 : i3.topic) || "";
    await this.client.core.storage.setItem(`${_6}/${t}${r2}`, e);
  }
  async getFromStore(t) {
    var e;
    const i3 = ((e = this.session) == null ? void 0 : e.topic) || "";
    return await this.client.core.storage.getItem(`${_6}/${t}${i3}`);
  }
  async deleteFromStore(t) {
    var e;
    const i3 = ((e = this.session) == null ? void 0 : e.topic) || "";
    await this.client.core.storage.removeItem(`${_6}/${t}${i3}`);
  }
  async cleanupStorage() {
    var t;
    try {
      if (((t = this.client) == null ? void 0 : t.session.length) > 0) return;
      const e = await this.client.core.storage.getKeys();
      for (const i3 of e) i3.startsWith(_6) && await this.client.core.storage.removeItem(i3);
    } catch (e) {
      this.logger.warn("Failed to cleanup storage", e);
    }
  }
};

// node_modules/@reown/appkit/dist/esm/src/utils/ConstantsUtil.js
var WcConstantsUtil = {
  ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
  ERROR_CODE_DEFAULT: 5e3,
  ERROR_INVALID_CHAIN_ID: 32603
};

// node_modules/viem/_esm/chains/definitions/abey.js
var abey = defineChain({
  id: 179,
  name: "ABEY Mainnet",
  nativeCurrency: { name: "ABEY", symbol: "ABEY", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.abeychain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Abey Scan",
      url: "https://abeyscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/zksync/constants/number.js
var gasPerPubdataDefault = 50000n;
var maxBytecodeSize = maxUint16 * 32n;

// node_modules/viem/_esm/zksync/formatters.js
var formatters = {
  block: defineBlock({
    format(args) {
      var _a2;
      const transactions = (_a2 = args.transactions) == null ? void 0 : _a2.map((transaction) => {
        var _a3;
        if (typeof transaction === "string")
          return transaction;
        const formatted = (_a3 = formatters.transaction) == null ? void 0 : _a3.format(transaction);
        if (formatted.typeHex === "0x71")
          formatted.type = "eip712";
        else if (formatted.typeHex === "0xff")
          formatted.type = "priority";
        return formatted;
      });
      return {
        l1BatchNumber: args.l1BatchNumber ? hexToBigInt2(args.l1BatchNumber) : null,
        l1BatchTimestamp: args.l1BatchTimestamp ? hexToBigInt2(args.l1BatchTimestamp) : null,
        transactions
      };
    }
  }),
  transaction: defineTransaction({
    format(args) {
      const transaction = {};
      if (args.type === "0x71")
        transaction.type = "eip712";
      else if (args.type === "0xff")
        transaction.type = "priority";
      return {
        ...transaction,
        l1BatchNumber: args.l1BatchNumber ? hexToBigInt2(args.l1BatchNumber) : null,
        l1BatchTxIndex: args.l1BatchTxIndex ? hexToBigInt2(args.l1BatchTxIndex) : null
      };
    }
  }),
  transactionReceipt: defineTransactionReceipt({
    format(args) {
      return {
        l1BatchNumber: args.l1BatchNumber ? hexToBigInt2(args.l1BatchNumber) : null,
        l1BatchTxIndex: args.l1BatchTxIndex ? hexToBigInt2(args.l1BatchTxIndex) : null,
        logs: args.logs.map((log) => {
          return {
            ...formatLog(log),
            l1BatchNumber: log.l1BatchNumber ? hexToBigInt2(log.l1BatchNumber) : null,
            transactionLogIndex: hexToNumber2(log.transactionLogIndex),
            logType: log.logType
          };
        }),
        l2ToL1Logs: args.l2ToL1Logs.map((l2ToL1Log) => {
          return {
            blockNumber: hexToBigInt2(l2ToL1Log.blockHash),
            blockHash: l2ToL1Log.blockHash,
            l1BatchNumber: l2ToL1Log.l1BatchNumber ? hexToBigInt2(l2ToL1Log.l1BatchNumber) : null,
            transactionIndex: hexToBigInt2(l2ToL1Log.transactionIndex),
            shardId: hexToBigInt2(l2ToL1Log.shardId),
            isService: l2ToL1Log.isService,
            sender: l2ToL1Log.sender,
            key: l2ToL1Log.key,
            value: l2ToL1Log.value,
            transactionHash: l2ToL1Log.transactionHash,
            logIndex: hexToBigInt2(l2ToL1Log.logIndex)
          };
        })
      };
    }
  }),
  transactionRequest: defineTransactionRequest({
    exclude: [
      "customSignature",
      "factoryDeps",
      "gasPerPubdata",
      "paymaster",
      "paymasterInput"
    ],
    format(args) {
      if (args.gasPerPubdata || args.paymaster && args.paymasterInput || args.factoryDeps || args.customSignature)
        return {
          eip712Meta: {
            ...args.gasPerPubdata ? { gasPerPubdata: toHex2(args.gasPerPubdata) } : { gasPerPubdata: toHex2(gasPerPubdataDefault) },
            ...args.paymaster && args.paymasterInput ? {
              paymasterParams: {
                paymaster: args.paymaster,
                paymasterInput: Array.from(hexToBytes(args.paymasterInput))
              }
            } : {},
            ...args.factoryDeps ? {
              factoryDeps: args.factoryDeps.map((dep) => Array.from(hexToBytes(dep)))
            } : {},
            ...args.customSignature ? {
              customSignature: Array.from(hexToBytes(args.customSignature))
            } : {}
          },
          type: "0x71"
        };
      return {};
    }
  })
};

// node_modules/viem/_esm/zksync/errors/transaction.js
var InvalidEip712TransactionError = class extends BaseError {
  constructor() {
    super([
      "Transaction is not an EIP712 transaction.",
      "",
      "Transaction must:",
      '  - include `type: "eip712"`',
      "  - include one of the following: `customSignature`, `paymaster`, `paymasterInput`, `gasPerPubdata`, `factoryDeps`"
    ].join("\n"), { name: "InvalidEip712TransactionError" });
  }
};

// node_modules/viem/_esm/zksync/utils/isEip712Transaction.js
function isEIP712Transaction(transaction) {
  if (transaction.type === "eip712")
    return true;
  if ("customSignature" in transaction && transaction.customSignature || "paymaster" in transaction && transaction.paymaster || "paymasterInput" in transaction && transaction.paymasterInput || "gasPerPubdata" in transaction && typeof transaction.gasPerPubdata === "bigint" || "factoryDeps" in transaction && transaction.factoryDeps)
    return true;
  return false;
}

// node_modules/viem/_esm/zksync/utils/assertEip712Transaction.js
function assertEip712Transaction(transaction) {
  const { chainId, to: to4, from: from11, paymaster, paymasterInput } = transaction;
  if (!isEIP712Transaction(transaction))
    throw new InvalidEip712TransactionError();
  if (!chainId || chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to4 && !isAddress(to4))
    throw new InvalidAddressError({ address: to4 });
  if (from11 && !isAddress(from11))
    throw new InvalidAddressError({ address: from11 });
  if (paymaster && !isAddress(paymaster))
    throw new InvalidAddressError({ address: paymaster });
  if (paymaster && !paymasterInput) {
    throw new BaseError("`paymasterInput` must be provided when `paymaster` is defined");
  }
  if (!paymaster && paymasterInput) {
    throw new BaseError("`paymaster` must be provided when `paymasterInput` is defined");
  }
}

// node_modules/viem/_esm/zksync/serializers.js
function serializeTransaction4(transaction, signature) {
  if (isEIP712Transaction(transaction))
    return serializeTransactionEIP712(transaction);
  return serializeTransaction(transaction, signature);
}
var serializers = {
  transaction: serializeTransaction4
};
function serializeTransactionEIP712(transaction) {
  const { chainId, gas, nonce, to: to4, from: from11, value, maxFeePerGas, maxPriorityFeePerGas, customSignature, factoryDeps, paymaster, paymasterInput, gasPerPubdata, data } = transaction;
  assertEip712Transaction(transaction);
  const serializedTransaction = [
    nonce ? toHex2(nonce) : "0x",
    maxPriorityFeePerGas ? toHex2(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex2(maxFeePerGas) : "0x",
    gas ? toHex2(gas) : "0x",
    to4 ?? "0x",
    value ? toHex2(value) : "0x",
    data ?? "0x",
    toHex2(chainId),
    toHex2(""),
    toHex2(""),
    toHex2(chainId),
    from11 ?? "0x",
    gasPerPubdata ? toHex2(gasPerPubdata) : toHex2(gasPerPubdataDefault),
    factoryDeps ?? [],
    customSignature ?? "0x",
    // EIP712 signature
    paymaster && paymasterInput ? [paymaster, paymasterInput] : []
  ];
  return concatHex([
    "0x71",
    toRlp(serializedTransaction)
  ]);
}

// node_modules/viem/_esm/zksync/errors/bytecode.js
var BytecodeLengthExceedsMaxSizeError = class extends BaseError {
  constructor({ givenLength, maxBytecodeSize: maxBytecodeSize2 }) {
    super(`Bytecode cannot be longer than ${maxBytecodeSize2} bytes. Given length: ${givenLength}`, { name: "BytecodeLengthExceedsMaxSizeError" });
  }
};
var BytecodeLengthInWordsMustBeOddError = class extends BaseError {
  constructor({ givenLengthInWords }) {
    super(`Bytecode length in 32-byte words must be odd. Given length in words: ${givenLengthInWords}`, { name: "BytecodeLengthInWordsMustBeOddError" });
  }
};
var BytecodeLengthMustBeDivisibleBy32Error = class extends BaseError {
  constructor({ givenLength }) {
    super(`The bytecode length in bytes must be divisible by 32. Given length: ${givenLength}`, { name: "BytecodeLengthMustBeDivisibleBy32Error" });
  }
};

// node_modules/viem/_esm/zksync/utils/hashBytecode.js
function hashBytecode(bytecode) {
  const bytecodeBytes = toBytes(bytecode);
  if (bytecodeBytes.length % 32 !== 0)
    throw new BytecodeLengthMustBeDivisibleBy32Error({
      givenLength: bytecodeBytes.length
    });
  if (bytecodeBytes.length > maxBytecodeSize)
    throw new BytecodeLengthExceedsMaxSizeError({
      givenLength: bytecodeBytes.length,
      maxBytecodeSize
    });
  const hashStr = sha256(bytecodeBytes);
  const hash = toBytes(hashStr);
  const bytecodeLengthInWords = bytecodeBytes.length / 32;
  if (bytecodeLengthInWords % 2 === 0) {
    throw new BytecodeLengthInWordsMustBeOddError({
      givenLengthInWords: bytecodeLengthInWords
    });
  }
  const bytecodeLength = toBytes(bytecodeLengthInWords);
  const bytecodeLengthPadded = pad(bytecodeLength, { size: 2 });
  const codeHashVersion = new Uint8Array([1, 0]);
  hash.set(codeHashVersion, 0);
  hash.set(bytecodeLengthPadded, 2);
  return hash;
}

// node_modules/viem/_esm/zksync/utils/getEip712Domain.js
var getEip712Domain3 = (transaction) => {
  assertEip712Transaction(transaction);
  const message = transactionToMessage(transaction);
  return {
    domain: {
      name: "zkSync",
      version: "2",
      chainId: transaction.chainId
    },
    types: {
      Transaction: [
        { name: "txType", type: "uint256" },
        { name: "from", type: "uint256" },
        { name: "to", type: "uint256" },
        { name: "gasLimit", type: "uint256" },
        { name: "gasPerPubdataByteLimit", type: "uint256" },
        { name: "maxFeePerGas", type: "uint256" },
        { name: "maxPriorityFeePerGas", type: "uint256" },
        { name: "paymaster", type: "uint256" },
        { name: "nonce", type: "uint256" },
        { name: "value", type: "uint256" },
        { name: "data", type: "bytes" },
        { name: "factoryDeps", type: "bytes32[]" },
        { name: "paymasterInput", type: "bytes" }
      ]
    },
    primaryType: "Transaction",
    message
  };
};
function transactionToMessage(transaction) {
  const { gas, nonce, to: to4, from: from11, value, maxFeePerGas, maxPriorityFeePerGas, factoryDeps, paymaster, paymasterInput, gasPerPubdata, data } = transaction;
  return {
    txType: 113n,
    from: BigInt(from11),
    to: to4 ? BigInt(to4) : 0n,
    gasLimit: gas ?? 0n,
    gasPerPubdataByteLimit: gasPerPubdata ?? gasPerPubdataDefault,
    maxFeePerGas: maxFeePerGas ?? 0n,
    maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,
    paymaster: paymaster ? BigInt(paymaster) : 0n,
    nonce: nonce ? BigInt(nonce) : 0n,
    value: value ?? 0n,
    data: data ? data : "0x0",
    factoryDeps: (factoryDeps == null ? void 0 : factoryDeps.map((dep) => toHex2(hashBytecode(dep)))) ?? [],
    paymasterInput: paymasterInput ? paymasterInput : "0x"
  };
}

// node_modules/viem/_esm/zksync/chainConfig.js
var chainConfig = {
  formatters,
  serializers,
  custom: {
    getEip712Domain: getEip712Domain3
  }
};

// node_modules/viem/_esm/chains/definitions/abstract.js
var abstract = defineChain({
  ...chainConfig,
  id: 2741,
  name: "Abstract",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://api.mainnet.abs.xyz"],
      webSocket: ["wss://api.mainnet.abs.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://abscan.org"
    },
    native: {
      name: "Abstract Explorer",
      url: "https://explorer.mainnet.abs.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xAa4De41dba0Ca5dCBb288b7cC6b708F3aaC759E7",
      blockCreated: 5288
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 5263
    }
  }
});

// node_modules/viem/_esm/chains/definitions/abstractTestnet.js
var abstractTestnet = defineChain({
  ...chainConfig,
  id: 11124,
  name: "Abstract Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://api.testnet.abs.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.abscan.org"
    },
    native: {
      name: "Abstract Explorer",
      url: "https://explorer.testnet.abs.xyz"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963",
      blockCreated: 358349
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 431682
    }
  }
});

// node_modules/viem/_esm/chains/definitions/acala.js
var acala = defineChain({
  id: 787,
  name: "Acala",
  network: "acala",
  nativeCurrency: {
    name: "Acala",
    symbol: "ACA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-acala.aca-api.network"],
      webSocket: ["wss://eth-rpc-acala.aca-api.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Acala Blockscout",
      url: "https://blockscout.acala.network",
      apiUrl: "https://blockscout.acala.network/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/acria.js
var acria = defineChain({
  id: 47,
  name: "Acria IntelliChain",
  nativeCurrency: {
    decimals: 18,
    name: "ACRIA",
    symbol: "ACRIA"
  },
  rpcUrls: {
    default: {
      http: ["https://aic.acria.ai"]
    }
  },
  blockExplorers: {
    default: {
      name: "Acria Explorer",
      url: "https://explorer.acria.ai"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/adf.js
var adf = defineChain({
  id: 1215,
  name: "ADF Chain",
  nativeCurrency: { name: "ADDFILL", symbol: "ADF", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.adftechnology.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "ADF Mainnet Explorer",
      url: "https://explorer.adftechnology.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/aioz.js
var aioz = defineChain({
  id: 168,
  name: "AIOZ Network",
  nativeCurrency: {
    decimals: 18,
    name: "AIOZ",
    symbol: "AIOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://eth-dataseed.aioz.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "AIOZ Explorer",
      url: "https://explorer.aioz.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/alephZero.js
var alephZero = defineChain({
  id: 41455,
  name: "Aleph Zero",
  nativeCurrency: { name: "Aleph Zero", symbol: "AZERO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.alephzero.raas.gelato.cloud"]
    }
  },
  blockExplorers: {
    default: {
      name: "Aleph Zero EVM Explorer",
      url: "https://evm-explorer.alephzero.org",
      apiUrl: "https://evm-explorer.alephzero.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4603377
    }
  }
});

// node_modules/viem/_esm/chains/definitions/alephZeroTestnet.js
var alephZeroTestnet = defineChain({
  id: 2039,
  name: "Aleph Zero Testnet",
  nativeCurrency: { name: "TZERO", symbol: "TZERO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.alephzero-testnet.gelato.digital"],
      webSocket: ["wss://ws.alephzero-testnet.gelato.digital"]
    }
  },
  blockExplorers: {
    default: {
      name: "Aleph Zero EVM Testnet explorer",
      url: "https://evm-explorer-testnet.alephzero.org",
      apiUrl: "https://evm-explorer-testnet.alephzero.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2861745
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/alienX.js
var alienx = defineChain({
  id: 10241024,
  name: "AlienX Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.alienxchain.io/http"] }
  },
  blockExplorers: {
    default: {
      name: "AlienX Explorer",
      url: "https://explorer.alienxchain.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/alienXHalTestnet.js
var alienxHalTestnet = defineChain({
  id: 10241025,
  name: "ALIENX Hal Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://hal-rpc.alienxchain.io/http"] }
  },
  blockExplorers: {
    default: {
      name: "AlienX Explorer",
      url: "https://hal-explorer.alienxchain.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/op-stack/contracts.js
var contracts = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
};

// node_modules/viem/_esm/op-stack/formatters.js
var formatters2 = {
  block: defineBlock({
    format(args) {
      var _a2;
      const transactions = (_a2 = args.transactions) == null ? void 0 : _a2.map((transaction) => {
        if (typeof transaction === "string")
          return transaction;
        const formatted = formatTransaction(transaction);
        if (formatted.typeHex === "0x7e") {
          formatted.isSystemTx = transaction.isSystemTx;
          formatted.mint = transaction.mint ? hexToBigInt2(transaction.mint) : void 0;
          formatted.sourceHash = transaction.sourceHash;
          formatted.type = "deposit";
        }
        return formatted;
      });
      return {
        transactions,
        stateRoot: args.stateRoot
      };
    }
  }),
  transaction: defineTransaction({
    format(args) {
      const transaction = {};
      if (args.type === "0x7e") {
        transaction.isSystemTx = args.isSystemTx;
        transaction.mint = args.mint ? hexToBigInt2(args.mint) : void 0;
        transaction.sourceHash = args.sourceHash;
        transaction.type = "deposit";
      }
      return transaction;
    }
  }),
  transactionReceipt: defineTransactionReceipt({
    format(args) {
      return {
        l1GasPrice: args.l1GasPrice ? hexToBigInt2(args.l1GasPrice) : null,
        l1GasUsed: args.l1GasUsed ? hexToBigInt2(args.l1GasUsed) : null,
        l1Fee: args.l1Fee ? hexToBigInt2(args.l1Fee) : null,
        l1FeeScalar: args.l1FeeScalar ? Number(args.l1FeeScalar) : null
      };
    }
  })
};

// node_modules/viem/_esm/op-stack/serializers.js
function serializeTransaction5(transaction, signature) {
  if (isDeposit(transaction))
    return serializeTransactionDeposit(transaction);
  return serializeTransaction(transaction, signature);
}
var serializers2 = {
  transaction: serializeTransaction5
};
function serializeTransactionDeposit(transaction) {
  assertTransactionDeposit(transaction);
  const { sourceHash, data, from: from11, gas, isSystemTx, mint: mint2, to: to4, value } = transaction;
  const serializedTransaction = [
    sourceHash,
    from11,
    to4 ?? "0x",
    mint2 ? toHex2(mint2) : "0x",
    value ? toHex2(value) : "0x",
    gas ? toHex2(gas) : "0x",
    isSystemTx ? "0x1" : "0x",
    data ?? "0x"
  ];
  return concatHex([
    "0x7e",
    toRlp(serializedTransaction)
  ]);
}
function isDeposit(transaction) {
  if (transaction.type === "deposit")
    return true;
  if (typeof transaction.sourceHash !== "undefined")
    return true;
  return false;
}
function assertTransactionDeposit(transaction) {
  const { from: from11, to: to4 } = transaction;
  if (from11 && !isAddress(from11))
    throw new InvalidAddressError({ address: from11 });
  if (to4 && !isAddress(to4))
    throw new InvalidAddressError({ address: to4 });
}

// node_modules/viem/_esm/op-stack/chainConfig.js
var chainConfig2 = {
  contracts,
  formatters: formatters2,
  serializers: serializers2
};

// node_modules/viem/_esm/chains/definitions/ancient8.js
var sourceId = 1;
var ancient8 = defineChain({
  ...chainConfig2,
  id: 888888888,
  name: "Ancient8",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.ancient8.gg"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ancient8 explorer",
      url: "https://scan.ancient8.gg",
      apiUrl: "https://scan.ancient8.gg/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId]: {
        address: "0xB09DC08428C8b4EFB4ff9C0827386CDF34277996"
      }
    },
    portal: {
      [sourceId]: {
        address: "0x639F2AECE398Aa76b07e59eF6abe2cFe32bacb68",
        blockCreated: 19070571
      }
    },
    l1StandardBridge: {
      [sourceId]: {
        address: "0xd5e3eDf5b68135D559D572E26bF863FBC1950033",
        blockCreated: 19070571
      }
    }
  },
  sourceId
});

// node_modules/viem/_esm/chains/definitions/ancient8Sepolia.js
var sourceId2 = 11155111;
var ancient8Sepolia = defineChain({
  ...chainConfig2,
  id: 28122024,
  name: "Ancient8 Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpcv2-testnet.ancient8.gg"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ancient8 Celestia Testnet explorer",
      url: "https://scanv2-testnet.ancient8.gg",
      apiUrl: "https://scanv2-testnet.ancient8.gg/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId2]: {
        address: "0x942fD5017c0F60575930D8574Eaca13BEcD6e1bB"
      }
    },
    portal: {
      [sourceId2]: {
        address: "0xfa1d9E26A6aCD7b22115D27572c1221B9803c960",
        blockCreated: 4972908
      }
    },
    l1StandardBridge: {
      [sourceId2]: {
        address: "0xF6Bc0146d3c74D48306e79Ae134A260E418C9335",
        blockCreated: 4972908
      }
    }
  },
  sourceId: sourceId2
});

// node_modules/viem/_esm/chains/definitions/anvil.js
var anvil = defineChain({
  id: 31337,
  name: "Anvil",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:8545"],
      webSocket: ["ws://127.0.0.1:8545"]
    }
  }
});

// node_modules/viem/_esm/chains/definitions/apeChain.js
var sourceId3 = 42161;
var apeChain = defineChain({
  id: 33139,
  name: "Ape Chain",
  nativeCurrency: {
    name: "ApeCoin",
    symbol: "APE",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.apechain.com/http"],
      webSocket: ["wss://rpc.apechain.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Apescan",
      url: "https://apescan.io",
      apiUrl: "https://api.apescan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 20889
    }
  },
  sourceId: sourceId3
});

// node_modules/viem/_esm/chains/definitions/apexTestnet.js
var apexTestnet = defineChain({
  id: 3993,
  name: "APEX Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.apexlayer.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp-testnet.apexlayer.xyz",
      apiUrl: "https://exp-testnet.apexlayer.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xf7642be33a6b18D16a995657adb5a68CD0438aE2",
      blockCreated: 283775
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/arbitrum.js
var arbitrum = defineChain({
  id: 42161,
  name: "Arbitrum One",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://arbiscan.io",
      apiUrl: "https://api.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
});

// node_modules/viem/_esm/chains/definitions/arbitrumGoerli.js
var arbitrumGoerli = defineChain({
  id: 421613,
  name: "Arbitrum Goerli",
  nativeCurrency: {
    name: "Arbitrum Goerli Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://goerli-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://goerli.arbiscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 88114
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/arbitrumNova.js
var arbitrumNova = defineChain({
  id: 42170,
  name: "Arbitrum Nova",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://nova.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://nova.arbiscan.io",
      apiUrl: "https://api-nova.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1746963
    }
  }
});

// node_modules/viem/_esm/chains/definitions/arbitrumSepolia.js
var arbitrumSepolia = defineChain({
  id: 421614,
  name: "Arbitrum Sepolia",
  nativeCurrency: {
    name: "Arbitrum Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://sepolia.arbiscan.io",
      apiUrl: "https://api-sepolia.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 81930
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/arenaz.js
var arenaz = defineChain({
  id: 7897,
  name: "Arena-Z",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.arena-z.gg"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arena-Z Explorer",
      url: "https://explorer.arena-z.gg",
      apiUrl: "https://explorer.arena-z.gg"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/areonNetwork.js
var areonNetwork = defineChain({
  id: 463,
  name: "Areon Network",
  nativeCurrency: { decimals: 18, name: "AREA", symbol: "AREA" },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.areon.network"],
      webSocket: ["wss://mainnet-ws.areon.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Areonscan",
      url: "https://areonscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 353286
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/areonNetworkTestnet.js
var areonNetworkTestnet = defineChain({
  id: 462,
  name: "Areon Network Testnet",
  nativeCurrency: { decimals: 18, name: "TAREA", symbol: "TAREA" },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.areon.network"],
      webSocket: ["wss://testnet-ws.areon.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Areonscan",
      url: "https://areonscan.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/artelaTestnet.js
var artelaTestnet = defineChain({
  id: 11822,
  name: "Artela Testnet",
  nativeCurrency: { name: "ART", symbol: "ART", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://betanet-rpc1.artela.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Artela",
      url: "https://betanet-scan.artela.network",
      apiUrl: "https://betanet-scan.artela.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xd07c8635f76e8745Ee7092fbb6e8fbc5FeF09DD7",
      blockCreated: 7001871
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/arthera.js
var arthera = defineChain({
  id: 10242,
  name: "Arthera",
  nativeCurrency: { name: "Arthera", symbol: "AA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.arthera.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arthera EVM Explorer",
      url: "https://explorer.arthera.net",
      apiUrl: "https://explorer.arthera.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4502791
    }
  }
});

// node_modules/viem/_esm/chains/definitions/artheraTestnet.js
var artheraTestnet = defineChain({
  id: 10243,
  name: "Arthera Testnet",
  nativeCurrency: { name: "Arthera", symbol: "AA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-test.arthera.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arthera EVM Explorer",
      url: "https://explorer-test.arthera.net",
      apiUrl: "https://explorer-test.arthera.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 22051
    }
  }
});

// node_modules/viem/_esm/chains/definitions/assetChain.js
var assetChain = defineChain({
  id: 42420,
  name: "AssetChain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Real World Asset",
    symbol: "RWA"
  },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.assetchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Asset Chain Explorer",
      url: "https://scan.assetchain.org",
      apiUrl: "https://scan.assetchain.org/api"
    }
  },
  testnet: false,
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/assetChainTestnet.js
var assetChainTestnet = defineChain({
  id: 42421,
  name: "AssetChain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Real World Asset",
    symbol: "RWA"
  },
  rpcUrls: {
    default: { http: ["https://enugu-rpc.assetchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Asset Chain Testnet Explorer",
      url: "https://scan-testnet.assetchain.org",
      apiUrl: "https://scan-testnet.assetchain.org/api"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0x989F832D35988cb5e3eB001Fa2Fe789469EC31Ea",
      blockCreated: 17177
    }
  }
});

// node_modules/viem/_esm/chains/definitions/astar.js
var astar = defineChain({
  id: 592,
  name: "Astar",
  network: "astar-mainnet",
  nativeCurrency: {
    name: "Astar",
    symbol: "ASTR",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://astar.api.onfinality.io/public"] }
  },
  blockExplorers: {
    default: {
      name: "Astar Subscan",
      url: "https://astar.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 761794
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/astarZkEVM.js
var astarZkEVM = defineChain({
  id: 3776,
  name: "Astar zkEVM",
  network: "AstarZkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-zkevm.astar.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Astar zkEVM Explorer",
      url: "https://astar-zkevm.explorer.startale.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 93528
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/astarZkyoto.js
var astarZkyoto = defineChain({
  id: 6038361,
  name: "Astar zkEVM Testnet zKyoto",
  network: "zKyoto",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.startale.com/zkyoto"]
    }
  },
  blockExplorers: {
    default: {
      name: "zKyoto Explorer",
      url: "https://zkyoto.explorer.startale.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 196153
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/atletaOlympia.js
var atletaOlympia = defineChain({
  id: 2340,
  name: "Atleta Olympia",
  nativeCurrency: { decimals: 18, name: "Atla", symbol: "ATLA" },
  rpcUrls: {
    default: {
      http: [
        "https://testnet-rpc.atleta.network:9944",
        "https://testnet-rpc.atleta.network"
      ],
      ws: ["wss://testnet-rpc.atleta.network:9944"]
    }
  },
  blockExplorers: {
    default: {
      name: "Atleta Olympia Explorer",
      url: "https://blockscout.atleta.network",
      apiUrl: "https://blockscout.atleta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x1472ec6392180fb84F345d2455bCC75B26577115",
      blockCreated: 1076473
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/aurora.js
var aurora = defineChain({
  id: 1313161554,
  name: "Aurora",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.aurora.dev"] }
  },
  blockExplorers: {
    default: {
      name: "Aurorascan",
      url: "https://aurorascan.dev",
      apiUrl: "https://aurorascan.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 62907816
    }
  }
});

// node_modules/viem/_esm/chains/definitions/auroraTestnet.js
var auroraTestnet = defineChain({
  id: 1313161555,
  name: "Aurora Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://testnet.aurora.dev"] }
  },
  blockExplorers: {
    default: {
      name: "Aurorascan",
      url: "https://testnet.aurorascan.dev",
      apiUrl: "https://testnet.aurorascan.dev/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/auroria.js
var auroria = defineChain({
  id: 205205,
  name: "Auroria Testnet",
  network: "auroria",
  nativeCurrency: {
    name: "Auroria Stratis",
    symbol: "tSTRAX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://auroria.rpc.stratisevm.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Auroria Testnet Explorer",
      url: "https://auroria.explorer.stratisevm.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/avalanche.js
var avalanche = defineChain({
  id: 43114,
  name: "Avalanche",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://snowtrace.io",
      apiUrl: "https://api.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11907934
    }
  }
});

// node_modules/viem/_esm/chains/definitions/avalancheFuji.js
var avalancheFuji = defineChain({
  id: 43113,
  name: "Avalanche Fuji",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche Fuji",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://testnet.snowtrace.io",
      apiUrl: "https://api-testnet.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7096959
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/b3.js
var sourceId4 = 8453;
var b32 = defineChain({
  id: 8333,
  name: "B3",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.b3.fun/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.b3.fun"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  },
  sourceId: sourceId4
});

// node_modules/viem/_esm/chains/definitions/b3Sepolia.js
var sourceId5 = 168587773;
var b3Sepolia = defineChain({
  id: 1993,
  name: "B3 Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.b3.fun/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia.explorer.b3.fun"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  },
  testnet: true,
  sourceId: sourceId5
});

// node_modules/viem/_esm/chains/definitions/bahamut.js
var bahamut = defineChain({
  id: 5165,
  network: "bahamut",
  name: "Bahamut",
  nativeCurrency: { name: "Fasttoken", symbol: "FTN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc1.bahamut.io",
        "https://bahamut-rpc.publicnode.com",
        "https://rpc2.bahamut.io"
      ],
      webSocket: [
        "wss://ws1.sahara.bahamutchain.com",
        "wss://bahamut-rpc.publicnode.com",
        "wss://ws2.sahara.bahamutchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Ftnscan",
      url: "https://www.ftnscan.com",
      apiUrl: "https://www.ftnscan.com/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/base.js
var sourceId6 = 1;
var base3 = defineChain({
  ...chainConfig2,
  id: 8453,
  name: "Base",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://basescan.org",
      apiUrl: "https://api.basescan.org/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId6]: {
        address: "0x43edB88C4B80fDD2AdFF2412A7BebF9dF42cB40e"
      }
    },
    l2OutputOracle: {
      [sourceId6]: {
        address: "0x56315b90c40730925ec5485cf004d835058518A0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 5022
    },
    portal: {
      [sourceId6]: {
        address: "0x49048044D57e1C92A77f79988d21Fa8fAF74E97e",
        blockCreated: 17482143
      }
    },
    l1StandardBridge: {
      [sourceId6]: {
        address: "0x3154Cf16ccdb4C6d922629664174b904d80F2C35",
        blockCreated: 17482143
      }
    }
  },
  sourceId: sourceId6
});

// node_modules/viem/_esm/chains/definitions/basecampTestnet.js
var basecampTestnet = defineChain({
  id: 123420001114,
  name: "Basecamp Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Camp",
    symbol: "CAMP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.basecamp.t.raas.gelato.cloud"] }
  },
  blockExplorers: {
    default: {
      name: "basecamp",
      url: "https://basecamp.cloud.blockscout.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/baseGoerli.js
var sourceId7 = 5;
var baseGoerli = defineChain({
  ...chainConfig2,
  id: 84531,
  name: "Base Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://goerli.base.org"] }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://goerli.basescan.org",
      apiUrl: "https://goerli.basescan.org/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId7]: {
        address: "0x2A35891ff30313CcFa6CE88dcf3858bb075A2298"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1376988
    },
    portal: {
      [sourceId7]: {
        address: "0xe93c8cD0D409341205A592f8c4Ac1A5fe5585cfA"
      }
    },
    l1StandardBridge: {
      [sourceId7]: {
        address: "0xfA6D8Ee5BE770F84FC001D098C4bD604Fe01284a"
      }
    }
  },
  testnet: true,
  sourceId: sourceId7
});

// node_modules/viem/_esm/chains/definitions/baseSepolia.js
var sourceId8 = 11155111;
var baseSepolia = defineChain({
  ...chainConfig2,
  id: 84532,
  network: "base-sepolia",
  name: "Base Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://sepolia.basescan.org",
      apiUrl: "https://api-sepolia.basescan.org/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId8]: {
        address: "0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1"
      }
    },
    l2OutputOracle: {
      [sourceId8]: {
        address: "0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254"
      }
    },
    portal: {
      [sourceId8]: {
        address: "0x49f53e41452c74589e85ca1677426ba426459e85",
        blockCreated: 4446677
      }
    },
    l1StandardBridge: {
      [sourceId8]: {
        address: "0xfd0Bf71F60660E2f608ed56e1659C450eB113120",
        blockCreated: 4446677
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1059647
    }
  },
  testnet: true,
  sourceId: sourceId8
});

// node_modules/viem/_esm/chains/definitions/beam.js
var beam = defineChain({
  id: 4337,
  name: "Beam",
  network: "beam",
  nativeCurrency: {
    decimals: 18,
    name: "Beam",
    symbol: "BEAM"
  },
  rpcUrls: {
    default: {
      http: ["https://build.onbeam.com/rpc"],
      webSocket: ["wss://build.onbeam.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beam Explorer",
      url: "https://subnets.avax.network/beam"
    }
  },
  contracts: {
    multicall3: {
      address: "0x4956f15efdc3dc16645e90cc356eafa65ffc65ec",
      blockCreated: 1
    }
  }
});

// node_modules/viem/_esm/chains/definitions/beamTestnet.js
var beamTestnet = defineChain({
  id: 13337,
  name: "Beam Testnet",
  network: "beam",
  nativeCurrency: {
    decimals: 18,
    name: "Beam",
    symbol: "BEAM"
  },
  rpcUrls: {
    default: {
      http: ["https://build.onbeam.com/rpc/testnet"],
      webSocket: ["wss://build.onbeam.com/ws/testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beam Explorer",
      url: "https://subnets-test.avax.network/beam"
    }
  },
  contracts: {
    multicall3: {
      address: "0x9bf49b704ee2a095b95c1f2d4eb9010510c41c9e",
      blockCreated: 3
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bearNetworkChainMainnet.js
var bearNetworkChainMainnet = defineChain({
  id: 641230,
  name: "Bear Network Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BearNetworkChain",
    symbol: "BRNKC"
  },
  rpcUrls: {
    default: { http: ["https://brnkc-mainnet.bearnetwork.net"] }
  },
  blockExplorers: {
    default: {
      name: "BrnkScan",
      url: "https://brnkscan.bearnetwork.net",
      apiUrl: "https://brnkscan.bearnetwork.net/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bearNetworkChainTestnet.js
var bearNetworkChainTestnet = defineChain({
  id: 751230,
  name: "Bear Network Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tBRNKC",
    symbol: "tBRNKC"
  },
  rpcUrls: {
    default: { http: ["https://brnkc-test.bearnetwork.net"] }
  },
  blockExplorers: {
    default: {
      name: "BrnkTestScan",
      url: "https://brnktest-scan.bearnetwork.net",
      apiUrl: "https://brnktest-scan.bearnetwork.net/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/berachain.js
var berachain = defineChain({
  id: 80094,
  name: "Berachain",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    ensRegistry: {
      address: "0x5b22280886a2f5e09a49bea7e320eab0e5320e28",
      blockCreated: 877007
    },
    ensUniversalResolver: {
      address: "0xddfb18888a9466688235887dec2a10c4f5effee9",
      blockCreated: 877008
    }
  },
  rpcUrls: {
    default: { http: ["https://rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berascan",
      url: "https://berascan.com"
    }
  },
  ensTlds: [".bera"],
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/berachainBepolia.js
var berachainBepolia = defineChain({
  id: 80069,
  name: "Berachain Bepolia",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  rpcUrls: {
    default: { http: ["https://bepolia.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berascan",
      url: "https://bepolia.beratrail.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/berachainTestnet.js
var berachainTestnet = defineChain({
  id: 80085,
  name: "Berachain Artio",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  rpcUrls: {
    default: { http: ["https://artio.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berachain",
      url: "https://artio.beratrail.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 866924
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/berachainTestnetbArtio.js
var berachainTestnetbArtio = defineChain({
  id: 80084,
  name: "Berachain bArtio",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 109269
    },
    ensRegistry: {
      address: "0xB0eef18971290b333450586D33dcA6cE122651D2",
      blockCreated: 7736794
    },
    ensUniversalResolver: {
      address: "0x41692Ef1EA0C79E6b73077E4A67572D2BDbD7057",
      blockCreated: 7736795
    }
  },
  ensTlds: [".bera"],
  rpcUrls: {
    default: { http: ["https://bartio.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berachain bArtio Beratrail",
      url: "https://bartio.beratrail.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bevmMainnet.js
var bevmMainnet = defineChain({
  id: 11501,
  name: "BEVM Mainnet",
  nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet-1.bevm.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bevmscan",
      url: "https://scan-mainnet.bevm.io",
      apiUrl: "https://scan-mainnet-api.bevm.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bifrost.js
var bifrost = defineChain({
  id: 3068,
  name: "Bifrost Mainnet",
  nativeCurrency: { name: "BFC", symbol: "BFC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://public-01.mainnet.bifrostnetwork.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bifrost Blockscout",
      url: "https://explorer.mainnet.bifrostnetwork.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/bitgert.js
var bitgert = defineChain({
  id: 32520,
  name: "Bitgert Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Brise",
    symbol: "Brise"
  },
  rpcUrls: {
    default: { http: ["https://rpc-bitgert.icecreamswap.com"] }
  },
  blockExplorers: {
    default: {
      name: "Bitgert Scan",
      url: "https://brisescan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2118034
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/bitkub.js
var bitkub = defineChain({
  id: 96,
  name: "Bitkub",
  nativeCurrency: { name: "Bitkub", symbol: "KUB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitkubchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitkub Chain Mainnet Explorer",
      url: "https://www.bkcscan.com",
      apiUrl: "https://www.bkcscan.com/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bitkubTestnet.js
var bitkubTestnet = defineChain({
  id: 25925,
  name: "Bitkub Testnet",
  network: "Bitkub Testnet",
  nativeCurrency: { name: "Bitkub Test", symbol: "tKUB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.bitkubchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitkub Chain Testnet Explorer",
      url: "https://testnet.bkcscan.com",
      apiUrl: "https://testnet.bkcscan.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bitlayer.js
var bitlayer = defineChain({
  id: 200901,
  name: "Bitlayer Mainnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitlayer.org"],
      webSocket: ["wss://ws.bitlayer.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "bitlayer mainnet scan",
      url: "https://www.btrscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5B256fE9e993902eCe49D138a5b1162cBb529474",
      blockCreated: 2421963
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bitlayerTestnet.js
var bitlayerTestnet = defineChain({
  id: 200810,
  name: "Bitlayer Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bitlayer.org"],
      webSocket: ["wss://testnet-ws.bitlayer.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "bitlayer testnet scan",
      url: "https://testnet.btrscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5B256fE9e993902eCe49D138a5b1162cBb529474",
      blockCreated: 4135671
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bitrock.js
var bitrock = defineChain({
  id: 7171,
  name: "Bitrock Mainnet",
  nativeCurrency: { name: "BROCK", symbol: "BROCK", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://brockrpc.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitrock Explorer",
      url: "https://explorer.bit-rock.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/bitTorrent.js
var bitTorrent = defineChain({
  id: 199,
  name: "BitTorrent",
  network: "bittorrent-chain-mainnet",
  nativeCurrency: { name: "BitTorrent", symbol: "BTT", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.bittorrentchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bttcscan",
      url: "https://bttcscan.com",
      apiUrl: "https://api.bttcscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 31078552
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bitTorrentTestnet.js
var bitTorrentTestnet = defineChain({
  id: 1028,
  name: "BitTorrent Chain Testnet",
  network: "bittorrent-chain-testnet",
  nativeCurrency: { name: "BitTorrent", symbol: "BTT", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://testrpc.bittorrentchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bttcscan",
      url: "https://testnet.bttcscan.com",
      apiUrl: "https://testnet.bttcscan.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/birdlayer.js
var birdlayer = defineChain({
  id: 53456,
  name: "BirdLayer",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.birdlayer.xyz", "https://rpc1.birdlayer.xyz"],
      webSocket: ["wss://rpc.birdlayer.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "BirdLayer Explorer",
      url: "https://scan.birdlayer.xyz"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/blast.js
var sourceId9 = 1;
var blast = defineChain({
  ...chainConfig2,
  id: 81457,
  name: "Blast",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.blast.io"] }
  },
  blockExplorers: {
    default: {
      name: "Blastscan",
      url: "https://blastscan.io",
      apiUrl: "https://api.blastscan.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 212929
    }
  },
  sourceId: sourceId9
});

// node_modules/viem/_esm/chains/definitions/blastSepolia.js
var sourceId10 = 11155111;
var blastSepolia = defineChain({
  id: 168587773,
  name: "Blast Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.blast.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blastscan",
      url: "https://sepolia.blastscan.io",
      apiUrl: "https://api-sepolia.blastscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 756690
    }
  },
  testnet: true,
  sourceId: sourceId10
});

// node_modules/viem/_esm/chains/definitions/bob.js
var sourceId11 = 1;
var bob = defineChain({
  ...chainConfig2,
  id: 60808,
  name: "BOB",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.gobob.xyz"],
      webSocket: ["wss://rpc.gobob.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "BOB Explorer",
      url: "https://explorer.gobob.xyz"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 23131
    },
    l2OutputOracle: {
      [sourceId11]: {
        address: "0xdDa53E23f8a32640b04D7256e651C1db98dB11C1",
        blockCreated: 4462615
      }
    },
    portal: {
      [sourceId11]: {
        address: "0x8AdeE124447435fE03e3CD24dF3f4cAE32E65a3E",
        blockCreated: 4462615
      }
    }
  },
  sourceId: sourceId11
});

// node_modules/viem/_esm/chains/definitions/boba.js
var boba = defineChain({
  id: 288,
  name: "Boba Network",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.boba.network"] }
  },
  blockExplorers: {
    default: {
      name: "BOBAScan",
      url: "https://bobascan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 446859
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bobaSepolia.js
var bobaSepolia = defineChain({
  id: 28882,
  name: "Boba Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://sepolia.boba.network"] }
  },
  blockExplorers: {
    default: {
      name: "BOBAScan",
      url: "https://testnet.bobascan.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bobSepolia.js
var sourceId12 = 11155111;
var bobSepolia = defineChain({
  ...chainConfig2,
  id: 808813,
  name: "BOB Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://bob-sepolia.rpc.gobob.xyz"],
      webSocket: ["wss://bob-sepolia.rpc.gobob.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "BOB Sepolia Explorer",
      url: "https://bob-sepolia.explorer.gobob.xyz"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 35677
    },
    l2OutputOracle: {
      [sourceId12]: {
        address: "0x14D0069452b4AE2b250B395b8adAb771E4267d2f",
        blockCreated: 4462615
      }
    },
    portal: {
      [sourceId12]: {
        address: "0x867B1Aa872b9C8cB5E9F7755feDC45BB24Ad0ae4",
        blockCreated: 4462615
      }
    }
  },
  testnet: true,
  sourceId: sourceId12
});

// node_modules/viem/_esm/chains/definitions/boolBetaMainnet.js
var boolBetaMainnet = defineChain({
  id: 11100,
  name: "Bool Beta Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BOL",
    symbol: "BOL"
  },
  rpcUrls: {
    default: { http: ["https://beta-rpc-node-http.bool.network"] }
  },
  blockExplorers: {
    default: {
      name: "BoolScan",
      url: "https://beta-mainnet.boolscan.com/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/botanixTestnet.js
var botanixTestnet = defineChain({
  id: 3636,
  name: "Botanix Testnet",
  nativeCurrency: { name: "Botanix", symbol: "BTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://node.botanixlabs.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Botanix Testnet Explorer",
      url: "https://testnet.botanixscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bounceBit.js
var bounceBit = defineChain({
  id: 6001,
  name: "BounceBit Mainnet",
  nativeCurrency: { name: "BounceBit", symbol: "BB", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://fullnode-mainnet.bouncebitapi.com"] }
  },
  blockExplorers: {
    default: {
      name: "BB Scan",
      url: "https://bbscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/bounceBitTestnet.js
var bounceBitTestnet = defineChain({
  id: 6e3,
  name: "BounceBit Testnet",
  nativeCurrency: { name: "BounceBit", symbol: "BB", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://fullnode-testnet.bouncebitapi.com"] }
  },
  blockExplorers: {
    default: {
      name: "BB Scan",
      url: "https://testnet.bbscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bronos.js
var bronos = defineChain({
  id: 1039,
  name: "Bronos",
  nativeCurrency: {
    decimals: 18,
    name: "BRO",
    symbol: "BRO"
  },
  rpcUrls: {
    default: { http: ["https://evm.bronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "BronoScan",
      url: "https://broscan.bronos.org"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bronosTestnet.js
var bronosTestnet = defineChain({
  id: 1038,
  name: "Bronos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Bronos Coin",
    symbol: "tBRO"
  },
  rpcUrls: {
    default: { http: ["https://evm-testnet.bronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "BronoScan",
      url: "https://tbroscan.bronos.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bsc.js
var bsc = defineChain({
  id: 56,
  name: "BNB Smart Chain",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://56.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://bscscan.com",
      apiUrl: "https://api.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15921452
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bscGreenfield.js
var bscGreenfield = defineChain({
  id: 1017,
  name: "BNB Greenfield Chain",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://greenfield-chain.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "BNB Greenfield Mainnet Scan",
      url: "https://greenfieldscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/bscTestnet.js
var bscTestnet = defineChain({
  id: 97,
  name: "Binance Smart Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "tBNB"
  },
  rpcUrls: {
    default: { http: ["https://data-seed-prebsc-1-s1.bnbchain.org:8545"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://testnet.bscscan.com",
      apiUrl: "https://api-testnet.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 17422483
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bsquared.js
var bsquared = defineChain({
  id: 223,
  name: "B2",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bsquared.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.bsquared.network"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bsquaredTestnet.js
var bsquaredTestnet = defineChain({
  id: 1123,
  name: "B2 Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bsquared.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet-explorer.bsquared.network"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/btr.js
var btr = defineChain({
  id: 200901,
  name: "Bitlayer",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitlayer.org", "https://rpc.bitlayer-rpc.com"],
      webSocket: ["wss://ws.bitlayer.org", "wss://ws.bitlayer-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitlayer(BTR) Scan",
      url: "https://www.btrscan.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/btrTestnet.js
var btrTestnet = defineChain({
  id: 200810,
  name: "Bitlayer Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bitlayer.org"],
      webSocket: [
        "wss://testnet-ws.bitlayer.org",
        "wss://testnet-ws.bitlayer-rpc.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitlayer(BTR) Scan",
      url: "https://testnet.btrscan.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bxn.js
var bxn = defineChain({
  id: 4999,
  name: "BlackFort Exchange Network",
  nativeCurrency: { name: "BlackFort Token", symbol: "BXN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.blackfort.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.blackfort.network",
      apiUrl: "https://explorer.blackfort.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bxnTestnet.js
var bxnTestnet = defineChain({
  id: 4777,
  name: "BlackFort Exchange Network Testnet",
  nativeCurrency: {
    name: "BlackFort Testnet Token",
    symbol: "TBXN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.blackfort.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.blackfort.network",
      apiUrl: "https://testnet-explorer.blackfort.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/cannon.js
var cannon = defineChain({
  id: 13370,
  name: "Cannon",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
});

// node_modules/viem/_esm/chains/definitions/canto.js
var canto = defineChain({
  id: 7700,
  name: "Canto",
  nativeCurrency: {
    decimals: 18,
    name: "Canto",
    symbol: "CANTO"
  },
  rpcUrls: {
    default: { http: ["https://canto.gravitychain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Tuber.Build (Blockscout)",
      url: "https://tuber.build"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2905789
    }
  }
});

// node_modules/viem/_esm/celo/fees.js
var fees = {
  /*
     * Estimates the fees per gas for a transaction.
  
     * If the transaction is to be paid in a token (feeCurrency is present) then the fees
     * are estimated in the value of the token. Otherwise falls back to the default
     * estimation by returning null.
     *
     * @param params fee estimation function parameters
     */
  estimateFeesPerGas: async (params) => {
    var _a2;
    if (!((_a2 = params.request) == null ? void 0 : _a2.feeCurrency))
      return null;
    const [gasPrice, maxPriorityFeePerGas] = await Promise.all([
      estimateFeePerGasInFeeCurrency(params.client, params.request.feeCurrency),
      estimateMaxPriorityFeePerGasInFeeCurrency(params.client, params.request.feeCurrency)
    ]);
    const maxFeePerGas = params.multiply(gasPrice - maxPriorityFeePerGas) + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
};
async function estimateFeePerGasInFeeCurrency(client, feeCurrency) {
  const fee = await client.request({
    method: "eth_gasPrice",
    params: [feeCurrency]
  });
  return BigInt(fee);
}
async function estimateMaxPriorityFeePerGasInFeeCurrency(client, feeCurrency) {
  const feesPerGas = await client.request({
    method: "eth_maxPriorityFeePerGas",
    params: [feeCurrency]
  });
  return BigInt(feesPerGas);
}

// node_modules/viem/_esm/celo/utils.js
function isEmpty(value) {
  return value === 0 || value === 0n || value === void 0 || value === null || value === "0" || value === "" || typeof value === "string" && (trim(value).toLowerCase() === "0x" || trim(value).toLowerCase() === "0x00");
}
function isPresent(value) {
  return !isEmpty(value);
}
function isEIP1559(transaction) {
  return typeof transaction.maxFeePerGas !== "undefined" && typeof transaction.maxPriorityFeePerGas !== "undefined";
}
function isCIP64(transaction) {
  if (transaction.type === "cip64") {
    return true;
  }
  return isEIP1559(transaction) && isPresent(transaction.feeCurrency);
}

// node_modules/viem/_esm/celo/formatters.js
var formatters3 = {
  block: defineBlock({
    format(args) {
      var _a2;
      const transactions = (_a2 = args.transactions) == null ? void 0 : _a2.map((transaction) => {
        if (typeof transaction === "string")
          return transaction;
        const formatted = formatTransaction(transaction);
        return {
          ...formatted,
          ...transaction.gatewayFee ? {
            gatewayFee: hexToBigInt2(transaction.gatewayFee),
            gatewayFeeRecipient: transaction.gatewayFeeRecipient
          } : {},
          feeCurrency: transaction.feeCurrency
        };
      });
      return {
        transactions
      };
    }
  }),
  transaction: defineTransaction({
    format(args) {
      if (args.type === "0x7e")
        return {
          isSystemTx: args.isSystemTx,
          mint: args.mint ? hexToBigInt2(args.mint) : void 0,
          sourceHash: args.sourceHash,
          type: "deposit"
        };
      const transaction = { feeCurrency: args.feeCurrency };
      if (args.type === "0x7b")
        transaction.type = "cip64";
      else {
        if (args.type === "0x7c")
          transaction.type = "cip42";
        transaction.gatewayFee = args.gatewayFee ? hexToBigInt2(args.gatewayFee) : null;
        transaction.gatewayFeeRecipient = args.gatewayFeeRecipient;
      }
      return transaction;
    }
  }),
  transactionRequest: defineTransactionRequest({
    format(args) {
      const request = {};
      if (args.feeCurrency)
        request.feeCurrency = args.feeCurrency;
      if (isCIP64(args))
        request.type = "0x7b";
      return request;
    }
  })
};

// node_modules/viem/_esm/celo/serializers.js
function serializeTransaction6(transaction, signature) {
  if (isCIP64(transaction))
    return serializeTransactionCIP64(transaction, signature);
  return serializeTransaction5(transaction, signature);
}
var serializers3 = {
  transaction: serializeTransaction6
};
function serializeTransactionCIP64(transaction, signature) {
  assertTransactionCIP64(transaction);
  const { chainId, gas, nonce, to: to4, value, maxFeePerGas, maxPriorityFeePerGas, accessList, feeCurrency, data } = transaction;
  const serializedTransaction = [
    toHex2(chainId),
    nonce ? toHex2(nonce) : "0x",
    maxPriorityFeePerGas ? toHex2(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex2(maxFeePerGas) : "0x",
    gas ? toHex2(gas) : "0x",
    to4 ?? "0x",
    value ? toHex2(value) : "0x",
    data ?? "0x",
    serializeAccessList(accessList),
    feeCurrency,
    ...toYParitySignatureArray(transaction, signature)
  ];
  return concatHex([
    "0x7b",
    toRlp(serializedTransaction)
  ]);
}
var MAX_MAX_FEE_PER_GAS = maxUint256;
function assertTransactionCIP64(transaction) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to: to4, feeCurrency } = transaction;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to4 && !isAddress(to4))
    throw new InvalidAddressError({ address: to4 });
  if (gasPrice)
    throw new BaseError("`gasPrice` is not a valid CIP-64 Transaction attribute.");
  if (isPresent(maxFeePerGas) && maxFeePerGas > MAX_MAX_FEE_PER_GAS)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (isPresent(maxPriorityFeePerGas) && isPresent(maxFeePerGas) && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
  if (isPresent(feeCurrency) && !isAddress(feeCurrency)) {
    throw new BaseError("`feeCurrency` MUST be a token address for CIP-64 transactions.");
  }
  if (isEmpty(feeCurrency)) {
    throw new BaseError("`feeCurrency` must be provided for CIP-64 transactions.");
  }
}

// node_modules/viem/_esm/celo/chainConfig.js
var chainConfig3 = {
  contracts,
  formatters: formatters3,
  serializers: serializers3,
  fees
};

// node_modules/viem/_esm/chains/definitions/celo.js
var celo = defineChain({
  ...chainConfig3,
  id: 42220,
  name: "Celo",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "CELO"
  },
  rpcUrls: {
    default: { http: ["https://forno.celo.org"] }
  },
  blockExplorers: {
    default: {
      name: "Celo Explorer",
      url: "https://celoscan.io",
      apiUrl: "https://api.celoscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 13112599
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/celoAlfajores.js
var sourceId13 = 17e3;
var celoAlfajores = defineChain({
  ...chainConfig3,
  id: 44787,
  name: "Alfajores",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "A-CELO"
  },
  rpcUrls: {
    default: {
      http: ["https://alfajores-forno.celo-testnet.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Celo Alfajores Explorer",
      url: "https://celo-alfajores.blockscout.com",
      apiUrl: "https://celo-alfajores.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig3.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 14569001
    },
    portal: {
      [sourceId13]: {
        address: "0x82527353927d8D069b3B452904c942dA149BA381",
        blockCreated: 2411324
      }
    },
    disputeGameFactory: {
      [sourceId13]: {
        address: "0xE28AAdcd9883746c0e5068F58f9ea06027b214cb",
        blockCreated: 2411324
      }
    },
    l2OutputOracle: {
      [sourceId13]: {
        address: "0x4a2635e9e4f6e45817b1D402ac4904c1d1752438",
        blockCreated: 2411324
      }
    },
    l1StandardBridge: {
      [sourceId13]: {
        address: "0xD1B0E0581973c9eB7f886967A606b9441A897037",
        blockCreated: 2411324
      }
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/chang.js
var chang = defineChain({
  id: 5858,
  name: "Chang Chain Foundation Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "CTH",
    symbol: "CTH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.cthscan.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chang Chain explorer",
      url: "https://cthscan.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/chiliz.js
var chiliz = defineChain({
  id: 88888,
  name: "Chiliz Chain",
  network: "chiliz-chain",
  nativeCurrency: {
    decimals: 18,
    name: "CHZ",
    symbol: "CHZ"
  },
  rpcUrls: {
    default: {
      http: ["https://chiliz-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chiliz Explorer",
      url: "https://scan.chiliz.com",
      apiUrl: "https://scan.chiliz.com/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/chips.js
var chips = defineChain({
  id: 2882,
  name: "Chips Network",
  network: "CHIPS",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: [
        "https://node.chips.ooo/wasp/api/v1/chains/iota1pp3d3mnap3ufmgqnjsnw344sqmf5svjh26y2khnmc89sv6788y3r207a8fn/evm"
      ]
    }
  }
});

// node_modules/viem/_esm/chains/definitions/citreaTestnet.js
var citreaTestnet = defineChain({
  id: 5115,
  name: "Citrea Testnet",
  nativeCurrency: { name: "cBTC", symbol: "cBTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.citrea.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Citrea Explorer",
      url: "https://explorer.testnet.citrea.xyz",
      apiUrl: "https://explorer.testnet.citrea.xyz/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/classic.js
var classic = defineChain({
  id: 61,
  name: "Ethereum Classic",
  nativeCurrency: {
    decimals: 18,
    name: "ETC",
    symbol: "ETC"
  },
  rpcUrls: {
    default: { http: ["https://etc.rivet.link"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.com/etc/mainnet"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/coinbit.js
var coinbit = defineChain({
  id: 112,
  name: "Coinbit Mainnet",
  nativeCurrency: { name: "GIDR", symbol: "GIDR", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://coinbit-rpc-mainnet.chain.sbcrypto.app"]
    }
  },
  blockExplorers: {
    default: {
      name: "Coinbit Explorer",
      url: "https://coinbit-explorer.chain.sbcrypto.app"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/coinex.js
var coinex = defineChain({
  id: 52,
  name: "CoinEx Mainnet",
  nativeCurrency: { name: "cet", symbol: "cet", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.coinex.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "CoinEx Explorer",
      url: "https://www.coinex.net"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/confluxESpace.js
var confluxESpace = defineChain({
  id: 1030,
  name: "Conflux eSpace",
  nativeCurrency: { name: "Conflux", symbol: "CFX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm.confluxrpc.com"],
      webSocket: ["wss://evm.confluxrpc.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "ConfluxScan",
      url: "https://evm.confluxscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
      blockCreated: 68602935
    }
  }
});

// node_modules/viem/_esm/chains/definitions/confluxESpaceTestnet.js
var confluxESpaceTestnet = defineChain({
  id: 71,
  name: "Conflux eSpace Testnet",
  network: "cfx-espace-testnet",
  testnet: true,
  nativeCurrency: { name: "Conflux", symbol: "CFX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmtestnet.confluxrpc.com"],
      webSocket: ["wss://evmtestnet.confluxrpc.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "ConfluxScan",
      url: "https://evmtestnet.confluxscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
      blockCreated: 117499050
    }
  }
});

// node_modules/viem/_esm/chains/definitions/coreDao.js
var coreDao = defineChain({
  id: 1116,
  name: "Core Dao",
  nativeCurrency: {
    decimals: 18,
    name: "Core",
    symbol: "CORE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.coredao.org"] }
  },
  blockExplorers: {
    default: {
      name: "CoreDao",
      url: "https://scan.coredao.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 11907934
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/coreTestnet1.js
var coreTestnet1 = defineChain({
  id: 1115,
  name: "Core Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tCore",
    symbol: "TCORE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.test.btcs.network"] }
  },
  blockExplorers: {
    default: {
      name: "Core Testnet",
      url: "https://scan.test.btcs.network",
      apiUrl: "https://api.test.btcs.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xCcddF20A1932537123C2E48Bd8e00b108B8f7569",
      blockCreated: 29350509
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/coreTestnet2.js
var coreTestnet2 = defineChain({
  id: 1114,
  name: "Core Testnet2",
  nativeCurrency: {
    decimals: 18,
    name: "tCore2",
    symbol: "TCORE2"
  },
  rpcUrls: {
    default: { http: ["https://rpc.test2.btcs.network"] }
  },
  blockExplorers: {
    default: {
      name: "Core Testnet2",
      url: "https://scan.test2.btcs.network",
      apiUrl: "https://api.test2.btcs.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x3CB285ff3Cd5C7C7e570b1E7DE3De17A0f985e56",
      blockCreated: 3838600
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/corn.js
var sourceId14 = 1;
var corn = defineChain({
  id: 21e6,
  name: "Corn",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcorn",
    symbol: "BTCN"
  },
  rpcUrls: {
    default: { http: ["https://21000000.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Corn Explorer",
      url: "https://cornscan.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/21000000/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3228
    }
  },
  sourceId: sourceId14
});

// node_modules/viem/_esm/chains/definitions/cornTestnet.js
var sourceId15 = 11155111;
var cornTestnet = defineChain({
  id: 21000001,
  name: "Corn Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcorn",
    symbol: "BTCN"
  },
  rpcUrls: {
    default: { http: ["https://21000001.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Corn Testnet Explorer",
      url: "https://testnet.cornscan.io",
      apiUrl: "https://api.routescan.io/v2/network/testnet/evm/21000001/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4886
    }
  },
  testnet: true,
  sourceId: sourceId15
});

// node_modules/viem/_esm/chains/definitions/crab.js
var crab = defineChain({
  id: 44,
  name: "Crab Network",
  nativeCurrency: {
    decimals: 18,
    name: "Crab Network Native Token",
    symbol: "CRAB"
  },
  rpcUrls: {
    default: {
      http: ["https://crab-rpc.darwinia.network"],
      webSocket: ["wss://crab-rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Blockscout", url: "https://crab-scan.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3032593
    }
  }
});

// node_modules/viem/_esm/chains/definitions/creatorTestnet.js
var creatorTestnet = defineChain({
  id: 66665,
  name: "Creator",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.creatorchain.io"]
    }
  },
  blockExplorers: {
    default: { name: "Explorer", url: "https://explorer.creatorchain.io" }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/creditCoin3Mainnet.js
var creditCoin3Mainnet = defineChain({
  id: 102030,
  name: "Creditcoin3 Mainnet",
  nativeCurrency: { name: "Creditcoin3 Mainnet", symbol: "CTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet3.creditcoin.network"],
      webSocket: ["wss://mainnet3.creditcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://creditcoin.blockscout.com",
      apiUrl: "https://creditcoin.blockscout.com/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/creditCoin3Testnet.js
var creditCoin3Testnet = defineChain({
  id: 102031,
  name: "Creditcoin3 Testnet",
  nativeCurrency: { name: "Creditcoin3 Testnet", symbol: "TCTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.cc3-testnet.creditcoin.network"],
      webSocket: ["wss://rpc.cc3-testnet.creditcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://creditcoin-testnet.blockscout.com",
      apiUrl: "https://creditcoin-testnet.blockscout.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/cronos.js
var cronos = defineChain({
  id: 25,
  name: "Cronos Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos",
    symbol: "CRO"
  },
  rpcUrls: {
    default: { http: ["https://evm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos Explorer",
      url: "https://explorer.cronos.org",
      apiUrl: "https://explorer-api.cronos.org/mainnet/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1963112
    }
  }
});

// node_modules/viem/_esm/chains/definitions/cronosTestnet.js
var cronosTestnet = defineChain({
  id: 338,
  name: "Cronos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "CRO",
    symbol: "tCRO"
  },
  rpcUrls: {
    default: { http: ["https://evm-t3.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos Explorer",
      url: "https://cronos.org/explorer/testnet3"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 10191251
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/cronoszkEVM.js
var cronoszkEVM = defineChain({
  id: 388,
  name: "Cronos zkEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos zkEVM CRO",
    symbol: "zkCRO"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.zkevm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos zkEVM (Mainnet) Chain Explorer",
      url: "https://explorer.zkevm.cronos.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0x06f4487d7c4a5983d2660db965cc6d2565e4cfaa",
      blockCreated: 72
    }
  }
});

// node_modules/viem/_esm/chains/definitions/cronoszkEVMTestnet.js
var cronoszkEVMTestnet = defineChain({
  id: 282,
  name: "Cronos zkEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos zkEVM Test Coin",
    symbol: "zkTCRO"
  },
  rpcUrls: {
    default: { http: ["https://testnet.zkevm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos zkEVM Testnet Explorer",
      url: "https://explorer.zkevm.cronos.org/testnet"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/crossbell.js
var crossbell = defineChain({
  id: 3737,
  name: "Crossbell",
  nativeCurrency: {
    decimals: 18,
    name: "CSB",
    symbol: "CSB"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.crossbell.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "CrossScan",
      url: "https://scan.crossbell.io",
      apiUrl: "https://scan.crossbell.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 38246031
    }
  }
});

// node_modules/viem/_esm/chains/definitions/curtis.js
var curtis = defineChain({
  id: 33111,
  name: "Curtis",
  nativeCurrency: { name: "ApeCoin", symbol: "APE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.curtis.apechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Curtis Explorer",
      url: "https://explorer.curtis.apechain.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/cyber.js
var cyber = defineChain({
  id: 7560,
  name: "Cyber",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cyber.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://cyberscan.co",
      apiUrl: "https://cyberscan.co/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/cyberTestnet.js
var cyberTestnet = defineChain({
  id: 111557560,
  name: "Cyber Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cyber-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet.cyberscan.co",
      apiUrl: "https://testnet.cyberscan.co/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xffc391F0018269d4758AEA1a144772E8FB99545E",
      blockCreated: 304545
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/dailyNetwork.js
var dailyNetwork = defineChain({
  id: 824,
  name: "Daily Network Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Daily",
    symbol: "DLY"
  },
  rpcUrls: {
    default: { http: ["https://rpc.mainnet.dailycrypto.net"] }
  },
  blockExplorers: {
    default: {
      name: "Daily Mainnet Explorer",
      url: "https://explorer.mainnet.dailycrypto.net"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/dailyNetworkTestnet.js
var dailyNetworkTestnet = defineChain({
  id: 825,
  name: "Daily Network Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Daily",
    symbol: "DLY"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.dailycrypto.net"] }
  },
  blockExplorers: {
    default: {
      name: "Daily Testnet Explorer",
      url: "https://explorer.testnet.dailycrypto.net"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/darwinia.js
var darwinia = defineChain({
  id: 46,
  name: "Darwinia Network",
  nativeCurrency: {
    decimals: 18,
    name: "RING",
    symbol: "RING"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.darwinia.network"],
      webSocket: ["wss://rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Explorer", url: "https://explorer.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 69420
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dbkchain.js
var dbkchain = defineChain({
  id: 20240603,
  name: "DBK chain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.dbkchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "DBK Chain Explorer",
      url: "https://scan.dbkchain.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/dchain.js
var dchain = defineChain({
  ...chainConfig2,
  id: 2716446429837e3,
  name: "Dchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dchain-2716446429837000-1.jsonrpc.sagarpc.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Dchain Explorer",
      url: "https://dchain-2716446429837000-1.sagaexplorer.io",
      apiUrl: "https://api-dchain-2716446429837000-1.sagaexplorer.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts
  }
});

// node_modules/viem/_esm/chains/definitions/dchainTestnet.js
var dchainTestnet = defineChain({
  ...chainConfig2,
  id: 2713017997578e3,
  name: "Dchain Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://dchaintestnet-2713017997578000-1.jsonrpc.testnet.sagarpc.io"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Dchain Explorer",
      url: "https://dchaintestnet-2713017997578000-1.testnet.sagaexplorer.io",
      apiUrl: "https://api-dchaintestnet-2713017997578000-1.testnet.sagaexplorer.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts
  }
});

// node_modules/viem/_esm/chains/definitions/defichainEvm.js
var defichainEvm = defineChain({
  id: 1130,
  network: "defichain-evm",
  name: "DeFiChain EVM Mainnet",
  nativeCurrency: {
    name: "DeFiChain",
    symbol: "DFI",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth.mainnet.ocean.jellyfishsdk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DeFiScan",
      url: "https://meta.defiscan.live"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 137852
    }
  }
});

// node_modules/viem/_esm/chains/definitions/defichainEvmTestnet.js
var defichainEvmTestnet = defineChain({
  id: 1131,
  network: "defichain-evm-testnet",
  name: "DeFiChain EVM Testnet",
  nativeCurrency: {
    name: "DeFiChain",
    symbol: "DFI",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth.testnet.ocean.jellyfishsdk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DeFiScan",
      url: "https://meta.defiscan.live/?network=TestNet"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 156462
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/degen.js
var degen = defineChain({
  id: 666666666,
  name: "Degen",
  nativeCurrency: {
    decimals: 18,
    name: "Degen",
    symbol: "DEGEN"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.degen.tips"],
      webSocket: ["wss://rpc.degen.tips"]
    }
  },
  blockExplorers: {
    default: {
      name: "Degen Chain Explorer",
      url: "https://explorer.degen.tips",
      apiUrl: "https://explorer.degen.tips/api/v2"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dfk.js
var dfk = defineChain({
  id: 53935,
  name: "DFK Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Jewel",
    symbol: "JEWEL"
  },
  rpcUrls: {
    default: {
      http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "DFKSubnetScan",
      url: "https://subnets.avax.network/defi-kingdoms"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14790551
    }
  }
});

// node_modules/viem/_esm/chains/definitions/diode.js
var diode = defineChain({
  id: 15,
  name: "Diode Prenet",
  nativeCurrency: {
    decimals: 18,
    name: "DIODE",
    symbol: "DIODE"
  },
  rpcUrls: {
    default: {
      http: ["https://prenet.diode.io:8443"],
      webSocket: ["wss://prenet.diode.io:8443/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Diode Explorer",
      url: "https://diode.io/prenet"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/disChain.js
var disChain = defineChain({
  id: 513100,
  name: "DisChain",
  nativeCurrency: {
    decimals: 18,
    name: "DIS",
    symbol: "DIS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dischain.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "DisChain Explorer",
      url: "https://www.oklink.com/dis"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dodochainTestnet.js
var dodochainTestnet = defineChain({
  id: 53457,
  name: "DODOchain Testnet",
  nativeCurrency: { decimals: 18, name: "DODO", symbol: "DODO" },
  rpcUrls: {
    default: {
      http: ["https://dodochain-testnet.alt.technology"],
      webSocket: ["wss://dodochain-testnet.alt.technology/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "DODOchain Testnet (Sepolia) Explorer",
      url: "https://testnet-scan.dodochain.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/dogechain.js
var dogechain = defineChain({
  id: 2e3,
  name: "Dogechain",
  nativeCurrency: {
    decimals: 18,
    name: "Wrapped Dogecoin",
    symbol: "WDOGE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.dogechain.dog"] }
  },
  blockExplorers: {
    default: {
      name: "DogeChainExplorer",
      url: "https://explorer.dogechain.dog",
      apiUrl: "https://explorer.dogechain.dog/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x68a8609a60a008EFA633dfdec592c03B030cC508",
      blockCreated: 25384031
    }
  }
});

// node_modules/viem/_esm/chains/definitions/donatuz.js
var donatuz = defineChain({
  id: 42026,
  name: "Donatuz",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.donatuz.com"] }
  },
  blockExplorers: {
    default: {
      name: "Donatuz Explorer",
      url: "https://explorer.donatuz.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dosChain.js
var dosChain = defineChain({
  id: 7979,
  name: "DOS Chain",
  nativeCurrency: {
    decimals: 18,
    name: "DOS Chain",
    symbol: "DOS"
  },
  rpcUrls: {
    default: { http: ["https://main.doschain.com"] }
  },
  blockExplorers: {
    default: {
      name: "DOS Chain Explorer",
      url: "https://doscan.io",
      apiUrl: "https://api.doscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 161908
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dosChainTestnet.js
var dosChainTestnet = defineChain({
  id: 3939,
  name: "DOS Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "DOS Chain Testnet",
    symbol: "DOS"
  },
  rpcUrls: {
    default: { http: ["https://test.doschain.com"] }
  },
  blockExplorers: {
    default: {
      name: "DOS Chain Testnet Explorer",
      url: "https://test.doscan.io",
      apiUrl: "https://api-test.doscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 69623
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/dreyerxMainnet.js
var dreyerxMainnet = defineChain({
  id: 23451,
  name: "DreyerX Mainnet",
  nativeCurrency: {
    name: "DreyerX",
    symbol: "DRX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dreyerx.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DreyerX Scan",
      url: "https://scan.dreyerx.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dreyerxTestnet.js
var dreyerxTestnet = defineChain({
  id: 23452,
  name: "DreyerX Testnet",
  nativeCurrency: {
    name: "DreyerX",
    symbol: "DRX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["http://testnet-rpc.dreyerx.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DreyerX Testnet Scan",
      url: "https://testnet-scan.dreyerx.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/dustboyIoT.js
var dustboyIoT = defineChain({
  id: 555888,
  name: "DustBoy IoT",
  nativeCurrency: { name: "Ether", symbol: "DST", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dustboy-rpc.jibl2.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://dustboy.jibl2.com",
      apiUrl: "https://dustboy.jibl2.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xFFD34aa2C62B2D52E00A361e466C229788f4eD6a",
      blockCreated: 526569
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/dymension.js
var dymension = defineChain({
  id: 1100,
  name: "Dymension",
  nativeCurrency: {
    name: "DYM",
    symbol: "DYM",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://dymension-evm-rpc.publicnode.com"],
      webSocket: ["wss://dymension-evm-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Dym FYI",
      url: "https://dym.fyi"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/edexaTestnet.js
var edexaTestnet = defineChain({
  id: 1995,
  name: "edeXa Testnet",
  nativeCurrency: { name: "edeXa", symbol: "tEDX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.edexa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "edeXa Testnet Explorer",
      url: "https://explorer.testnet.edexa.network",
      apiUrl: "https://explorer.testnet.edexa.network/api/v2"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/edexa.js
var edexa = defineChain({
  id: 5424,
  name: "edeXa",
  nativeCurrency: { name: "edeXa", symbol: "EDX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.edexa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "edeXa Explorer",
      url: "https://explorer.edexa.network",
      apiUrl: "https://explorer.edexa.network/api/v2"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/edgeless.js
var edgeless = defineChain({
  id: 2026,
  name: "Edgeless Network",
  nativeCurrency: {
    name: "Edgeless Wrapped ETH",
    symbol: "EwETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.edgeless.network/http"],
      webSocket: ["wss://rpc.edgeless.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Edgeless Explorer",
      url: "https://explorer.edgeless.network"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/edgelessTestnet.js
var edgelessTestnet = defineChain({
  id: 202,
  name: "Edgeless Testnet",
  nativeCurrency: {
    name: "Edgeless Wrapped ETH",
    symbol: "EwETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://edgeless-testnet.rpc.caldera.xyz/http"],
      webSocket: ["wss://edgeless-testnet.rpc.caldera.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Edgeless Testnet Explorer",
      url: "https://testnet.explorer.edgeless.network"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/edgeware.js
var edgeware = defineChain({
  id: 2021,
  name: "Edgeware EdgeEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Edgeware",
    symbol: "EDG"
  },
  rpcUrls: {
    default: { http: ["https://edgeware-evm.jelliedowl.net"] }
  },
  blockExplorers: {
    default: {
      name: "Edgscan by Bharathcoorg",
      url: "https://edgscan.live",
      apiUrl: "https://edgscan.live/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 18117872
    }
  }
});

// node_modules/viem/_esm/chains/definitions/edgewareTestnet.js
var edgewareTestnet = defineChain({
  id: 2022,
  name: "Beresheet BereEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Testnet EDG",
    symbol: "tEDG"
  },
  rpcUrls: {
    default: { http: ["https://beresheet-evm.jelliedowl.net"] }
  },
  blockExplorers: {
    default: {
      name: "Edgscan by Bharathcoorg",
      url: "https://testnet.edgscan.live",
      apiUrl: "https://testnet.edgscan.live/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/eduChain.js
var eduChain = defineChain({
  id: 41923,
  name: "EDU Chain",
  nativeCurrency: {
    decimals: 18,
    name: "EDU",
    symbol: "EDU"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.edu-chain.raas.gelato.cloud"]
    }
  },
  blockExplorers: {
    default: {
      name: "EDU Chain Explorer",
      url: "https://educhain.blockscout.com/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/eduChainTestnet.js
var eduChainTestnet = defineChain({
  id: 656476,
  name: "EDU Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EDU",
    symbol: "EDU"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.open-campus-codex.gelato.digital/"],
      webSocket: ["wss://ws.open-campus-codex.gelato.digital"]
    }
  },
  blockExplorers: {
    default: {
      name: "EDU Chain Testnet Explorer",
      url: "https://opencampus-codex.blockscout.com",
      apiUrl: "https://opencampus-codex.blockscout.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 15514133
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ekta.js
var ekta = defineChain({
  id: 1994,
  name: "Ekta",
  nativeCurrency: {
    decimals: 18,
    name: "EKTA",
    symbol: "EKTA"
  },
  rpcUrls: {
    default: { http: ["https://main.ekta.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ektascan",
      url: "https://ektascan.io",
      apiUrl: "https://ektascan.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/ektaTestnet.js
var ektaTestnet = defineChain({
  id: 1004,
  name: "Ekta Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EKTA",
    symbol: "EKTA"
  },
  rpcUrls: {
    default: { http: ["https://test.ekta.io:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Test Ektascan",
      url: "https://test.ektascan.io",
      apiUrl: "https://test.ektascan.io/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/elastos.js
var elastos = defineChain({
  id: 20,
  name: "Elastos Smart Chain",
  nativeCurrency: { name: "ELA", symbol: "ELA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api2.elastos.io/eth"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elastos Explorer",
      url: "https://esc.elastos.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/elastosTestnet.js
var elastosTestnet = defineChain({
  id: 21,
  name: "Elastos Smart Chain Testnet",
  nativeCurrency: { name: "tELA", symbol: "tELA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api-testnet.elastos.io/eth"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elastos Explorer",
      url: "https://esc-testnet.elastos.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/electroneum.js
var electroneum = defineChain({
  id: 52014,
  name: "Electroneum Mainnet",
  nativeCurrency: {
    name: "ETN",
    symbol: "ETN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.electroneum.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Electroneum Block Explorer",
      url: "https://blockexplorer.electroneum.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/electroneumTestnet.js
var electroneumTestnet = defineChain({
  id: 5201420,
  name: "Electroneum Testnet",
  nativeCurrency: {
    name: "ETN",
    symbol: "ETN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.electroneum.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Electroneum Block Explorer",
      url: "https://blockexplorer.thesecurityteam.rocks"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/elysiumTestnet.js
var elysiumTestnet = defineChain({
  ...chainConfig2,
  id: 1338,
  name: "Elysium Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "LAVA",
    symbol: "LAVA"
  },
  rpcUrls: {
    default: {
      http: ["https://elysium-test-rpc.vulcanforged.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elysium testnet explorer",
      url: "https://elysium-explorer.vulcanforged.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/energy.js
var energy = defineChain({
  id: 246,
  name: "Energy Mainnet",
  nativeCurrency: { name: "EWT", symbol: "EWT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.energyweb.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "EnergyWeb Explorer",
      url: "https://explorer.energyweb.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/enuls.js
var enuls = defineChain({
  id: 119,
  name: "ENULS Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "NULS",
    symbol: "NULS"
  },
  rpcUrls: {
    default: { http: ["https://evmapi2.nuls.io"] }
  },
  blockExplorers: {
    default: {
      name: "ENULS Explorer",
      url: "https://evmscan.nuls.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/eon.js
var eon = defineChain({
  id: 7332,
  name: "Horizen EON",
  nativeCurrency: {
    decimals: 18,
    name: "ZEN",
    symbol: "ZEN"
  },
  rpcUrls: {
    default: { http: ["https://eon-rpc.horizenlabs.io/ethv1"] }
  },
  blockExplorers: {
    default: {
      name: "EON Explorer",
      url: "https://eon-explorer.horizenlabs.io"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/eos.js
var eos = defineChain({
  id: 17777,
  name: "EOS EVM",
  nativeCurrency: {
    decimals: 18,
    name: "EOS",
    symbol: "EOS"
  },
  rpcUrls: {
    default: { http: ["https://api.evm.eosnetwork.com"] }
  },
  blockExplorers: {
    default: {
      name: "EOS EVM Explorer",
      url: "https://explorer.evm.eosnetwork.com",
      apiUrl: "https://explorer.evm.eosnetwork.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7943933
    }
  }
});

// node_modules/viem/_esm/chains/definitions/eosTestnet.js
var eosTestnet = defineChain({
  id: 15557,
  name: "EOS EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EOS",
    symbol: "EOS"
  },
  rpcUrls: {
    default: { http: ["https://api.testnet.evm.eosnetwork.com"] }
  },
  blockExplorers: {
    default: {
      name: "EOS EVM Testnet Explorer",
      url: "https://explorer.testnet.evm.eosnetwork.com",
      apiUrl: "https://explorer.testnet.evm.eosnetwork.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 9067940
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/etherlink.js
var etherlink = defineChain({
  id: 42793,
  name: "Etherlink",
  nativeCurrency: {
    decimals: 18,
    name: "Tez",
    symbol: "XTZ"
  },
  rpcUrls: {
    default: { http: ["https://node.mainnet.etherlink.com"] }
  },
  blockExplorers: {
    default: {
      name: "Etherlink",
      url: "https://explorer.etherlink.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 33899
    }
  }
});

// node_modules/viem/_esm/chains/definitions/etherlinkTestnet.js
var etherlinkTestnet = defineChain({
  id: 128123,
  name: "Etherlink Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Tez",
    symbol: "XTZ"
  },
  rpcUrls: {
    default: { http: ["https://node.ghostnet.etherlink.com"] }
  },
  blockExplorers: {
    default: {
      name: "Etherlink Testnet",
      url: "https://testnet.explorer.etherlink.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ethernity.js
var ethernity = defineChain({
  id: 183,
  name: "Ethernity",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.ethernitychain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ethernity Explorer",
      url: "https://ernscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/etp.js
var etp = defineChain({
  id: 20256789,
  name: "ETP Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETP Chain Native Token",
    symbol: "ETP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.etpscan.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "ETP Scan",
      url: "https://etpscan.xyz"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/evmos.js
var evmos = defineChain({
  id: 9001,
  name: "Evmos",
  nativeCurrency: {
    decimals: 18,
    name: "Evmos",
    symbol: "EVMOS"
  },
  rpcUrls: {
    default: { http: ["https://eth.bd.evmos.org:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Evmos Block Explorer",
      url: "https://escan.live"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/evmosTestnet.js
var evmosTestnet = defineChain({
  id: 9e3,
  name: "Evmos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Evmos",
    symbol: "EVMOS"
  },
  rpcUrls: {
    default: { http: ["https://eth.bd.evmos.dev:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Evmos Testnet Block Explorer",
      url: "https://evm.evmos.dev/"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/excelonMainnet.js
var excelonMainnet = defineChain({
  id: 22052002,
  name: "Excelon Mainnet",
  network: "XLON",
  nativeCurrency: {
    decimals: 18,
    name: "Excelon",
    symbol: "xlon"
  },
  rpcUrls: {
    default: {
      http: ["https://edgewallet1.xlon.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Excelon explorer",
      url: "https://explorer.excelon.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/expanse.js
var expanse = defineChain({
  id: 2,
  name: "Expanse Network",
  nativeCurrency: {
    decimals: 18,
    name: "EXP",
    symbol: "EXP"
  },
  rpcUrls: {
    default: { http: ["https://node.expanse.tech"] }
  },
  blockExplorers: {
    default: {
      name: "Expanse Explorer",
      url: "https://explorer.expanse.tech"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/exSat.js
var exsat = defineChain({
  id: 7200,
  name: "exSat Network",
  nativeCurrency: {
    decimals: 18,
    name: "BTC",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://evm.exsat.network"] }
  },
  blockExplorers: {
    default: {
      name: "exSat Explorer",
      url: "https://scan.exsat.network",
      apiUrl: "https://scan.exsat.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/exSatTestnet.js
var exsatTestnet = defineChain({
  id: 839999,
  name: "exSat Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "BTC",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://evm-tst3.exsat.network"] }
  },
  blockExplorers: {
    default: {
      name: "exSat Explorer",
      url: "https://scan-testnet.exsat.network",
      apiUrl: "https://scan-testnet.exsat.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fantom.js
var fantom = defineChain({
  id: 250,
  name: "Fantom",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://250.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "FTMScan",
      url: "https://ftmscan.com",
      apiUrl: "https://api.ftmscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 33001987
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fantomSonicTestnet.js
var fantomSonicTestnet = defineChain({
  id: 64240,
  name: "Fantom Sonic Open Testnet",
  network: "fantom-sonic-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://rpcapi.sonic.fantom.network"] }
  },
  blockExplorers: {
    default: {
      name: "Fantom Sonic Open Testnet Explorer",
      url: "https://public-sonic.fantom.network"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/fantomTestnet.js
var fantomTestnet = defineChain({
  id: 4002,
  name: "Fantom Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.fantom.network"] }
  },
  blockExplorers: {
    default: {
      name: "FTMScan",
      url: "https://testnet.ftmscan.com",
      apiUrl: "https://testnet.ftmscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 8328688
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/fibo.js
var fibo = defineChain({
  id: 12306,
  name: "Fibo Chain",
  nativeCurrency: {
    decimals: 18,
    name: "fibo",
    symbol: "FIBO"
  },
  rpcUrls: {
    default: { http: ["https://network.hzroc.art"] }
  },
  blockExplorers: {
    default: {
      name: "FiboScan",
      url: "https://scan.fibochain.org"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/filecoin.js
var filecoin = defineChain({
  id: 314,
  name: "Filecoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "filecoin",
    symbol: "FIL"
  },
  rpcUrls: {
    default: { http: ["https://api.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filfox",
      url: "https://filfox.info/en"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3328594
    }
  }
});

// node_modules/viem/_esm/chains/definitions/filecoinCalibration.js
var filecoinCalibration = defineChain({
  id: 314159,
  name: "Filecoin Calibration",
  nativeCurrency: {
    decimals: 18,
    name: "testnet filecoin",
    symbol: "tFIL"
  },
  rpcUrls: {
    default: { http: ["https://api.calibration.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filscan",
      url: "https://calibration.filscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/filecoinHyperspace.js
var filecoinHyperspace = defineChain({
  id: 3141,
  name: "Filecoin Hyperspace",
  nativeCurrency: {
    decimals: 18,
    name: "testnet filecoin",
    symbol: "tFIL"
  },
  rpcUrls: {
    default: { http: ["https://api.hyperspace.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filfox",
      url: "https://hyperspace.filfox.info/en"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/5ireChain.js
var fireChain = defineChain({
  id: 995,
  name: "5ireChain",
  nativeCurrency: { name: "5ire Token", symbol: "5IRE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.5ire.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "5ireChain Mainnet Explorer",
      url: "https://5irescan.io/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/flame.js
var flame = defineChain({
  id: 253368190,
  name: "Flame",
  network: "flame",
  nativeCurrency: {
    symbol: "TIA",
    name: "TIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.flame.astria.org"],
      webSocket: ["wss://ws.flame.astria.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Flame Explorer",
      url: "https://explorer.flame.astria.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 6829148
    }
  }
});

// node_modules/viem/_esm/chains/definitions/flare.js
var flare = defineChain({
  id: 14,
  name: "Flare Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flare",
    symbol: "FLR"
  },
  rpcUrls: {
    default: { http: ["https://flare-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Flare Explorer",
      url: "https://flare-explorer.flare.network",
      apiUrl: "https://flare-explorer.flare.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3002461
    }
  }
});

// node_modules/viem/_esm/chains/definitions/flareTestnet.js
var flareTestnet = defineChain({
  id: 114,
  name: "Flare Testnet Coston2",
  nativeCurrency: {
    decimals: 18,
    name: "Coston2 Flare",
    symbol: "C2FLR"
  },
  rpcUrls: {
    default: { http: ["https://coston2-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Coston2 Explorer",
      url: "https://coston2-explorer.flare.network",
      apiUrl: "https://coston2-explorer.flare.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/flowMainnet.js
var flowMainnet = defineChain({
  id: 747,
  name: "Flow EVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mainnet Explorer",
      url: "https://evm.flowscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6205
    }
  }
});

// node_modules/viem/_esm/chains/definitions/flowPreviewnet.js
var flowPreviewnet = defineChain({
  id: 646,
  name: "Flow EVM Previewnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://previewnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Previewnet Explorer",
      url: "https://previewnet.flowdiver.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6205
    }
  }
});

// node_modules/viem/_esm/chains/definitions/flowTestnet.js
var flowTestnet = defineChain({
  id: 545,
  name: "Flow EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Flow Diver",
      url: "https://evm-testnet.flowscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 137518
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/fluence.js
var fluence = defineChain({
  id: 9999999,
  name: "Fluence",
  nativeCurrency: { name: "FLT", symbol: "FLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.fluence.dev"],
      webSocket: ["wss://ws.mainnet.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.mainnet.fluence.dev",
      apiUrl: "https://blockscout.mainnet.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 207583
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fluenceStage.js
var fluenceStage = defineChain({
  id: 123420000220,
  name: "Fluence Stage",
  nativeCurrency: { name: "tFLT", symbol: "tFLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.stage.fluence.dev"],
      webSocket: ["wss://ws.stage.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.stage.fluence.dev",
      apiUrl: "https://blockscout.stage.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 83227
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/fluenceTestnet.js
var fluenceTestnet = defineChain({
  id: 52164803,
  name: "Fluence Testnet",
  nativeCurrency: { name: "tFLT", symbol: "tFLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.fluence.dev"],
      webSocket: ["wss://ws.testnet.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.testnet.fluence.dev",
      apiUrl: "https://blockscout.testnet.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96424
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/fluentTestnet.js
var fluentTestnet = defineChain({
  id: 20993,
  name: "Fluent Testnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dev.gblend.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Fluent Explorer",
      url: "https://blockscout.dev.gblend.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/forma.js
var forma = defineChain({
  id: 984122,
  name: "Forma",
  network: "forma",
  nativeCurrency: {
    symbol: "TIA",
    name: "TIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.forma.art"],
      webSocket: ["wss://ws.forma.art"]
    }
  },
  blockExplorers: {
    default: {
      name: "Forma Explorer",
      url: "https://explorer.forma.art"
    }
  },
  contracts: {
    multicall3: {
      address: "0xd53C6FFB123F7349A32980F87faeD8FfDc9ef079",
      blockCreated: 252705
    }
  }
});

// node_modules/viem/_esm/chains/definitions/form.js
var sourceId16 = 1;
var form = defineChain({
  id: 478,
  name: "Form Network",
  nativeCurrency: {
    decimals: 18,
    name: "Ethereum",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.form.network/http"],
      webSocket: ["wss://rpc.form.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Form Explorer",
      url: "https://explorer.form.network"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    addressManager: {
      [sourceId16]: {
        address: "0x15c249E46A2F924C2dB3A1560CF86729bAD1f07B"
      }
    },
    l1CrossDomainMessenger: {
      [sourceId16]: {
        address: "0xF333158DCCad1dF6C3F0a3aEe8BC31fA94d9eD5c"
      }
    },
    l2OutputOracle: {
      [sourceId16]: {
        address: "0x4ccAAF69F41c5810cA875183648B577CaCf1F67E"
      }
    },
    portal: {
      [sourceId16]: {
        address: "0x4E259Ee5F4136408908160dD32295A5031Fa426F"
      }
    },
    l1StandardBridge: {
      [sourceId16]: {
        address: "0xdc20aA63D3DE59574E065957190D8f24e0F7B8Ba"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  sourceId: sourceId16
});

// node_modules/viem/_esm/chains/definitions/memecoreFormicariumTestnet.js
var formicarium = defineChain({
  id: 43521,
  name: "Formicarium",
  nativeCurrency: {
    decimals: 18,
    name: "M",
    symbol: "M"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.formicarium.memecore.net"],
      webSocket: ["wss://ws.formicarium.memecore.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MemeCore Testnet Explorer",
      url: "https://formicarium.memecorescan.io"
    },
    okx: {
      name: "MemeCore Testnet Explorer",
      url: "https://web3.okx.com/explorer/formicarium-testnet"
    },
    memecore: {
      name: "MemeCore Testnet Explorer",
      url: "https://formicarium.blockscout.memecore.com",
      apiUrl: "https://formicarium.blockscout.memecore.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/formTestnet.js
var sourceId17 = 11155111;
var formTestnet = defineChain({
  id: 132902,
  name: "Form Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ethereum",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.form.network/http"],
      webSocket: ["wss://sepolia-rpc.form.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Form Testnet Explorer",
      url: "https://sepolia-explorer.form.network"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    addressManager: {
      [sourceId17]: {
        address: "0xd5C38fa934f7fd7477D4800F4f38a1c5BFdF1373"
      }
    },
    l1CrossDomainMessenger: {
      [sourceId17]: {
        address: "0x37A68565c4BE9700b3E3Ec60cC4416cAC3052FAa"
      }
    },
    l2OutputOracle: {
      [sourceId17]: {
        address: "0x9eA2239E65a59EC9C7F1ED4C116dD58Da71Fc1e2"
      }
    },
    portal: {
      [sourceId17]: {
        address: "0x60377e3cE15dF4CCA24c4beF076b60314240b032"
      }
    },
    l1StandardBridge: {
      [sourceId17]: {
        address: "0xD4531f633942b2725896F47cD2aFd260b44Ab1F7"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: true,
  sourceId: sourceId17
});

// node_modules/viem/_esm/chains/definitions/forta.js
var forta = defineChain({
  id: 80931,
  name: "Forta Chain",
  nativeCurrency: {
    symbol: "FORT",
    name: "FORT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-forta-chain-8gj1qndmfc.t.conduit.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Forta Explorer",
      url: "https://explorer.forta.org"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/foundry.js
var foundry = defineChain({
  id: 31337,
  name: "Foundry",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:8545"],
      webSocket: ["ws://127.0.0.1:8545"]
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fraxtal.js
var sourceId18 = 1;
var fraxtal = defineChain({
  ...chainConfig2,
  id: 252,
  name: "Fraxtal",
  nativeCurrency: { name: "Frax", symbol: "FRAX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.frax.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "fraxscan",
      url: "https://fraxscan.com",
      apiUrl: "https://api.fraxscan.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId18]: {
        address: "0x66CC916Ed5C6C2FA97014f7D1cD141528Ae171e4"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId18]: {
        address: "0x36cb65c1967A0Fb0EEE11569C51C2f2aA1Ca6f6D",
        blockCreated: 19135323
      }
    },
    l1StandardBridge: {
      [sourceId18]: {
        address: "0x34C0bD5877A5Ee7099D0f5688D65F4bB9158BDE2",
        blockCreated: 19135323
      }
    }
  },
  sourceId: sourceId18
});

// node_modules/viem/_esm/chains/definitions/fraxtalTestnet.js
var sourceId19 = 17e3;
var fraxtalTestnet = defineChain({
  ...chainConfig2,
  id: 2522,
  name: "Fraxtal Testnet",
  nativeCurrency: { name: "Frax", symbol: "FRAX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.frax.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "fraxscan testnet",
      url: "https://holesky.fraxscan.com",
      apiUrl: "https://api-holesky.fraxscan.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId19]: {
        address: "0x715EA64DA13F4d0831ece4Ad3E8c1aa013167F32"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId19]: {
        address: "0xB9c64BfA498d5b9a8398Ed6f46eb76d90dE5505d",
        blockCreated: 318416
      }
    },
    l1StandardBridge: {
      [sourceId19]: {
        address: "0x0BaafC217162f64930909aD9f2B27125121d6332",
        blockCreated: 318416
      }
    }
  },
  sourceId: sourceId19
});

// node_modules/viem/_esm/chains/definitions/funkiMainnet.js
var sourceId20 = 1;
var funkiMainnet = defineChain({
  ...chainConfig2,
  id: 33979,
  name: "Funki",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.funkichain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Funki Mainnet Explorer",
      url: "https://funkiscan.io"
    }
  },
  contracts: {
    ...chainConfig2.contracts
  },
  sourceId: sourceId20
});

// node_modules/viem/_esm/chains/definitions/funkiSepolia.js
var sourceId21 = 11155111;
var funkiSepolia = defineChain({
  ...chainConfig2,
  id: 3397901,
  network: "funkiSepolia",
  name: "Funki Sepolia Sandbox",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://funki-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Funki Sepolia Sandbox Explorer",
      url: "https://sepolia-sandbox.funkichain.com/"
    }
  },
  testnet: true,
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1620204
    }
  },
  sourceId: sourceId21
});

// node_modules/viem/_esm/chains/definitions/fuse.js
var fuse = defineChain({
  id: 122,
  name: "Fuse",
  nativeCurrency: { name: "Fuse", symbol: "FUSE", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.fuse.io"] }
  },
  blockExplorers: {
    default: {
      name: "Fuse Explorer",
      url: "https://explorer.fuse.io",
      apiUrl: "https://explorer.fuse.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 16146628
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fuseSparknet.js
var fuseSparknet = defineChain({
  id: 123,
  name: "Fuse Sparknet",
  nativeCurrency: { name: "Spark", symbol: "SPARK", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.fusespark.io"] }
  },
  blockExplorers: {
    default: {
      name: "Sparkent Explorer",
      url: "https://explorer.fusespark.io",
      apiUrl: "https://explorer.fusespark.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fusion.js
var fusion = defineChain({
  id: 32659,
  name: "Fusion Mainnet",
  nativeCurrency: { name: "Fusion", symbol: "FSN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.fusionnetwork.io"],
      webSocket: ["wss://mainnet.fusionnetwork.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "FSNscan",
      url: "https://fsnscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10441605
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/fusionTestnet.js
var fusionTestnet = defineChain({
  id: 46688,
  name: "Fusion Testnet",
  nativeCurrency: { name: "Fusion", symbol: "FSN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.fusionnetwork.io"],
      webSocket: ["wss://testnet.fusionnetwork.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "FSNscan",
      url: "https://testnet.fsnscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10428309
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/garnet.js
var sourceId22 = 17e3;
var garnet = defineChain({
  ...chainConfig2,
  name: "Garnet Testnet",
  testnet: true,
  id: 17069,
  sourceId: sourceId22,
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.garnetchain.com"],
      webSocket: ["wss://rpc.garnetchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.garnetchain.com"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId22]: {
        address: "0x57ee40586fbE286AfC75E67cb69511A6D9aF5909",
        blockCreated: 1274684
      }
    },
    l2OutputOracle: {
      [sourceId22]: {
        address: "0xCb8E7AC561b8EF04F2a15865e9fbc0766FEF569B",
        blockCreated: 1274684
      }
    },
    l1StandardBridge: {
      [sourceId22]: {
        address: "0x09bcDd311FE398F80a78BE37E489f5D440DB95DE",
        blockCreated: 1274684
      }
    }
  }
});

// node_modules/viem/_esm/chains/definitions/geist.js
var geist = defineChain({
  id: 63157,
  name: "Geist Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Aavegotchi GHST Token",
    symbol: "GHST"
  },
  rpcUrls: {
    default: {
      http: ["https://geist-mainnet.g.alchemy.com/public"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://geist-mainnet.explorer.alchemy.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 660735
    }
  }
});

// node_modules/viem/_esm/chains/definitions/genesys.js
var genesys = defineChain({
  id: 16507,
  name: "Genesys Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "GSYS",
    symbol: "GSYS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.genesys.network"] }
  },
  blockExplorers: {
    default: {
      name: "Genesys Explorer",
      url: "https://gchainexplorer.genesys.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/glideL1Protocol.js
var glideL1Protocol = defineChain({
  id: 251,
  name: "Glide L1 Protocol XP",
  nativeCurrency: { name: "GLXP", symbol: "GLXP", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-api.glideprotocol.xyz/l1-rpc"],
      webSocket: ["wss://rpc-api.glideprotocol.xyz/l1-rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Glide Protocol Explore",
      url: "https://blockchain-explorer.glideprotocol.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/glideL2Protocol.js
var glideL2Protocol = defineChain({
  id: 253,
  name: "Glide L2 Protocol XP",
  nativeCurrency: { name: "GLXP", symbol: "GLXP", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-api.glideprotocol.xyz/l2-rpc"],
      webSocket: ["wss://rpc-api.glideprotocol.xyz/l2-rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Glide Protocol Explore",
      url: "https://blockchain-explorer.glideprotocol.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/gnosis.js
var gnosis = defineChain({
  id: 100,
  name: "Gnosis",
  nativeCurrency: {
    decimals: 18,
    name: "xDAI",
    symbol: "XDAI"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.gnosischain.com"],
      webSocket: ["wss://rpc.gnosischain.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "Gnosisscan",
      url: "https://gnosisscan.io",
      apiUrl: "https://api.gnosisscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 21022491
    }
  }
});

// node_modules/viem/_esm/chains/definitions/gnosisChiado.js
var gnosisChiado = defineChain({
  id: 10200,
  name: "Gnosis Chiado",
  nativeCurrency: {
    decimals: 18,
    name: "Gnosis",
    symbol: "xDAI"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.chiadochain.net"],
      webSocket: ["wss://rpc.chiadochain.net/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.chiadochain.net",
      apiUrl: "https://blockscout.chiadochain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4967313
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/goat.js
var goat = defineChain({
  id: 2345,
  name: "GOAT",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcoin",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://rpc.goat.network"] }
  },
  blockExplorers: {
    default: {
      name: "Goat Explorer",
      url: "https://explorer.goat.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/gobi.js
var gobi = defineChain({
  id: 1663,
  name: "Horizen Gobi Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Test ZEN",
    symbol: "tZEN"
  },
  rpcUrls: {
    default: { http: ["https://gobi-testnet.horizenlabs.io/ethv1"] }
  },
  blockExplorers: {
    default: {
      name: "Gobi Explorer",
      url: "https://gobi-explorer.horizen.io"
    }
  },
  contracts: {},
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/goChain.js
var goChain = defineChain({
  id: 60,
  name: "GoChain",
  nativeCurrency: {
    decimals: 18,
    name: "GO",
    symbol: "GO"
  },
  rpcUrls: {
    default: { http: ["https://rpc.gochain.io"] }
  },
  blockExplorers: {
    default: {
      name: "GoChain Explorer",
      url: "https://explorer.gochain.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/godwoken.js
var godwoken = defineChain({
  id: 71402,
  name: "Godwoken Mainnet",
  nativeCurrency: { decimals: 18, name: "pCKB", symbol: "pCKB" },
  rpcUrls: {
    default: {
      http: ["https://v1.mainnet.godwoken.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "GW Scan",
      url: "https://v1.gwscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 15034
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/goerli.js
var goerli = defineChain({
  id: 5,
  name: "Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://5.rpc.thirdweb.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.etherscan.io",
      apiUrl: "https://api-goerli.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xfc4AC75C46C914aF5892d6d3eFFcebD7917293F1",
      blockCreated: 10339206
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6507670
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/gravity.js
var gravity = defineChain({
  id: 1625,
  name: "Gravity Alpha Mainnet",
  nativeCurrency: { name: "G", symbol: "G", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.gravity.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Gravity Explorer",
      url: "https://explorer.gravity.xyz",
      apiUrl: "https://explorer.gravity.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xf8ac4BEB2F75d2cFFb588c63251347fdD629B92c",
      blockCreated: 16851
    }
  }
});

// node_modules/viem/_esm/chains/definitions/gunz.js
var gunz = defineChain({
  id: 43419,
  name: "Gunz Mainnet",
  nativeCurrency: { name: "GUN", symbol: "GUN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.gunzchain.io/ext/bc/2M47TxWHGnhNtq6pM5zPXdATBtuqubxn5EPFgFmEawCQr9WFML/rpc"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Gunz Explorer",
      url: "https://gunzscan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 70502
    }
  }
});

// node_modules/viem/_esm/chains/definitions/guruNetwork.js
var guruNetwork = defineChain({
  id: 260,
  name: "Guru Network Mainnet",
  nativeCurrency: {
    name: "GURU Token",
    symbol: "GURU",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-main.gurunetwork.ai",
        "https://rpc.gurunetwork.ai/archive/260"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Guruscan",
      url: "https://scan.gurunetwork.ai"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 271691
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/guruTestnet.js
var guruTestnet = defineChain({
  id: 261,
  name: "Guru Network Testnet",
  nativeCurrency: {
    name: "tGURU Token",
    symbol: "tGURU",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-test.gurunetwork.ai",
        "https://rpc.gurunetwork.ai/archive/261"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Guruscan",
      url: "https://sepolia.gurunetwork.ai"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ham.js
var ham = defineChain({
  id: 5112,
  name: "Ham",
  nativeCurrency: {
    decimals: 18,
    name: "Ham",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.ham.fun"],
      webSocket: ["wss://rpc.ham.fun"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ham Chain Explorer",
      url: "https://explorer.ham.fun",
      apiUrl: "https://explorer.ham.fun/api/v2"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/happychainTestnet.js
var happychainTestnet = defineChain({
  id: 216,
  name: "Happychain Testnet",
  nativeCurrency: {
    symbol: "HAPPY",
    name: "HAPPY",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.happy.tech/http"],
      webSocket: ["wss://rpc.testnet.happy.tech/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Happy Chain Testnet Explorer",
      url: "https://explorer.testnet.happy.tech"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/haqqMainnet.js
var haqqMainnet = defineChain({
  id: 11235,
  name: "HAQQ Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Islamic Coin",
    symbol: "ISLM"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.eth.haqq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "HAQQ Explorer",
      url: "https://explorer.haqq.network",
      apiUrl: "https://explorer.haqq.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/haqqTestedge2.js
var haqqTestedge2 = defineChain({
  id: 54211,
  name: "HAQQ Testedge 2",
  nativeCurrency: {
    decimals: 18,
    name: "Islamic Coin",
    symbol: "ISLMT"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.eth.testedge2.haqq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "HAQQ Explorer",
      url: "https://explorer.testedge2.haqq.network",
      apiUrl: "https://explorer.testedge2.haqq.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/hardhat.js
var hardhat = defineChain({
  id: 31337,
  name: "Hardhat",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
});

// node_modules/viem/_esm/chains/definitions/harmonyOne.js
var harmonyOne = defineChain({
  id: 16666e5,
  name: "Harmony One",
  nativeCurrency: {
    name: "Harmony",
    symbol: "ONE",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://1666600000.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Harmony Explorer",
      url: "https://explorer.harmony.one"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 24185753
    }
  }
});

// node_modules/viem/_esm/chains/definitions/hashKeyChain.js
var hashkey = defineChain({
  id: 177,
  name: "HashKey Chain",
  nativeCurrency: {
    decimals: 18,
    name: "HashKey EcoPoints",
    symbol: "HSK"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.hsk.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "HashKey Chain Explorer",
      url: "https://hashkey.blockscout.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/hashkeyChainTestnet.js
var hashkeyTestnet = defineChain({
  id: 133,
  name: "HashKey Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "HashKey EcoPoints",
    symbol: "HSK"
  },
  rpcUrls: {
    default: {
      http: ["https://hashkeychain-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "HashKey Chain Explorer",
      url: "https://hashkeychain-testnet-explorer.alt.technology"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/haustTestnet.js
var haustTestnet = defineChain({
  id: 1523903251,
  name: "Haust Network Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "HAUST",
    symbol: "HAUST"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.haust.app"]
    }
  },
  blockExplorers: {
    default: {
      name: "Haust Network Testnet Explorer",
      url: "https://explorer-testnet.haust.app"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hedera.js
var hedera = defineChain({
  id: 295,
  name: "Hedera Mainnet",
  network: "hedera-mainnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/mainnet"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/hederaPreviewnet.js
var hederaPreviewnet = defineChain({
  id: 297,
  name: "Hedera Previewnet",
  network: "hedera-previewnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://previewnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/previewnet"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hederaTestnet.js
var hederaTestnet = defineChain({
  id: 296,
  name: "Hedera Testnet",
  network: "hedera-testnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/testnet"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hela.js
var hela = defineChain({
  id: 8668,
  name: "Hela Mainnet",
  nativeCurrency: {
    name: "HLUSD",
    symbol: "HLUSD",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.helachain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hela explorer",
      url: "https://mainnet-blockexplorer.helachain.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/hemi.js
var hemi = defineChain({
  id: 43111,
  name: "Hemi",
  network: "Hemi",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.hemi.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.hemi.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/hemiSepolia.js
var hemiSepolia = defineChain({
  id: 743111,
  name: "Hemi Sepolia",
  network: "Hemi Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.hemi.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hemi Sepolia explorer",
      url: "https://testnet.explorer.hemi.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/holesky.js
var holesky = defineChain({
  id: 17e3,
  name: "Holesky",
  nativeCurrency: { name: "Holesky Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ethereum-holesky-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://holesky.etherscan.io",
      apiUrl: "https://api-holesky.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 77
    },
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      blockCreated: 801613
    },
    ensUniversalResolver: {
      address: "0xa6AC935D4971E3CD133b950aE053bECD16fE7f3b",
      blockCreated: 973484
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hoodi.js
var hoodi = defineChain({
  id: 560048,
  name: "Hoodi",
  nativeCurrency: { name: "Hoodi Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.hoodi.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://hoodi.etherscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2589
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hpb.js
var hpb = defineChain({
  id: 269,
  name: "High Performance Blockchain",
  nativeCurrency: { name: "HPB", symbol: "HPB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://hpbnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "hpbScan",
      url: "https://hscan.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/huddle01Mainnet.js
var sourceId23 = 42161;
var huddle01Mainnet = defineChain({
  id: 12323,
  name: "Huddle01 dRTC Chain",
  nativeCurrency: {
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://huddle01.calderachain.xyz/http"],
      webSocket: ["wss://huddle01.calderachain.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Huddle01 Caldera Explorer",
      url: "https://huddle01.calderaexplorer.xyz",
      apiUrl: "https://huddle01.calderaexplorer.xyz/api"
    }
  },
  sourceId: sourceId23
});

// node_modules/viem/_esm/chains/definitions/huddle01Testnet.js
var sourceId24 = 421614;
var huddle01Testnet = defineChain({
  id: 2524852,
  name: "Huddle01 dRTC Chain Testnet",
  nativeCurrency: {
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://huddle-testnet.rpc.caldera.xyz/http"],
      webSocket: ["wss://huddle-testnet.rpc.caldera.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Huddle01 Caldera Explorer",
      url: "https://huddle-testnet.explorer.caldera.xyz",
      apiUrl: "https://huddle-testnet.explorer.caldera.xyz/api"
    }
  },
  sourceId: sourceId24
});

// node_modules/viem/_esm/chains/definitions/humanode.js
var humanode = defineChain({
  id: 5234,
  name: "Humanode",
  nativeCurrency: { name: "HMND", symbol: "HMND", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://explorer-rpc-http.mainnet.stages.humanode.io"],
      webSocket: ["wss://explorer-rpc-ws.mainnet.stages.humanode.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Subscan",
      url: "https://humanode.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4413097
    }
  }
});

// node_modules/viem/_esm/chains/definitions/humanodeTestnet5.js
var humanodeTestnet5 = defineChain({
  id: 14853,
  name: "Humanode Testnet 5",
  nativeCurrency: { name: "HMND", symbol: "HMND", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://explorer-rpc-http.testnet5.stages.humanode.io"],
      webSocket: ["wss://explorer-rpc-ws.testnet5.stages.humanode.io"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/hychain.js
var hychain = defineChain({
  id: 2911,
  name: "HYCHAIN",
  nativeCurrency: { name: "HYTOPIA", symbol: "TOPIA", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.hychain.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "HYCHAIN Explorer",
      url: "https://explorer.hychain.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/hychainTestnet.js
var hychainTestnet = defineChain({
  id: 29112,
  name: "HYCHAIN Testnet",
  nativeCurrency: { name: "HYTOPIA", symbol: "TOPIA", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.hychain.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "HYCHAIN Explorer",
      url: "https://testnet-rpc.hychain.com/http"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/idchain.js
var idchain = defineChain({
  id: 74,
  name: "IDChain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "EIDI",
    symbol: "EIDI"
  },
  rpcUrls: {
    default: {
      http: ["https://idchain.one/rpc"],
      webSocket: ["wss://idchain.one/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "IDChain Explorer",
      url: "https://explorer.idchain.one"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/immutableZkEvm.js
var immutableZkEvm = defineChain({
  id: 13371,
  name: "Immutable zkEVM",
  nativeCurrency: {
    decimals: 18,
    name: "Immutable Coin",
    symbol: "IMX"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.immutable.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Immutable Explorer",
      url: "https://explorer.immutable.com",
      apiUrl: "https://explorer.immutable.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x236bdA4589e44e6850f5aC6a74BfCa398a86c6c0",
      blockCreated: 4335972
    }
  }
});

// node_modules/viem/_esm/chains/definitions/immutableZkEvmTestnet.js
var immutableZkEvmTestnet = defineChain({
  id: 13473,
  name: "Immutable zkEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Immutable Coin",
    symbol: "IMX"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.immutable.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Immutable Testnet Explorer",
      url: "https://explorer.testnet.immutable.com/"
    }
  },
  contracts: {
    multicall3: {
      address: "0x2CC787Ed364600B0222361C4188308Fa8E68bA60",
      blockCreated: 5977391
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/inEVM.js
var inEVM = defineChain({
  id: 2525,
  name: "inEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Injective",
    symbol: "INJ"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.rpc.inevm.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "inEVM Explorer",
      url: "https://inevm.calderaexplorer.xyz",
      apiUrl: "https://inevm.calderaexplorer.xyz/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 118606
    }
  }
});

// node_modules/viem/_esm/chains/definitions/initVerse.js
var initVerse = defineChain({
  id: 7233,
  name: "InitVerse Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "InitVerse",
    symbol: "INI"
  },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet.inichain.com"] }
  },
  blockExplorers: {
    default: {
      name: "InitVerseScan",
      url: "https://www.iniscan.com",
      apiUrl: "https://explorer-api.inichain.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x83466BE48A067115FFF91f7b892Ed1726d032e47",
      blockCreated: 2318
    }
  }
});

// node_modules/viem/_esm/chains/definitions/initVerseGenesis.js
var initVerseGenesis = defineChain({
  id: 7234,
  name: "InitVerse Genesis Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "InitVerse",
    symbol: "INI"
  },
  rpcUrls: {
    default: { http: ["https://rpc-testnet.inichain.com"] }
  },
  blockExplorers: {
    default: {
      name: "InitVerseGenesisScan",
      url: "https://genesis-testnet.iniscan.com",
      apiUrl: "https://explorer-testnet-api.inichain.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0cF32CBDd6c437331EA4f85ed2d881A5379B5a6F",
      blockCreated: 16361
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ink.js
var sourceId25 = 1;
var ink = defineChain({
  ...chainConfig2,
  id: 57073,
  name: "Ink",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-gel.inkonchain.com",
        "https://rpc-qnd.inkonchain.com"
      ],
      webSocket: [
        "wss://rpc-gel.inkonchain.com",
        "wss://rpc-qnd.inkonchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.inkonchain.com",
      apiUrl: "https://explorer.inkonchain.com/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId25]: {
        address: "0x10d7b35078d3baabb96dd45a9143b94be65b12cd"
      }
    },
    portal: {
      [sourceId25]: {
        address: "0x5d66c1782664115999c47c9fa5cd031f495d3e4f"
      }
    },
    l1StandardBridge: {
      [sourceId25]: {
        address: "0x88ff1e5b602916615391f55854588efcbb7663f0"
      }
    }
  },
  testnet: false,
  sourceId: sourceId25
});

// node_modules/viem/_esm/chains/definitions/inkSepolia.js
var sourceId26 = 11155111;
var inkSepolia = defineChain({
  ...chainConfig2,
  id: 763373,
  name: "Ink Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-gel-sepolia.inkonchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer-sepolia.inkonchain.com/",
      apiUrl: "https://explorer-sepolia.inkonchain.com/api/v2"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [sourceId26]: {
        address: "0x860e626c700af381133d9f4af31412a2d1db3d5d"
      }
    },
    portal: {
      [sourceId26]: {
        address: "0x5c1d29c6c9c8b0800692acc95d700bcb4966a1d7"
      }
    },
    l1StandardBridge: {
      [sourceId26]: {
        address: "0x33f60714bbd74d62b66d79213c348614de51901c"
      }
    }
  },
  testnet: true,
  sourceId: sourceId26
});

// node_modules/viem/_esm/chains/definitions/iota.js
var iota = defineChain({
  id: 8822,
  name: "IOTA EVM",
  network: "iotaevm",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.iotaledger.net"],
      webSocket: ["wss://ws.json-rpc.evm.iotaledger.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.evm.iota.org",
      apiUrl: "https://explorer.evm.iota.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 25022
    }
  }
});

// node_modules/viem/_esm/chains/definitions/iotaTestnet.js
var iotaTestnet = defineChain({
  id: 1075,
  name: "IOTA EVM Testnet",
  network: "iotaevm-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.testnet.iotaledger.net"],
      webSocket: ["wss://ws.json-rpc.evm.testnet.iotaledger.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.evm.testnet.iotaledger.net",
      apiUrl: "https://explorer.evm.testnet.iotaledger.net/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/iotex.js
var iotex = defineChain({
  id: 4689,
  name: "IoTeX",
  nativeCurrency: {
    decimals: 18,
    name: "IoTeX",
    symbol: "IOTX"
  },
  rpcUrls: {
    default: {
      http: ["https://babel-api.mainnet.iotex.io"],
      webSocket: ["wss://babel-api.mainnet.iotex.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "IoTeXScan",
      url: "https://iotexscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 22163670
    }
  }
});

// node_modules/viem/_esm/chains/definitions/iotexTestnet.js
var iotexTestnet = defineChain({
  id: 4690,
  name: "IoTeX Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IoTeX",
    symbol: "IOTX"
  },
  rpcUrls: {
    default: {
      http: ["https://babel-api.testnet.iotex.io"],
      webSocket: ["wss://babel-api.testnet.iotex.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "IoTeXScan",
      url: "https://testnet.iotexscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xb5cecD6894c6f473Ec726A176f1512399A2e355d",
      blockCreated: 24347592
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/iSunCoin.js
var iSunCoin = defineChain({
  id: 8017,
  name: "iSunCoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ISC",
    symbol: "ISC"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.isuncoin.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "iSunCoin Explorer",
      url: "https://baifa.io/app/chains/8017"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/jbc.js
var jbc = defineChain({
  id: 8899,
  name: "JIBCHAIN L1",
  network: "jbc",
  nativeCurrency: { name: "JBC", symbol: "JBC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-l1.jibchain.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp-l1.jibchain.net",
      apiUrl: "https://exp-l1.jibchain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc0C8C486D1466C57Efe13C2bf000d4c56F47CBdC",
      blockCreated: 2299048
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/jbcTestnet.js
var jbcTestnet = defineChain({
  id: 88991,
  name: "Jibchain Testnet",
  nativeCurrency: { name: "tJBC", symbol: "tJBC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.jibchain.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp.testnet.jibchain.net",
      apiUrl: "https://exp.testnet.jibchain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xa1a858ad9041B4741e620355a3F96B3c78e70ecE",
      blockCreated: 32848
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/juneo.js
var juneo = defineChain({
  id: 45003,
  name: "Juneo JUNE-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "JUNE-Chain",
    symbol: "JUNE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/JUNE/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/2",
      apiUrl: "https://juneoscan.io/chain/2/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoBCH1Chain.js
var juneoBCH1Chain = defineChain({
  id: 45013,
  name: "Juneo BCH1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo BCH1-Chain",
    symbol: "BCH1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/BCH1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/12",
      apiUrl: "https://juneoscan.io/chain/12/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoDAI1Chain.js
var juneoDAI1Chain = defineChain({
  id: 45004,
  name: "Juneo DAI1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo DAI1-Chain",
    symbol: "DAI1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/DAI1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/5",
      apiUrl: "https://juneoscan.io/chain/5/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoDOGE1Chain.js
var juneoDOGE1Chain = defineChain({
  id: 45010,
  name: "Juneo DOGE1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo DOGE1-Chain",
    symbol: "DOGE1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/DOGE1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/10",
      apiUrl: "https://juneoscan.io/chain/10/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoEUR1Chain.js
var juneoEUR1Chain = defineChain({
  id: 45011,
  name: "Juneo EUR1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo EUR1-Chain",
    symbol: "EUR1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/EUR1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/6",
      apiUrl: "https://juneoscan.io/chain/6/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoGLD1Chain.js
var juneoGLD1Chain = defineChain({
  id: 45008,
  name: "Juneo GLD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo GLD1-Chain",
    symbol: "GLD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/GLD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/8",
      apiUrl: "https://juneoscan.io/chain/8/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoLINK1Chain.js
var juneoLINK1Chain = defineChain({
  id: 45014,
  name: "Juneo LINK1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo LINK1-Chain",
    symbol: "LINK1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/LINK1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/13",
      apiUrl: "https://juneoscan.io/chain/13/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoLTC1Chain.js
var juneoLTC1Chain = defineChain({
  id: 45009,
  name: "Juneo LTC1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo LTC1-Chain",
    symbol: "LTC1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/LTC1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/11",
      apiUrl: "https://juneoscan.io/chain/11/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneomBTC1Chain.js
var juneomBTC1Chain = defineChain({
  id: 45007,
  name: "Juneo mBTC1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo mBTC1-Chain",
    symbol: "mBTC1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/mBTC1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/9",
      apiUrl: "https://juneoscan.io/chain/9/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoSGD1Chain.js
var juneoSGD1Chain = defineChain({
  id: 45012,
  name: "Juneo SGD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo SGD1-Chain",
    symbol: "SGD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/SGD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/7",
      apiUrl: "https://juneoscan.io/chain/7/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoSocotraTestnet.js
var juneoSocotraTestnet = defineChain({
  id: 101003,
  name: "Socotra JUNE-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Socotra JUNE-Chain",
    symbol: "JUNE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.socotra-testnet.network/ext/bc/JUNE/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://socotra.juneoscan.io/chain/2",
      apiUrl: "https://socotra.juneoscan.io/chain/2/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/juneoUSD1Chain.js
var juneoUSD1Chain = defineChain({
  id: 45006,
  name: "Juneo USD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo USD1-Chain",
    symbol: "USD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/USD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/4",
      apiUrl: "https://juneoscan.io/chain/4/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoUSDT1Chain.js
var juneoUSDT1Chain = defineChain({
  id: 45005,
  name: "Juneo USDT1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo USDT1-Chain",
    symbol: "USDT1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/USDT1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/3",
      apiUrl: "https://juneoscan.io/chain/3/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/karura.js
var karura = defineChain({
  id: 686,
  name: "Karura",
  network: "karura",
  nativeCurrency: {
    name: "Karura",
    symbol: "KAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-karura.aca-api.network"],
      webSocket: ["wss://eth-rpc-karura.aca-api.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Karura Blockscout",
      url: "https://blockscout.karura.network",
      apiUrl: "https://blockscout.karura.network/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/kakarotSepolia.js
var kakarotSepolia = defineChain({
  id: 1802203764,
  name: "Kakarot Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.kakarot.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kakarot Scan",
      url: "https://sepolia.kakarotscan.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/kakarotStarknetSepolia.js
var kakarotStarknetSepolia = defineChain({
  id: 920637907288165,
  name: "Kakarot Starknet Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.kakarot.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kakarot Scan",
      url: "https://sepolia.kakarotscan.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/kardiaChain.js
var kardiaChain = defineChain({
  id: 24,
  name: "KardiaChain Mainnet",
  nativeCurrency: { name: "KAI", symbol: "KAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.kardiachain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "KardiaChain Explorer",
      url: "https://explorer.kardiachain.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/kava.js
var kava = defineChain({
  id: 2222,
  name: "Kava EVM",
  network: "kava-mainnet",
  nativeCurrency: {
    name: "Kava",
    symbol: "KAVA",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://evm.kava.io"] }
  },
  blockExplorers: {
    default: {
      name: "Kava EVM Explorer",
      url: "https://kavascan.com",
      apiUrl: "https://kavascan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3661165
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/kavaTestnet.js
var kavaTestnet = defineChain({
  id: 2221,
  name: "Kava EVM Testnet",
  network: "kava-testnet",
  nativeCurrency: {
    name: "Kava",
    symbol: "KAVA",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://evm.testnet.kava.io"] }
  },
  blockExplorers: {
    default: {
      name: "Kava EVM Testnet Explorer",
      url: "https://testnet.kavascan.com/",
      apiUrl: "https://testnet.kavascan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xDf1D724A7166261eEB015418fe8c7679BBEa7fd6",
      blockCreated: 7242179
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/kcc.js
var kcc = defineChain({
  id: 321,
  name: "KCC Mainnet",
  network: "KCC Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "KCS",
    symbol: "KCS"
  },
  rpcUrls: {
    default: {
      http: ["https://kcc-rpc.com"]
    }
  },
  blockExplorers: {
    default: { name: "KCC Explorer", url: "https://explorer.kcc.io" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11760430
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/kinto.js
var kinto = defineChain({
  id: 7887,
  name: "Kinto Mainnet",
  network: "Kinto Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.kinto.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Kinto Explorer",
      url: "https://explorer.kinto.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/klaytn.js
var klaytn = defineChain({
  id: 8217,
  name: "Klaytn",
  nativeCurrency: {
    decimals: 18,
    name: "Klaytn",
    symbol: "KLAY"
  },
  rpcUrls: {
    default: { http: ["https://public-en-cypress.klaytn.net"] }
  },
  blockExplorers: {
    default: {
      name: "KlaytnScope",
      url: "https://scope.klaytn.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96002415
    }
  }
});

// node_modules/viem/_esm/chains/definitions/kaia.js
var kaia = defineChain({
  id: 8217,
  name: "Kaia",
  nativeCurrency: {
    decimals: 18,
    name: "Kaia",
    symbol: "KAIA"
  },
  rpcUrls: {
    default: { http: ["https://public-en.node.kaia.io"] }
  },
  blockExplorers: {
    default: {
      name: "KaiaScan",
      url: "https://kaiascan.io",
      apiUrl: "https://api-cypress.klaytnscope.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96002415
    }
  }
});

// node_modules/viem/_esm/chains/definitions/kairos.js
var kairos = defineChain({
  id: 1001,
  name: "Kairos Testnet",
  network: "kairos",
  nativeCurrency: {
    decimals: 18,
    name: "Kairos KAIA",
    symbol: "KAIA"
  },
  rpcUrls: {
    default: { http: ["https://public-en-kairos.node.kaia.io"] }
  },
  blockExplorers: {
    default: {
      name: "KaiaScan",
      url: "https://kairos.kaiascan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 123390593
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/klaytnBaobab.js
var klaytnBaobab = defineChain({
  id: 1001,
  name: "Klaytn Baobab Testnet",
  network: "klaytn-baobab",
  nativeCurrency: {
    decimals: 18,
    name: "Baobab Klaytn",
    symbol: "KLAY"
  },
  rpcUrls: {
    default: { http: ["https://public-en-baobab.klaytn.net"] }
  },
  blockExplorers: {
    default: {
      name: "KlaytnScope",
      url: "https://baobab.klaytnscope.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 123390593
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/koi.js
var koi = defineChain({
  id: 701,
  name: "Koi Network",
  nativeCurrency: {
    decimals: 18,
    name: "Koi Network Native Token",
    symbol: "KRING"
  },
  rpcUrls: {
    default: {
      http: ["https://koi-rpc.darwinia.network"],
      webSocket: ["wss://koi-rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Blockscout", url: "https://koi-scan.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 180001
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/kroma.js
var kroma = defineChain({
  id: 255,
  name: "Kroma",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.kroma.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kroma Explorer",
      url: "https://blockscout.kroma.network",
      apiUrl: "https://blockscout.kroma.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 16054868
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/kromaSepolia.js
var kromaSepolia = defineChain({
  id: 2358,
  name: "Kroma Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.sepolia.kroma.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kroma Sepolia Explorer",
      url: "https://blockscout.sepolia.kroma.network",
      apiUrl: "https://blockscout.sepolia.kroma.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 8900914
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/l3x.js
var l3x = defineChain({
  id: 12324,
  name: "L3X Protocol",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.l3x.com"],
      webSocket: ["wss://rpc-mainnet.l3x.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "L3X Mainnet Explorer",
      url: "https://explorer.l3x.com",
      apiUrl: "https://explorer.l3x.com/api/v2"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/l3xTestnet.js
var l3xTestnet = defineChain({
  id: 12325,
  name: "L3X Protocol Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.l3x.com"],
      webSocket: ["wss://rpc-testnet.l3x.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "L3X Testnet Explorer",
      url: "https://explorer-testnet.l3x.com",
      apiUrl: "https://explorer-testnet.l3x.com/api/v2"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lavita.js
var lavita = defineChain({
  id: 360890,
  name: "LAVITA Mainnet",
  nativeCurrency: { name: "vTFUEL", symbol: "vTFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://tsub360890-eth-rpc.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "LAVITA Explorer",
      url: "https://tsub360890-explorer.thetatoken.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/lens.js
var lens = defineChain({
  id: 232,
  name: "Lens",
  nativeCurrency: { name: "GHO", symbol: "GHO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.lens.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lens Block Explorer",
      url: "https://explorer.lens.xyz",
      apiUrl: "https://explorer.lens.xyz/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/lensTestnet.js
var lensTestnet = defineChain({
  id: 37111,
  name: "Lens Testnet",
  nativeCurrency: { name: "GRASS", symbol: "GRASS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.lens.dev"],
      webSocket: ["wss://rpc.testnet.lens.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lens Block Explorer",
      url: "https://block-explorer.testnet.lens.dev",
      apiUrl: "https://block-explorer-api.staging.lens.dev/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lestnet.js
var lestnet = defineChain({
  id: 21363,
  name: "Lestnet",
  nativeCurrency: { name: "Lestnet Ether", symbol: "LETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://service.lestnet.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lestnet Explorer",
      url: "https://explore.lestnet.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lightlinkPegasus.js
var lightlinkPegasus = defineChain({
  id: 1891,
  name: "LightLink Pegasus Testnet",
  network: "lightlink-pegasus",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://replicator.pegasus.lightlink.io/rpc/v1"]
    }
  },
  blockExplorers: {
    default: {
      name: "LightLink Pegasus Explorer",
      url: "https://pegasus.lightlink.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 127188532
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lightlinkPhoenix.js
var lightlinkPhoenix = defineChain({
  id: 1890,
  name: "LightLink Phoenix Mainnet",
  network: "lightlink-phoenix",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://replicator.phoenix.lightlink.io/rpc/v1"]
    }
  },
  blockExplorers: {
    default: {
      name: "LightLink Phoenix Explorer",
      url: "https://phoenix.lightlink.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 125499184
    }
  },
  testnet: false
});

// node_modules/viem/_esm/linea/actions/estimateGas.js
async function estimateGas3(client, args) {
  var _a2, _b, _c2;
  const { account: account_ = client.account } = args;
  if (!account_)
    throw new AccountNotFoundError();
  const account = parseAccount(account_);
  try {
    const { accessList, blockNumber, blockTag, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to: to4, value, ...rest } = args;
    const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex2(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    assertRequest(args);
    const chainFormat = (_c2 = (_b = (_a2 = client.chain) == null ? void 0 : _a2.formatters) == null ? void 0 : _b.transactionRequest) == null ? void 0 : _c2.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, { format: chainFormat }),
      from: account == null ? void 0 : account.address,
      accessList,
      data,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to: to4,
      value
    });
    const { baseFeePerGas, gasLimit, priorityFeePerGas } = await client.request({
      method: "linea_estimateGas",
      params: block ? [request, block] : [request]
    });
    return {
      baseFeePerGas: BigInt(baseFeePerGas),
      gasLimit: BigInt(gasLimit),
      priorityFeePerGas: BigInt(priorityFeePerGas)
    };
  } catch (err) {
    throw getCallError(err, {
      ...args,
      account,
      chain: client.chain
    });
  }
}

// node_modules/viem/_esm/linea/chainConfig.js
var chainConfig4 = {
  fees: {
    estimateFeesPerGas: estimateFeesPerGas3,
    async maxPriorityFeePerGas({ block, client, request }) {
      const response = await estimateFeesPerGas3({
        block,
        client,
        multiply: (x9) => x9,
        request,
        type: "eip1559"
      });
      if (!(response == null ? void 0 : response.maxPriorityFeePerGas))
        return null;
      return response.maxPriorityFeePerGas;
    }
  }
};
async function estimateFeesPerGas3({ client, multiply, request, type }) {
  try {
    const response = await estimateGas3(client, {
      ...request,
      account: request == null ? void 0 : request.account
    });
    const { priorityFeePerGas: maxPriorityFeePerGas } = response;
    const baseFeePerGas = multiply(BigInt(response.baseFeePerGas));
    const maxFeePerGas = baseFeePerGas + maxPriorityFeePerGas;
    if (type === "legacy")
      return { gasPrice: maxFeePerGas };
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  } catch {
    return null;
  }
}

// node_modules/viem/_esm/chains/definitions/linea.js
var linea = defineChain({
  ...chainConfig4,
  id: 59144,
  name: "Linea Mainnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.linea.build"],
      webSocket: ["wss://rpc.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://lineascan.build",
      apiUrl: "https://api.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 42
    },
    ensRegistry: {
      address: "0x50130b669B28C339991d8676FA73CF122a121267",
      blockCreated: 6682888
    },
    ensUniversalResolver: {
      address: "0x3aA974fb3f8C1E02796048BDCdeD79e9D53a6965",
      blockCreated: 6683e3
    }
  },
  ensTlds: [".linea.eth"],
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/lineaGoerli.js
var lineaGoerli = defineChain({
  id: 59140,
  name: "Linea Goerli Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.goerli.linea.build"],
      webSocket: ["wss://rpc.goerli.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.lineascan.build",
      apiUrl: "https://api-goerli.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 498623
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lineaSepolia.js
var lineaSepolia = defineChain({
  ...chainConfig4,
  id: 59141,
  name: "Linea Sepolia Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia.linea.build"],
      webSocket: ["wss://rpc.sepolia.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.lineascan.build",
      apiUrl: "https://api-sepolia.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 227427
    },
    ensRegistry: {
      address: "0x5B2636F0f2137B4aE722C01dd5122D7d3e9541f7",
      blockCreated: 2395094
    },
    ensUniversalResolver: {
      address: "0x72560a31B3DAEE82B984a7F51c6b3b1bb7CC9F50",
      blockCreated: 2395255
    }
  },
  ensTlds: [".linea.eth"],
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lineaTestnet.js
var lineaTestnet = defineChain({
  id: 59140,
  name: "Linea Goerli Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.goerli.linea.build"],
      webSocket: ["wss://rpc.goerli.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.lineascan.build",
      apiUrl: "https://goerli.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 498623
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lisk.js
var sourceId27 = 1;
var lisk = defineChain({
  ...chainConfig2,
  id: 1135,
  name: "Lisk",
  network: "lisk",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.api.lisk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.lisk.com",
      apiUrl: "https://blockscout.lisk.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xA9d71E1dd7ca26F26e656E66d6AA81ed7f745bf0"
    },
    l2OutputOracle: {
      [sourceId27]: {
        address: "0x113cB99283AF242Da0A0C54347667edF531Aa7d6"
      }
    },
    portal: {
      [sourceId27]: {
        address: "0x26dB93F8b8b4f7016240af62F7730979d353f9A7"
      }
    },
    l1StandardBridge: {
      [sourceId27]: {
        address: "0x2658723Bf70c7667De6B25F99fcce13A16D25d08"
      }
    }
  },
  sourceId: sourceId27
});

// node_modules/viem/_esm/chains/definitions/liskSepolia.js
var sourceId28 = 11155111;
var liskSepolia = defineChain({
  ...chainConfig2,
  id: 4202,
  network: "lisk-sepolia",
  name: "Lisk Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia-api.lisk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia-blockscout.lisk.com",
      apiUrl: "https://sepolia-blockscout.lisk.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId28]: {
        address: "0xA0E35F56C318DE1bD5D9ca6A94Fe7e37C5663348"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId28]: {
        address: "0xe3d90F21490686Ec7eF37BE788E02dfC12787264"
      }
    },
    l1StandardBridge: {
      [sourceId28]: {
        address: "0x1Fb30e446eA791cd1f011675E5F3f5311b70faF5"
      }
    }
  },
  testnet: true,
  sourceId: sourceId28
});

// node_modules/viem/_esm/chains/definitions/localhost.js
var localhost = defineChain({
  id: 1337,
  name: "Localhost",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
});

// node_modules/viem/_esm/chains/definitions/loop.js
var loop = defineChain({
  id: 15551,
  name: "LoopNetwork Mainnet",
  nativeCurrency: {
    name: "LOOP",
    symbol: "LOOP",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://api.mainnetloop.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "LoopNetwork Blockchain Explorer",
      url: "https://explorer.mainnetloop.com/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/lukso.js
var lukso = defineChain({
  id: 42,
  network: "lukso",
  name: "LUKSO",
  nativeCurrency: {
    name: "LUKSO",
    symbol: "LYX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.lukso.network"],
      webSocket: ["wss://ws-rpc.mainnet.lukso.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "LUKSO Mainnet Explorer",
      url: "https://explorer.execution.mainnet.lukso.network",
      apiUrl: "https://api.explorer.execution.mainnet.lukso.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 468183
    }
  }
});

// node_modules/viem/_esm/chains/definitions/luksoTestnet.js
var luksoTestnet = defineChain({
  id: 4201,
  name: "LUKSO Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "LUKSO Testnet",
    symbol: "LYXt"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.lukso.network"],
      webSocket: ["wss://ws-rpc.testnet.lukso.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "LUKSO Testnet Explorer",
      url: "https://explorer.execution.testnet.lukso.network",
      apiUrl: "https://api.explorer.execution.testnet.lukso.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 605348
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lumiaMainnet.js
var lumiaMainnet = defineChain({
  id: 994873017,
  name: "Lumia Mainnet",
  network: "LumiaMainnet",
  nativeCurrency: { name: "Lumia", symbol: "LUMIA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.lumia.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumia Explorer",
      url: "https://explorer.lumia.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3975939
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/lumiaTestnet.js
var lumiaTestnet = defineChain({
  id: 1952959480,
  name: "Lumia Testnet",
  network: "LumiaTestnet",
  nativeCurrency: {
    name: "Lumia",
    symbol: "LUMIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.lumia.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumia Testnet Explorer",
      url: "https://testnet-explorer.lumia.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2235063
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lumoz.js
var lumoz = defineChain({
  id: 96370,
  name: "Lumoz",
  nativeCurrency: {
    decimals: 18,
    name: "Lumoz Token",
    symbol: "MOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.lumoz.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumoz Scan",
      url: "https://scan.lumoz.info"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/lumozTestnet.js
var lumozTestnet = defineChain({
  id: 105363,
  name: "Lumoz Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Lumoz Testnet Token",
    symbol: "MOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.lumoz.org"]
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lycan.js
var lycan = defineChain({
  id: 721,
  name: "Lycan",
  nativeCurrency: {
    decimals: 18,
    name: "Lycan",
    symbol: "LYC"
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.lycanchain.com",
        "https://us-east.lycanchain.com",
        "https://us-west.lycanchain.com",
        "https://eu-north.lycanchain.com",
        "https://eu-west.lycanchain.com",
        "https://asia-southeast.lycanchain.com"
      ],
      webSocket: [
        "wss://rpc.lycanchain.com",
        "wss://us-east.lycanchain.com",
        "wss://us-west.lycanchain.com",
        "wss://eu-north.lycanchain.com",
        "wss://eu-west.lycanchain.com",
        "wss://asia-southeast.lycanchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Lycan Explorer",
      url: "https://explorer.lycanchain.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/lyra.js
var lyra = defineChain({
  id: 957,
  name: "Lyra Chain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.lyra.finance"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lyra Explorer",
      url: "https://explorer.lyra.finance",
      apiUrl: "https://explorer.lyra.finance/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1935198
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mainnet.js
var mainnet = defineChain({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth.merkle.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
      blockCreated: 19258213
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mandala.js
var mandala = defineChain({
  id: 595,
  name: "Mandala TC9",
  network: "mandala",
  nativeCurrency: {
    name: "Mandala",
    symbol: "mACA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-tc9.aca-staging.network"],
      webSocket: ["wss://eth-rpc-tc9.aca-staging.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mandala Blockscout",
      url: "https://blockscout.mandala.aca-staging.network",
      apiUrl: "https://blockscout.mandala.aca-staging.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/manta.js
var manta = defineChain({
  id: 169,
  name: "Manta Pacific Mainnet",
  network: "manta",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://pacific-rpc.manta.network/http"] }
  },
  blockExplorers: {
    default: {
      name: "Manta Explorer",
      url: "https://pacific-explorer.manta.network",
      apiUrl: "https://pacific-explorer.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 332890
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mantaSepoliaTestnet.js
var mantaSepoliaTestnet = defineChain({
  id: 3441006,
  name: "Manta Pacific Sepolia Testnet",
  network: "manta-sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://pacific-rpc.sepolia-testnet.manta.network/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Manta Sepolia Testnet Explorer",
      url: "https://pacific-explorer.sepolia-testnet.manta.network",
      apiUrl: "https://pacific-explorer.sepolia-testnet.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca54918f7B525C8df894668846506767412b53E3",
      blockCreated: 479584
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mantaTestnet.js
var mantaTestnet = defineChain({
  id: 3441005,
  name: "Manta Pacific Testnet",
  network: "manta-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://manta-testnet.calderachain.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Manta Testnet Explorer",
      url: "https://pacific-explorer.testnet.manta.network",
      apiUrl: "https://pacific-explorer.testnet.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x211B1643b95Fe76f11eD8880EE810ABD9A4cf56C",
      blockCreated: 419915
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mantle.js
var mantle = defineChain({
  id: 5e3,
  name: "Mantle",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Explorer",
      url: "https://mantlescan.xyz/",
      apiUrl: "https://api.mantlescan.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 304717
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mantleSepoliaTestnet.js
var mantleSepoliaTestnet = defineChain({
  id: 5003,
  name: "Mantle Sepolia Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.sepolia.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Testnet Explorer",
      url: "https://explorer.sepolia.mantle.xyz/",
      apiUrl: "https://explorer.sepolia.mantle.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4584012
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mantleTestnet.js
var mantleTestnet = defineChain({
  id: 5001,
  name: "Mantle Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Testnet Explorer",
      url: "https://explorer.testnet.mantle.xyz",
      apiUrl: "https://explorer.testnet.mantle.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 561333
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mapProtocol.js
var mapProtocol = defineChain({
  id: 22776,
  name: "MAP Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "MAPO",
    symbol: "MAPO"
  },
  rpcUrls: {
    default: { http: ["https://rpc.maplabs.io"] }
  },
  blockExplorers: {
    default: {
      name: "MAPO Scan",
      url: "https://maposcan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/matchain.js
var matchain = defineChain({
  id: 698,
  name: "Matchain",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.matchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Matchain Scan",
      url: "https://matchscan.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/matchainTestnet.js
var matchainTestnet = defineChain({
  id: 699,
  name: "Matchain Testnet",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://testnet-rpc.matchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Matchain Scan",
      url: "https://testnet.matchscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mchVerse.js
var mchVerse = defineChain({
  id: 29548,
  name: "MCH Verse",
  nativeCurrency: { name: "Oasys", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.oasys.mycryptoheroes.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MCH Verse Explorer",
      url: "https://explorer.oasys.mycryptoheroes.net",
      apiUrl: "https://explorer.oasys.mycryptoheroes.net/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/megaethTestnet.js
var megaethTestnet = defineChain({
  id: 6342,
  name: "MegaETH Testnet",
  nativeCurrency: {
    name: "MegaETH Testnet Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://carrot.megaeth.com/rpc"],
      webSocket: ["wss://carrot.megaeth.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "MegaETH Testnet Explorer",
      url: "https://www.megaexplorer.xyz/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mekong.js
var mekong = defineChain({
  id: 7078815900,
  name: "Mekong Pectra Devnet",
  nativeCurrency: { name: "eth", symbol: "eth", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mekong.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Block Explorer",
      url: "https://explorer.mekong.ethpandaops.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/meld.js
var meld = defineChain({
  id: 333000333,
  name: "Meld",
  nativeCurrency: {
    decimals: 18,
    name: "Meld",
    symbol: "MELD"
  },
  rpcUrls: {
    default: { http: ["https://rpc-1.meld.com"] }
  },
  blockExplorers: {
    default: { name: "MELDscan", url: "https://meldscan.io" }
  },
  contracts: {
    multicall3: {
      address: "0x769ee5a8e82c15c1b6e358f62ac8eb6e3abe8dc5",
      blockCreated: 360069
    }
  }
});

// node_modules/viem/_esm/chains/definitions/memecore.js
var memecore = defineChain({
  id: 4352,
  name: "MemeCore",
  nativeCurrency: {
    decimals: 18,
    name: "M",
    symbol: "M"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.memecore.net"],
      webSocket: ["wss://ws.memecore.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MemeCore Explorer",
      url: "https://memecorescan.io",
      apiUrl: "https://api.memecorescan.io/api"
    },
    okx: {
      name: "MemeCore Explorer",
      url: "https://web3.okx.com/explorer/memecore"
    },
    memecore: {
      name: "MemeCore Explorer",
      url: "https://blockscout.memecore.com",
      apiUrl: "https://blockscout.memecore.com/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/merlin.js
var merlin = defineChain({
  id: 4200,
  name: "Merlin",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.merlinchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://scan.merlinchain.io",
      apiUrl: "https://scan.merlinchain.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/merlinErigonTestnet.js
var merlinErigonTestnet = defineChain({
  id: 4203,
  name: "Merlin Erigon Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://testnet-erigon-rpc.merlinchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet-erigon-scan.merlinchain.io",
      apiUrl: "https://testnet-erigon-scan.merlinchain.io/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/metachain.js
var metachain = defineChain({
  id: 571,
  name: "MetaChain Mainnet",
  nativeCurrency: { name: "Metatime Coin", symbol: "MTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.metatime.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "MetaExplorer",
      url: "https://explorer.metatime.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0000000000000000000000000000000000003001",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/metachainIstanbul.js
var metachainIstanbul = defineChain({
  id: 1453,
  name: "MetaChain Istanbul",
  nativeCurrency: { name: "Metatime Coin", symbol: "MTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://istanbul-rpc.metachain.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "MetaExplorer",
      url: "https://istanbul-explorer.metachain.dev"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0000000000000000000000000000000000003001",
      blockCreated: 0
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/metadium.js
var metadium = defineChain({
  id: 11,
  name: "Metadium Network",
  nativeCurrency: {
    decimals: 18,
    name: "META",
    symbol: "META"
  },
  rpcUrls: {
    default: { http: ["https://api.metadium.com/prod"] }
  },
  blockExplorers: {
    default: {
      name: "Metadium Explorer",
      url: "https://explorer.metadium.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/metalL2.js
var sourceId29 = 1;
var metalL2 = defineChain({
  ...chainConfig2,
  id: 1750,
  name: "Metal L2",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.metall2.com"],
      webSocket: ["wss://rpc.metall2.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.metall2.com",
      apiUrl: "https://explorer.metall2.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId29]: {
        address: "0x3B1F7aDa0Fcc26B13515af752Dd07fB1CAc11426"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    portal: {
      [sourceId29]: {
        address: "0x3F37aBdE2C6b5B2ed6F8045787Df1ED1E3753956"
      }
    },
    l1StandardBridge: {
      [sourceId29]: {
        address: "0x6d0f65D59b55B0FEC5d2d15365154DcADC140BF3"
      }
    }
  },
  sourceId: sourceId29
});

// node_modules/viem/_esm/chains/definitions/meter.js
var meter = defineChain({
  id: 82,
  name: "Meter",
  nativeCurrency: {
    decimals: 18,
    name: "MTR",
    symbol: "MTR"
  },
  rpcUrls: {
    default: { http: ["https://rpc.meter.io"] }
  },
  blockExplorers: {
    default: {
      name: "MeterScan",
      url: "https://scan.meter.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/meterTestnet.js
var meterTestnet = defineChain({
  id: 83,
  name: "Meter Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MTR",
    symbol: "MTR"
  },
  rpcUrls: {
    default: { http: ["https://rpctest.meter.io"] }
  },
  blockExplorers: {
    default: {
      name: "MeterTestnetScan",
      url: "https://scan-warringstakes.meter.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/metis.js
var metis = defineChain({
  id: 1088,
  name: "Metis",
  nativeCurrency: {
    decimals: 18,
    name: "Metis",
    symbol: "METIS"
  },
  rpcUrls: {
    default: {
      http: [
        "https://metis.rpc.hypersync.xyz",
        "https://metis-pokt.nodies.app",
        "https://api.blockeden.xyz/metis/67nCBdZQSH9z3YqDDjdm",
        "https://metis-andromeda.rpc.thirdweb.com",
        "https://metis-andromeda.gateway.tenderly.co",
        "https://metis.api.onfinality.io/public",
        "https://andromeda.metis.io/?owner=1088",
        "https://metis-mainnet.public.blastapi.io"
      ],
      webSocket: ["wss://metis-rpc.publicnode.com", "wss://metis.drpc.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Metis Explorer",
      url: "https://explorer.metis.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/1088/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2338552
    }
  }
});

// node_modules/viem/_esm/chains/definitions/metisSepolia.js
var metisSepolia = defineChain({
  id: 59902,
  name: "Metis Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Test Metis",
    symbol: "tMETIS"
  },
  rpcUrls: {
    default: {
      http: [
        "https://sepolia.metisdevops.link",
        "https://metis-sepolia-rpc.publicnode.com",
        "https://metis-sepolia.gateway.tenderly.co"
      ],
      webSocket: ["wss://metis-sepolia-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Metis Sepolia Explorer",
      url: "https://sepolia-explorer.metisdevops.link",
      apiUrl: "https://sepolia-explorer.metisdevops.link/api-docs"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 224185
    }
  }
});

// node_modules/viem/_esm/chains/definitions/metisGoerli.js
var metisGoerli = defineChain({
  id: 599,
  name: "Metis Goerli",
  nativeCurrency: {
    decimals: 18,
    name: "Metis Goerli",
    symbol: "METIS"
  },
  rpcUrls: {
    default: { http: ["https://goerli.gateway.metisdevops.link"] }
  },
  blockExplorers: {
    default: {
      name: "Metis Goerli Explorer",
      url: "https://goerli.explorer.metisdevops.link",
      apiUrl: "https://goerli.explorer.metisdevops.link/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1006207
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mev.js
var mev = defineChain({
  id: 7518,
  name: "MEVerse Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "MEVerse",
    symbol: "MEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.meversemainnet.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://www.meversescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 86881340
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mevTestnet.js
var mevTestnet = defineChain({
  id: 4759,
  name: "MEVerse Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MEVerse",
    symbol: "MEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.meversetestnet.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://testnet.meversescan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 64371115
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mint.js
var mint = defineChain({
  id: 185,
  name: "Mint Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mintchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mintchain explorer",
      url: "https://explorer.mintchain.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/mintSepoliaTestnet.js
var mintSepoliaTestnet = defineChain({
  id: 1686,
  name: "Mint Sepolia Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.mintchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mintchain Testnet explorer",
      url: "https://testnet-explorer.mintchain.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mitosisTestnet.js
var mitosisTestnet = defineChain({
  id: 124832,
  name: "Mitosis Testnet",
  nativeCurrency: { name: "MITO", symbol: "MITO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.mitosis.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mitosis testnet explorer",
      url: "https://testnet.mitosiscan.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mode.js
var sourceId30 = 1;
var mode = defineChain({
  ...chainConfig2,
  id: 34443,
  name: "Mode Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.mode.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Modescan",
      url: "https://modescan.io"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2465882
    },
    l2OutputOracle: {
      [sourceId30]: {
        address: "0x4317ba146D4933D889518a3e5E11Fe7a53199b04"
      }
    },
    portal: {
      [sourceId30]: {
        address: "0x8B34b14c7c7123459Cf3076b8Cb929BE097d0C07"
      }
    },
    l1StandardBridge: {
      [sourceId30]: {
        address: "0x735aDBbE72226BD52e818E7181953f42E3b0FF21"
      }
    }
  },
  sourceId: sourceId30
});

// node_modules/viem/_esm/chains/definitions/modeTestnet.js
var sourceId31 = 11155111;
var modeTestnet = defineChain({
  ...chainConfig2,
  id: 919,
  name: "Mode Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.mode.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia.explorer.mode.network",
      apiUrl: "https://sepolia.explorer.mode.network/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId31]: {
        address: "0x2634BD65ba27AB63811c74A63118ACb312701Bfa",
        blockCreated: 3778393
      }
    },
    portal: {
      [sourceId31]: {
        address: "0x320e1580effF37E008F1C92700d1eBa47c1B23fD",
        blockCreated: 3778395
      }
    },
    l1StandardBridge: {
      [sourceId31]: {
        address: "0xbC5C679879B2965296756CD959C3C739769995E2",
        blockCreated: 3778392
      }
    },
    multicall3: {
      address: "0xBAba8373113Fb7a68f195deF18732e01aF8eDfCF",
      blockCreated: 3019007
    }
  },
  testnet: true,
  sourceId: sourceId31
});

// node_modules/viem/_esm/chains/definitions/monadTestnet.js
var monadTestnet = defineChain({
  id: 10143,
  name: "Monad Testnet",
  nativeCurrency: {
    name: "Testnet MON Token",
    symbol: "MON",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.monad.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Monad Testnet explorer",
      url: "https://testnet.monadexplorer.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 251449
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/moonbaseAlpha.js
var moonbaseAlpha = defineChain({
  id: 1287,
  name: "Moonbase Alpha",
  nativeCurrency: {
    decimals: 18,
    name: "DEV",
    symbol: "DEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.api.moonbase.moonbeam.network"],
      webSocket: ["wss://wss.api.moonbase.moonbeam.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonbase.moonscan.io",
      apiUrl: "https://moonbase.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1850686
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/moonbeam.js
var moonbeam = defineChain({
  id: 1284,
  name: "Moonbeam",
  nativeCurrency: {
    decimals: 18,
    name: "GLMR",
    symbol: "GLMR"
  },
  rpcUrls: {
    default: {
      http: ["https://moonbeam.public.blastapi.io"],
      webSocket: ["wss://moonbeam.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonscan.io",
      apiUrl: "https://api-moonbeam.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 609002
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/moonbeamDev.js
var moonbeamDev = defineChain({
  id: 1281,
  name: "Moonbeam Development Node",
  nativeCurrency: {
    decimals: 18,
    name: "DEV",
    symbol: "DEV"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:9944"],
      webSocket: ["wss://127.0.0.1:9944"]
    }
  }
});

// node_modules/viem/_esm/chains/definitions/moonriver.js
var moonriver = defineChain({
  id: 1285,
  name: "Moonriver",
  nativeCurrency: {
    decimals: 18,
    name: "MOVR",
    symbol: "MOVR"
  },
  rpcUrls: {
    default: {
      http: ["https://moonriver.public.blastapi.io"],
      webSocket: ["wss://moonriver.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonriver.moonscan.io",
      apiUrl: "https://api-moonriver.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1597904
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/morph.js
var morph = defineChain({
  id: 2818,
  name: "Morph",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.morphl2.io"],
      webSocket: ["wss://rpc.morphl2.io:8443"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Explorer",
      url: "https://explorer.morphl2.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/morphHolesky.js
var morphHolesky = defineChain({
  id: 2810,
  name: "Morph Holesky",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-quicknode-holesky.morphl2.io"],
      webSocket: ["wss://rpc-quicknode-holesky.morphl2.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Holesky Explorer",
      url: "https://explorer-holesky.morphl2.io",
      apiUrl: "https://explorer-api-holesky.morphl2.io/api?"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/morphSepolia.js
var morphSepolia = defineChain({
  id: 2710,
  name: "Morph Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.morphl2.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Testnet Explorer",
      url: "https://explorer-testnet.morphl2.io",
      apiUrl: "https://explorer-api-testnet.morphl2.io/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/nahmii.js
var nahmii = defineChain({
  id: 5551,
  name: "Nahmii 2 Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://l2.nahmii.io"] }
  },
  blockExplorers: {
    default: {
      name: "Nahmii 2 Explorer",
      url: "https://explorer.n2.nahmii.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/nautilus.js
var nautilus = defineChain({
  id: 22222,
  name: "Nautilus Mainnet",
  nativeCurrency: { name: "ZBC", symbol: "ZBC", decimals: 9 },
  rpcUrls: {
    default: {
      http: ["https://api.nautilus.nautchain.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "NautScan",
      url: "https://nautscan.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/near.js
var near = defineChain({
  id: 397,
  name: "NEAR Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "NEAR",
    symbol: "NEAR"
  },
  rpcUrls: {
    default: { http: ["https://eth-rpc.mainnet.near.org"] }
  },
  blockExplorers: {
    default: {
      name: "NEAR Explorer",
      url: "https://eth-explorer.near.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/nearTestnet.js
var nearTestnet = defineChain({
  id: 398,
  name: "NEAR Protocol Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "NEAR",
    symbol: "NEAR"
  },
  rpcUrls: {
    default: { http: ["https://eth-rpc.testnet.near.org"] }
  },
  blockExplorers: {
    default: {
      name: "NEAR Explorer",
      url: "https://eth-explorer-testnet.near.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/neonDevnet.js
var neonDevnet = defineChain({
  id: 245022926,
  name: "Neon EVM DevNet",
  nativeCurrency: { name: "NEON", symbol: "NEON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://devnet.neonevm.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Neonscan",
      url: "https://devnet.neonscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 205206112
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/neonMainnet.js
var neonMainnet = defineChain({
  id: 245022934,
  network: "neonMainnet",
  name: "Neon EVM MainNet",
  nativeCurrency: { name: "NEON", symbol: "NEON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://neon-proxy-mainnet.solana.p2p.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Neonscan",
      url: "https://neonscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 206545524
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/neoxMainnet.js
var neoxMainnet = defineChain({
  id: 47763,
  name: "Neo X Mainnet",
  nativeCurrency: { name: "Gas", symbol: "GAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://mainnet-1.rpc.banelabs.org",
        "https://mainnet-2.rpc.banelabs.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Neo X - Explorer",
      url: "https://xexplorer.neo.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/neoxT4.js
var neoxT4 = defineChain({
  id: 12227332,
  name: "Neo X Testnet T4",
  nativeCurrency: { name: "Gas", symbol: "GAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.banelabs.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "neox-scan",
      url: "https://xt4scan.ngd.network"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/newton.js
var newton = defineChain({
  id: 1012,
  name: "Newton",
  nativeCurrency: {
    name: "Newton",
    symbol: "NEW",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://global.rpc.mainnet.newtonproject.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "NewFi explorer",
      url: "https://explorer.newtonproject.org/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/nexi.js
var nexi = defineChain({
  id: 4242,
  name: "Nexi",
  nativeCurrency: { name: "Nexi", symbol: "NEXI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.chain.nexi.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "NexiScan",
      url: "https://www.nexiscan.com",
      apiUrl: "https://www.nexiscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0277A46Cc69A57eE3A6C8c158bA874832F718B8E",
      blockCreated: 25770160
    }
  }
});

// node_modules/viem/_esm/chains/definitions/nexilix.js
var nexilix = defineChain({
  id: 240,
  name: "Nexilix Smart Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Nexilix",
    symbol: "NEXILIX"
  },
  rpcUrls: {
    default: { http: ["https://rpcurl.pos.nexilix.com"] }
  },
  blockExplorers: {
    default: {
      name: "NexilixScan",
      url: "https://scan.nexilix.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x58381c8e2BF9d0C2C4259cA14BdA9Afe02831244",
      blockCreated: 74448
    }
  }
});

// node_modules/viem/_esm/chains/definitions/nibiru.js
var nibiru = defineChain({
  id: 6900,
  name: "Nibiru",
  nativeCurrency: {
    decimals: 18,
    name: "NIBI",
    symbol: "NIBI"
  },
  rpcUrls: {
    default: { http: ["https://evm-rpc.nibiru.fi"] }
  },
  blockExplorers: {
    default: {
      name: "NibiScan",
      url: "https://nibiscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 19587573
    }
  }
});

// node_modules/viem/_esm/chains/definitions/oasisTestnet.js
var oasisTestnet = defineChain({
  id: 4090,
  network: "oasis-testnet",
  name: "Oasis Testnet",
  nativeCurrency: { name: "Fasttoken", symbol: "FTN", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc1.oasis.bahamutchain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Ftnscan",
      url: "https://oasis.ftnscan.com",
      apiUrl: "https://oasis.ftnscan.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/oasys.js
var oasys = defineChain({
  id: 248,
  name: "Oasys",
  nativeCurrency: { name: "Oasys", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.oasys.games"]
    }
  },
  blockExplorers: {
    default: {
      name: "OasysScan",
      url: "https://scan.oasys.games",
      apiUrl: "https://scan.oasys.games/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/odysseyTestnet.js
var odysseyTestnet = defineChain({
  id: 911867,
  name: "Odyssey Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://odyssey.ithaca.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Odyssey Explorer",
      url: "https://odyssey-explorer.ithaca.xyz",
      apiUrl: "https://odyssey-explorer.ithaca.xyz/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/okc.js
var okc = defineChain({
  id: 66,
  name: "OKC",
  nativeCurrency: {
    decimals: 18,
    name: "OKT",
    symbol: "OKT"
  },
  rpcUrls: {
    default: { http: ["https://exchainrpc.okex.org"] }
  },
  blockExplorers: {
    default: {
      name: "oklink",
      url: "https://www.oklink.com/okc"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10364792
    }
  }
});

// node_modules/viem/_esm/chains/definitions/omax.js
var omax = defineChain({
  id: 311,
  name: "Omax Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OMAX",
    symbol: "OMAX"
  },
  rpcUrls: {
    default: { http: ["https://mainapi.omaxray.com"] }
  },
  blockExplorers: {
    default: {
      name: "Omax Explorer",
      url: "https://omaxscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/oneWorld.js
var oneWorld = defineChain({
  id: 309075,
  name: "One World Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OWCT",
    symbol: "OWCT"
  },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.oneworldchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "One World Explorer",
      url: "https://mainnet.oneworldchain.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/oortmainnetDev.js
var oortMainnetDev = defineChain({
  id: 9700,
  name: "OORT MainnetDev",
  nativeCurrency: {
    decimals: 18,
    name: "OORT",
    symbol: "OORT"
  },
  rpcUrls: {
    default: { http: ["https://dev-rpc.oortech.com"] }
  },
  blockExplorers: {
    default: {
      name: "OORT MainnetDev Explorer",
      url: "https://dev-scan.oortech.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/opBNB.js
var sourceId32 = 56;
var opBNB = defineChain({
  id: 204,
  name: "opBNB",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://opbnb-mainnet-rpc.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "opBNB (BSCScan)",
      url: "https://opbnb.bscscan.com",
      apiUrl: "https://api-opbnb.bscscan.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 512881
    },
    l2OutputOracle: {
      [sourceId32]: {
        address: "0x153CAB79f4767E2ff862C94aa49573294B13D169"
      }
    },
    portal: {
      [sourceId32]: {
        address: "0x1876EA7702C0ad0C6A2ae6036DE7733edfBca519"
      }
    },
    l1StandardBridge: {
      [sourceId32]: {
        address: "0xF05F0e4362859c3331Cb9395CBC201E3Fa6757Ea"
      }
    }
  },
  sourceId: sourceId32
});

// node_modules/viem/_esm/chains/definitions/opBNBTestnet.js
var sourceId33 = 97;
var opBNBTestnet = defineChain({
  id: 5611,
  name: "opBNB Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tBNB",
    symbol: "tBNB"
  },
  rpcUrls: {
    default: { http: ["https://opbnb-testnet-rpc.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "opbnbscan",
      url: "https://testnet.opbnbscan.com"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3705108
    },
    l2OutputOracle: {
      [sourceId33]: {
        address: "0xFf2394Bb843012562f4349C6632a0EcB92fC8810"
      }
    },
    portal: {
      [sourceId33]: {
        address: "0x4386C8ABf2009aC0c263462Da568DD9d46e52a31"
      }
    },
    l1StandardBridge: {
      [sourceId33]: {
        address: "0x677311Fd2cCc511Bbc0f581E8d9a07B033D5E840"
      }
    }
  },
  testnet: true,
  sourceId: sourceId33
});

// node_modules/viem/_esm/chains/definitions/optimism.js
var sourceId34 = 1;
var optimism = defineChain({
  ...chainConfig2,
  id: 10,
  name: "OP Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Optimism Explorer",
      url: "https://optimistic.etherscan.io",
      apiUrl: "https://api-optimistic.etherscan.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId34]: {
        address: "0xe5965Ab5962eDc7477C8520243A95517CD252fA9"
      }
    },
    l2OutputOracle: {
      [sourceId34]: {
        address: "0xdfe97868233d1aa22e815a266982f2cf17685a27"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4286263
    },
    portal: {
      [sourceId34]: {
        address: "0xbEb5Fc579115071764c7423A4f12eDde41f106Ed"
      }
    },
    l1StandardBridge: {
      [sourceId34]: {
        address: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"
      }
    }
  },
  sourceId: sourceId34
});

// node_modules/viem/_esm/chains/definitions/optimismGoerli.js
var sourceId35 = 5;
var optimismGoerli = defineChain({
  ...chainConfig2,
  id: 420,
  name: "Optimism Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://goerli.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli-optimism.etherscan.io",
      apiUrl: "https://goerli-optimism.etherscan.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId35]: {
        address: "0xE6Dfba0953616Bacab0c9A8ecb3a9BBa77FC15c0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 49461
    },
    portal: {
      [sourceId35]: {
        address: "0x5b47E1A08Ea6d985D6649300584e6722Ec4B1383"
      }
    },
    l1StandardBridge: {
      [sourceId35]: {
        address: "0x636Af16bf2f682dD3109e60102b8E1A089FedAa8"
      }
    }
  },
  testnet: true,
  sourceId: sourceId35
});

// node_modules/viem/_esm/chains/definitions/optimismSepolia.js
var sourceId36 = 11155111;
var optimismSepolia = defineChain({
  ...chainConfig2,
  id: 11155420,
  name: "OP Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://optimism-sepolia.blockscout.com",
      apiUrl: "https://optimism-sepolia.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId36]: {
        address: "0x05F9613aDB30026FFd634f38e5C4dFd30a197Fa1"
      }
    },
    l2OutputOracle: {
      [sourceId36]: {
        address: "0x90E9c4f8a994a250F6aEfd61CAFb4F2e895D458F"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1620204
    },
    portal: {
      [sourceId36]: {
        address: "0x16Fc5058F25648194471939df75CF27A2fdC48BC"
      }
    },
    l1StandardBridge: {
      [sourceId36]: {
        address: "0xFBb0621E0B23b5478B630BD55a5f21f67730B0F1"
      }
    }
  },
  testnet: true,
  sourceId: sourceId36
});

// node_modules/viem/_esm/chains/definitions/optopia.js
var optopia = defineChain({
  id: 62050,
  name: "Optopia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet.optopia.ai"] }
  },
  blockExplorers: {
    default: {
      name: "Optopia Explorer",
      url: "https://scan.optopia.ai"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/optopiaTestnet.js
var optopiaTestnet = defineChain({
  id: 62049,
  name: "Optopia Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-testnet.optopia.ai"] }
  },
  blockExplorers: {
    default: {
      name: "Optopia Explorer",
      url: "https://scan-testnet.optopia.ai"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/orderly.js
var orderly = defineChain({
  id: 291,
  name: "Orderly",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.orderly.network"] }
  },
  blockExplorers: {
    default: {
      name: "Orderly Explorer",
      url: "https://explorer.orderly.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/orderlySepolia.js
var orderlySepolia = defineChain({
  id: 4460,
  name: "Orderly Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://l2-orderly-l2-4460-sepolia-8tc3sd7dvy.t.conduit.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Orderly Explorer",
      url: "https://explorerl2new-orderly-l2-4460-sepolia-8tc3sd7dvy.t.conduit.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/otimDevnet.js
var otimDevnet = defineChain({
  id: 41144114,
  name: "Otim Devnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://devnet.otim.xyz"]
    }
  },
  contracts: {
    batchInvoker: {
      address: "0x5FbDB2315678afecb367f032d93F642f64180aa3"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/palm.js
var palm = defineChain({
  id: 11297108109,
  name: "Palm",
  nativeCurrency: {
    decimals: 18,
    name: "PALM",
    symbol: "PALM"
  },
  rpcUrls: {
    default: {
      http: ["https://palm-mainnet.public.blastapi.io"],
      webSocket: ["wss://palm-mainnet.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chainlens",
      url: "https://palm.chainlens.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15429248
    }
  }
});

// node_modules/viem/_esm/chains/definitions/palmTestnet.js
var palmTestnet = defineChain({
  id: 11297108099,
  name: "Palm Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "PALM",
    symbol: "PALM"
  },
  rpcUrls: {
    default: {
      http: ["https://palm-mainnet.public.blastapi.io"],
      webSocket: ["wss://palm-mainnet.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chainlens",
      url: "https://palm.chainlens.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15429248
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/peaq.js
var peaq = defineChain({
  id: 3338,
  name: "Peaq",
  nativeCurrency: {
    decimals: 18,
    name: "peaq",
    symbol: "PEAQ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://peaq-rpc.publicnode.com",
        "https://peaq.api.onfinality.io/public",
        "https://peaq-rpc.dwellir.com",
        "https://evm.peaq.network"
      ],
      webSocket: [
        "wss://peaq-rpc.publicnode.com",
        "wss://peaq.api.onfinality.io/public",
        "wss://peaq-rpc.dwellir.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Subscan",
      url: "https://peaq.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3566354
    }
  }
});

// node_modules/viem/_esm/chains/definitions/pgn.js
var sourceId37 = 1;
var pgn = defineChain({
  id: 424,
  network: "pgn",
  name: "PGN",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.publicgoods.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "PGN Explorer",
      url: "https://explorer.publicgoods.network",
      apiUrl: "https://explorer.publicgoods.network/api"
    }
  },
  contracts: {
    l2OutputOracle: {
      [sourceId37]: {
        address: "0x9E6204F750cD866b299594e2aC9eA824E2e5f95c"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3380209
    },
    portal: {
      [sourceId37]: {
        address: "0xb26Fd985c5959bBB382BAFdD0b879E149e48116c"
      }
    },
    l1StandardBridge: {
      [sourceId37]: {
        address: "0xD0204B9527C1bA7bD765Fa5CCD9355d38338272b"
      }
    }
  },
  formatters: formatters2,
  sourceId: sourceId37
});

// node_modules/viem/_esm/chains/definitions/pgnTestnet.js
var sourceId38 = 11155111;
var pgnTestnet = defineChain({
  id: 58008,
  network: "pgn-testnet",
  name: "PGN ",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.publicgoods.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "PGN Testnet Explorer",
      url: "https://explorer.sepolia.publicgoods.network",
      apiUrl: "https://explorer.sepolia.publicgoods.network/api"
    }
  },
  contracts: {
    l2OutputOracle: {
      [sourceId38]: {
        address: "0xD5bAc3152ffC25318F848B3DD5dA6C85171BaEEe"
      }
    },
    portal: {
      [sourceId38]: {
        address: "0xF04BdD5353Bb0EFF6CA60CfcC78594278eBfE179"
      }
    },
    l1StandardBridge: {
      [sourceId38]: {
        address: "0xFaE6abCAF30D23e233AC7faF747F2fC3a5a6Bfa3"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3754925
    }
  },
  formatters: formatters2,
  sourceId: sourceId38,
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/phoenix.js
var phoenix = defineChain({
  id: 13381,
  name: "Phoenix Blockchain",
  nativeCurrency: { name: "Phoenix", symbol: "PHX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.phoenixplorer.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Phoenixplorer",
      url: "https://phoenixplorer.com",
      apiUrl: "https://phoenixplorer.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x498cF757a575cFF2c2Ed9f532f56Efa797f86442",
      blockCreated: 5620192
    }
  }
});

// node_modules/viem/_esm/chains/definitions/planq.js
var planq = defineChain({
  id: 7070,
  name: "Planq Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "PLQ",
    symbol: "PLQ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://planq-rpc.nodies.app",
        "https://evm-rpc.planq.network",
        "https://jsonrpc.planq.nodestake.top"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Planq Explorer",
      url: "https://evm.planq.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 8470015
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/playfiAlbireo.js
var playfiAlbireo = defineChain({
  ...chainConfig,
  id: 1612127,
  name: "PlayFi Albireo Testnet",
  network: "albireo",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://albireo-rpc.playfi.ai"],
      webSocket: ["wss://albireo-rpc-ws.playfi.ai/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "PlayFi Albireo Explorer",
      url: "https://albireo-explorer.playfi.ai"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/plinga.js
var plinga = defineChain({
  id: 242,
  name: "Plinga",
  nativeCurrency: { name: "Plinga", symbol: "PLINGA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpcurl.mainnet.plgchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Plgscan",
      url: "https://www.plgscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0989576160f2e7092908BB9479631b901060b6e4",
      blockCreated: 204489
    }
  }
});

// node_modules/viem/_esm/chains/definitions/plume.js
var sourceId39 = 1;
var plume = defineChain({
  id: 98865,
  name: "Plume (Legacy)",
  nativeCurrency: {
    name: "Plume Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.plumenetwork.xyz"],
      webSocket: ["wss://rpc.plumenetwork.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.plumenetwork.xyz",
      apiUrl: "https://explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 48577
    }
  },
  sourceId: sourceId39
});

// node_modules/viem/_esm/chains/definitions/plumeDevnet.js
var sourceId40 = 11155111;
var plumeDevnet = defineChain({
  id: 98864,
  name: "Plume Devnet (Legacy)",
  nativeCurrency: {
    name: "Plume Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://test-rpc.plumenetwork.xyz"],
      webSocket: ["wss://test-rpc.plumenetwork.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://test-explorer.plumenetwork.xyz",
      apiUrl: "https://test-explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 481948
    }
  },
  testnet: true,
  sourceId: sourceId40
});

// node_modules/viem/_esm/chains/definitions/plumeMainnet.js
var sourceId41 = 1;
var plumeMainnet = defineChain({
  id: 98866,
  name: "Plume",
  nativeCurrency: {
    name: "Plume",
    symbol: "PLUME",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.plume.org"],
      webSocket: ["wss://rpc.plume.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.plume.org",
      apiUrl: "https://explorer.plume.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 39679
    }
  },
  sourceId: sourceId41
});

// node_modules/viem/_esm/chains/definitions/plumeSepolia.js
var sourceId42 = 11155111;
var plumeSepolia = defineChain({
  id: 98867,
  name: "Plume Testnet",
  nativeCurrency: {
    name: "Plume",
    symbol: "PLUME",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.plume.org"],
      webSocket: ["wss://testnet-rpc.plume.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.plume.org",
      apiUrl: "https://testnet-explorer.plume.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 199712
    }
  },
  testnet: true,
  sourceId: sourceId42
});

// node_modules/viem/_esm/chains/definitions/plumeTestnet.js
var sourceId43 = 11155111;
var plumeTestnet = defineChain({
  id: 161221135,
  name: "Plume Testnet (Legacy)",
  nativeCurrency: {
    name: "Plume Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.plumenetwork.xyz/http"],
      webSocket: ["wss://testnet-rpc.plumenetwork.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.plumenetwork.xyz",
      apiUrl: "https://testnet-explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 6022332
    }
  },
  testnet: true,
  sourceId: sourceId43
});

// node_modules/viem/_esm/chains/definitions/polterTestnet.js
var polterTestnet = defineChain({
  id: 631571,
  name: "Polter Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Polter GHST",
    symbol: "GHST"
  },
  rpcUrls: {
    default: {
      http: ["https://geist-polter.g.alchemy.com/public"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://polter-testnet.explorer.alchemy.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11245
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/polygon.js
var polygon = defineChain({
  id: 137,
  name: "Polygon",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://polygon-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://polygonscan.com",
      apiUrl: "https://api.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polygonAmoy.js
var polygonAmoy = defineChain({
  id: 80002,
  name: "Polygon Amoy",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-amoy.polygon.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://amoy.polygonscan.com",
      apiUrl: "https://api-amoy.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3127388
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/polygonMumbai.js
var polygonMumbai = defineChain({
  id: 80001,
  name: "Polygon Mumbai",
  nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://80001.rpc.thirdweb.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://mumbai.polygonscan.com",
      apiUrl: "https://api-testnet.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/polygonZkEvm.js
var polygonZkEvm = defineChain({
  id: 1101,
  name: "Polygon zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://zkevm-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://zkevm.polygonscan.com",
      apiUrl: "https://api-zkevm.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 57746
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polygonZkEvmCardona.js
var polygonZkEvmCardona = defineChain({
  id: 2442,
  name: "Polygon zkEVM Cardona",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.cardona.zkevm-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://cardona-zkevm.polygonscan.com",
      apiUrl: "https://cardona-zkevm.polygonscan.com/api"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 114091
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polygonZkEvmTestnet.js
var polygonZkEvmTestnet = defineChain({
  id: 1442,
  name: "Polygon zkEVM Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.public.zkevm-test.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://testnet-zkevm.polygonscan.com",
      apiUrl: "https://testnet-zkevm.polygonscan.com/api"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 525686
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polynomial.js
var polynomial = defineChain({
  id: 8008,
  name: "Polynomial",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.polynomial.fi"]
    }
  },
  blockExplorers: {
    default: {
      name: "Polynomial Scan",
      url: "https://polynomialscan.io"
    }
  },
  testnet: false,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polynomialSepolia.js
var polynomialSepolia = defineChain({
  id: 80008,
  name: "Polynomia Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia.polynomial.fi"]
    }
  },
  blockExplorers: {
    default: {
      name: "Polynomial Scan",
      url: "https://sepolia.polynomialscan.io"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/premiumBlock.js
var premiumBlockTestnet = defineChain({
  id: 23023,
  name: "PremiumBlock Testnet",
  nativeCurrency: { name: "Premium Block", symbol: "PBLK", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.premiumblock.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "PremiumBlocks Explorer",
      url: "https://scan.premiumblock.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/pulsechain.js
var pulsechain = defineChain({
  id: 369,
  name: "PulseChain",
  nativeCurrency: { name: "Pulse", symbol: "PLS", decimals: 18 },
  testnet: false,
  rpcUrls: {
    default: {
      http: ["https://rpc.pulsechain.com"],
      webSocket: ["wss://ws.pulsechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PulseScan",
      url: "https://scan.pulsechain.com",
      apiUrl: "https://api.scan.pulsechain.com/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});

// node_modules/viem/_esm/chains/definitions/pulsechainV4.js
var pulsechainV4 = defineChain({
  id: 943,
  name: "PulseChain V4",
  testnet: true,
  nativeCurrency: { name: "V4 Pulse", symbol: "v4PLS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.v4.testnet.pulsechain.com"],
      webSocket: ["wss://ws.v4.testnet.pulsechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PulseScan",
      url: "https://scan.v4.testnet.pulsechain.com",
      apiUrl: "https://scan.v4.testnet.pulsechain.com/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});

// node_modules/viem/_esm/chains/definitions/pumpfiTestnet.js
var pumpfiTestnet = defineChain({
  id: 490092,
  name: "Pumpfi Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "PMPT",
    symbol: "PMPT"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc1testnet.pumpfi.me"]
    }
  },
  blockExplorers: {
    default: {
      name: "Pumpfi Testnet Scan",
      url: "https://testnetscan.pumpfi.me"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/pyrope.js
var sourceId44 = 11155111;
var pyrope = defineChain({
  ...chainConfig2,
  name: "Pyrope Testnet",
  testnet: true,
  id: 695569,
  sourceId: sourceId44,
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.pyropechain.com"],
      webSocket: ["wss://rpc.pyropechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://pyrope.blockscout.com"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l1StandardBridge: {
      [sourceId44]: {
        address: "0xC24932c31D9621aE9e792576152B7ef010cFC2F8"
      }
    }
  }
});

// node_modules/viem/_esm/chains/definitions/ql1.js
var ql1 = defineChain({
  id: 766,
  name: "QL1",
  nativeCurrency: {
    decimals: 18,
    name: "QOM",
    symbol: "QOM"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.qom.one"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ql1 Explorer",
      url: "https://scan.qom.one"
    }
  },
  contracts: {
    multicall3: {
      address: "0x7A52370716ea730585884F5BDB0f6E60C39b8C64"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/qMainnet.js
var qMainnet = defineChain({
  id: 35441,
  name: "Q Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Q",
    symbol: "Q"
  },
  rpcUrls: {
    default: { http: ["https://rpc.q.org"] }
  },
  blockExplorers: {
    default: {
      name: "Q Mainnet Explorer",
      url: "https://explorer.q.org",
      apiUrl: "https://explorer.q.org/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/qTestnet.js
var qTestnet = defineChain({
  id: 35443,
  name: "Q Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Q",
    symbol: "Q"
  },
  rpcUrls: {
    default: { http: ["https://rpc.qtestnet.org"] }
  },
  blockExplorers: {
    default: {
      name: "Q Testnet Explorer",
      url: "https://explorer.qtestnet.org",
      apiUrl: "https://explorer.qtestnet.org/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/real.js
var real = defineChain({
  id: 111188,
  name: "re.al",
  nativeCurrency: {
    name: "reETH",
    decimals: 18,
    symbol: "reETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.realforreal.gelato.digital"] }
  },
  blockExplorers: {
    default: {
      name: "re.al Explorer",
      url: "https://explorer.re.al",
      apiUrl: "https://explorer.re.al/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 695
    }
  }
});

// node_modules/viem/_esm/chains/definitions/redbellyMainnet.js
var redbellyMainnet = defineChain({
  id: 151,
  name: "Redbelly Network Mainnet",
  nativeCurrency: {
    name: "Redbelly Native Coin",
    symbol: "RBNT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://governors.mainnet.redbelly.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Routescan",
      url: "https://redbelly.routescan.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/151/etherscan/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/redbellyTestnet.js
var redbellyTestnet = defineChain({
  id: 153,
  name: "Redbelly Network Testnet",
  nativeCurrency: {
    name: "Redbelly Native Coin",
    symbol: "RBNT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://governors.testnet.redbelly.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Routescan",
      url: "https://redbelly.testnet.routescan.io",
      apiUrl: "https://api.routescan.io/v2/network/testnet/evm/153_2/etherscan/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/redstone.js
var sourceId45 = 1;
var redstone = defineChain({
  ...chainConfig2,
  name: "Redstone",
  id: 690,
  sourceId: sourceId45,
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.redstonechain.com"],
      webSocket: ["wss://rpc.redstonechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.redstone.xyz"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId45]: {
        address: "0xC7bCb0e8839a28A1cFadd1CF716de9016CdA51ae",
        blockCreated: 19578329
      }
    },
    l2OutputOracle: {
      [sourceId45]: {
        address: "0xa426A052f657AEEefc298b3B5c35a470e4739d69",
        blockCreated: 19578337
      }
    },
    l1StandardBridge: {
      [sourceId45]: {
        address: "0xc473ca7E02af24c129c2eEf51F2aDf0411c1Df69",
        blockCreated: 19578331
      }
    }
  }
});

// node_modules/viem/_esm/chains/definitions/rei.js
var rei = defineChain({
  id: 47805,
  name: "REI Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "REI",
    symbol: "REI"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.rei.network"],
      webSocket: ["wss://rpc.rei.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "REI Scan",
      url: "https://scan.rei.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/reyaNetwork.js
var reyaNetwork = defineChain({
  id: 1729,
  name: "Reya Network",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.reya.network"],
      webSocket: ["wss://ws.reya.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Reya Network Explorer",
      url: "https://explorer.reya.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/reddioSepolia.js
var reddioSepolia = defineChain({
  id: 50341,
  name: "Reddio Sepolia",
  nativeCurrency: { name: "Reddio", symbol: "RED", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://reddio-dev.reddio.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Reddioscan",
      url: "https://reddio-devnet.l2scan.co",
      apiUrl: "https://reddio-devnet.l2scan.co/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/rivalz.js
var rivalz = defineChain({
  id: 753,
  name: "Rivalz",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rivalz.calderachain.xyz/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rivalz Caldera Explorer",
      url: "https://rivalz.calderaexplorer.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/rollux.js
var rollux = defineChain({
  id: 570,
  name: "Rollux Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.rollux.com"],
      webSocket: ["wss://rpc.rollux.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "RolluxExplorer",
      url: "https://explorer.rollux.com",
      apiUrl: "https://explorer.rollux.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 119222
    }
  }
});

// node_modules/viem/_esm/chains/definitions/rolluxTestnet.js
var rolluxTestnet = defineChain({
  id: 57e3,
  name: "Rollux Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-tanenbaum.rollux.com/"],
      webSocket: ["wss://rpc-tanenbaum.rollux.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "RolluxTestnetExplorer",
      url: "https://rollux.tanenbaum.io",
      apiUrl: "https://rollux.tanenbaum.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1813675
    }
  }
});

// node_modules/viem/_esm/chains/definitions/ronin.js
var ronin = defineChain({
  id: 2020,
  name: "Ronin",
  nativeCurrency: { name: "RON", symbol: "RON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.roninchain.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ronin Explorer",
      url: "https://app.roninchain.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 26023535
    }
  }
});

// node_modules/viem/_esm/chains/definitions/root.js
var root = defineChain({
  id: 7668,
  name: "The Root Network",
  nativeCurrency: {
    decimals: 18,
    name: "XRP",
    symbol: "XRP"
  },
  rpcUrls: {
    default: {
      http: ["https://root.rootnet.live/archive"],
      webSocket: ["wss://root.rootnet.live/archive/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rootscan",
      url: "https://rootscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc9C2E2429AeC354916c476B30d729deDdC94988d",
      blockCreated: 9218338
    }
  }
});

// node_modules/viem/_esm/chains/definitions/rootPorcini.js
var rootPorcini = defineChain({
  id: 7672,
  name: "The Root Network - Porcini",
  nativeCurrency: {
    decimals: 18,
    name: "XRP",
    symbol: "XRP"
  },
  rpcUrls: {
    default: {
      http: ["https://porcini.rootnet.app/archive"],
      webSocket: ["wss://porcini.rootnet.app/archive/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rootscan",
      url: "https://porcini.rootscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc9C2E2429AeC354916c476B30d729deDdC94988d",
      blockCreated: 10555692
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/rootstock.js
var rootstock = defineChain({
  id: 30,
  name: "Rootstock Mainnet",
  network: "rootstock",
  nativeCurrency: {
    decimals: 18,
    name: "Rootstock Bitcoin",
    symbol: "RBTC"
  },
  rpcUrls: {
    default: { http: ["https://public-node.rsk.co"] }
  },
  blockExplorers: {
    default: {
      name: "RSK Explorer",
      url: "https://explorer.rsk.co"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4249540
    }
  }
});

// node_modules/viem/_esm/chains/definitions/rootstockTestnet.js
var rootstockTestnet = defineChain({
  id: 31,
  name: "Rootstock Testnet",
  network: "rootstock",
  nativeCurrency: {
    decimals: 18,
    name: "Rootstock Bitcoin",
    symbol: "tRBTC"
  },
  rpcUrls: {
    default: { http: ["https://public-node.testnet.rsk.co"] }
  },
  blockExplorers: {
    default: {
      name: "RSK Explorer",
      url: "https://explorer.testnet.rootstock.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2771150
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/rss3.js
var sourceId46 = 1;
var rss3 = defineChain({
  ...chainConfig2,
  id: 12553,
  name: "RSS3 VSL Mainnet",
  nativeCurrency: { name: "RSS3", symbol: "RSS3", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.rss3.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "RSS3 VSL Mainnet Scan",
      url: "https://scan.rss3.io",
      apiUrl: "https://scan.rss3.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId46]: {
        address: "0xE6f24d2C32B3109B18ed33cF08eFb490b1e09C10"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14193
    },
    portal: {
      [sourceId46]: {
        address: "0x6A12432491bbbE8d3babf75F759766774C778Db4",
        blockCreated: 19387057
      }
    },
    l1StandardBridge: {
      [sourceId46]: {
        address: "0x4cbab69108Aa72151EDa5A3c164eA86845f18438"
      }
    }
  },
  sourceId: sourceId46
});

// node_modules/viem/_esm/chains/definitions/rss3Sepolia.js
var sourceId47 = 11155111;
var rss3Sepolia = defineChain({
  ...chainConfig2,
  id: 2331,
  name: "RSS3 VSL Sepolia Testnet",
  nativeCurrency: { name: "RSS3", symbol: "RSS3", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.rss3.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "RSS3 VSL Sepolia Testnet Scan",
      url: "https://scan.testnet.rss3.io",
      apiUrl: "https://scan.testnet.rss3.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId47]: {
        address: "0xDb5c46C3Eaa6Ed6aE8b2379785DF7dd029C0dC81"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 55697
    },
    portal: {
      [sourceId47]: {
        address: "0xcBD77E8E1E7F06B25baDe67142cdE82652Da7b57",
        blockCreated: 5345035
      }
    },
    l1StandardBridge: {
      [sourceId47]: {
        address: "0xdDD29bb63B0839FB1cE0eE439Ff027738595D07B"
      }
    }
  },
  testnet: true,
  sourceId: sourceId47
});

// node_modules/viem/_esm/chains/definitions/saakuru.js
var saakuru = defineChain({
  id: 7225878,
  name: "Saakuru Mainnet",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.saakuru.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Saakuru Explorer",
      url: "https://explorer.saakuru.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/saga.js
var saga = defineChain({
  id: 5464,
  name: "Saga",
  network: "saga",
  nativeCurrency: {
    decimals: 18,
    name: "gas",
    symbol: "GAS"
  },
  rpcUrls: {
    default: { http: ["https://sagaevm.jsonrpc.sagarpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Saga Explorer",
      url: "https://sagaevm.sagaexplorer.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x864DDc9B50B9A0dF676d826c9B9EDe9F8913a160",
      blockCreated: 467530
    }
  }
});

// node_modules/viem/_esm/chains/definitions/saigon.js
var saigon = defineChain({
  id: 2021,
  name: "Saigon Testnet",
  nativeCurrency: { name: "RON", symbol: "RON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://saigon-testnet.roninchain.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Saigon Explorer",
      url: "https://saigon-app.roninchain.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 18736871
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sanko.js
var sanko = defineChain({
  id: 1996,
  name: "Sanko",
  nativeCurrency: { name: "DMT", symbol: "DMT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.sanko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sanko Explorer",
      url: "https://explorer.sanko.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 37
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/sapphire.js
var sapphire = defineChain({
  id: 23294,
  name: "Oasis Sapphire",
  network: "sapphire",
  nativeCurrency: { name: "Sapphire Rose", symbol: "ROSE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sapphire.oasis.io"],
      webSocket: ["wss://sapphire.oasis.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Oasis Explorer",
      url: "https://explorer.oasis.io/mainnet/sapphire"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 734531
    }
  }
});

// node_modules/viem/_esm/chains/definitions/sapphireTestnet.js
var sapphireTestnet = defineChain({
  id: 23295,
  name: "Oasis Sapphire Testnet",
  network: "sapphire-testnet",
  nativeCurrency: { name: "Sapphire Test Rose", symbol: "TEST", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.sapphire.oasis.dev"],
      webSocket: ["wss://testnet.sapphire.oasis.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Oasis Explorer",
      url: "https://explorer.oasis.io/testnet/sapphire"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/satoshivm.js
var satoshiVM = defineChain({
  id: 3109,
  name: "SatoshiVM Alpha Mainnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://alpha-rpc-node-http.svmscan.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://svmscan.io",
      apiUrl: "https://svmscan.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/satoshivmTestnet.js
var satoshiVMTestnet = defineChain({
  id: 3110,
  name: "SatoshiVM Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://test-rpc-node-http.svmscan.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet.svmscan.io",
      apiUrl: "https://testnet.svmscan.io/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/scroll.js
var scroll = defineChain({
  id: 534352,
  name: "Scroll",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.scroll.io"],
      webSocket: ["wss://wss-rpc.scroll.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Scrollscan",
      url: "https://scrollscan.com",
      apiUrl: "https://api.scrollscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/scrollSepolia.js
var scrollSepolia = defineChain({
  id: 534351,
  name: "Scroll Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.scroll.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Scrollscan",
      url: "https://sepolia.scrollscan.com",
      apiUrl: "https://api-sepolia.scrollscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 9473
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sei.js
var sei = defineChain({
  id: 1329,
  name: "Sei Network",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc.sei-apis.com/"],
      webSocket: ["wss://evm-ws.sei-apis.com/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com",
      apiUrl: "https://seitrace.com/pacific-1/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/seiDevnet.js
var seiDevnet = defineChain({
  id: 713715,
  name: "Sei Devnet",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc-arctic-1.sei-apis.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/seismicDevnet.js
var seismicDevnet = defineChain({
  id: 5124,
  name: "Seismic Devnet",
  nativeCurrency: { name: "Seismic Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://node-2.seismicdev.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seismic Devnet Explorer",
      url: "https://explorer-2.seismicdev.net"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/seiTestnet.js
var seiTestnet = defineChain({
  id: 1328,
  name: "Sei Testnet",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc-testnet.sei-apis.com"],
      webSocket: ["wss://evm-ws-testnet.sei-apis.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sepolia.js
var sepolia = defineChain({
  id: 11155111,
  name: "Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.drpc.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.etherscan.io",
      apiUrl: "https://api-sepolia.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 751532
    },
    ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
    ensUniversalResolver: {
      address: "0xc8Af999e38273D658BE1b921b88A9Ddf005769cC",
      blockCreated: 5317080
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/shape.js
var sourceId48 = 1;
var shape = defineChain({
  ...chainConfig2,
  id: 360,
  name: "Shape",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.shape.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "shapescan",
      url: "https://shapescan.xyz",
      apiUrl: "https://shapescan.xyz/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId48]: {
        address: "0x6Ef8c69CfE4635d866e3E02732068022c06e724D",
        blockCreated: 20369940
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    },
    portal: {
      [sourceId48]: {
        address: "0xEB06fFa16011B5628BaB98E29776361c83741dd3",
        blockCreated: 20369933
      }
    },
    l1StandardBridge: {
      [sourceId48]: {
        address: "0x62Edd5f4930Ea92dCa3fB81689bDD9b9d076b57B",
        blockCreated: 20369935
      }
    }
  },
  sourceId: sourceId48
});

// node_modules/viem/_esm/chains/definitions/shapeSepolia.js
var sourceId49 = 11155111;
var shapeSepolia = defineChain({
  ...chainConfig2,
  id: 11011,
  name: "Shape Sepolia Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.shape.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer-sepolia.shape.network/",
      apiUrl: "https://explorer-sepolia.shape.network/api/v2"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    }
  },
  testnet: true,
  sourceId: sourceId49
});

// node_modules/viem/_esm/chains/definitions/shardeum.js
var shardeum = defineChain({
  id: 8118,
  name: "Shardeum",
  nativeCurrency: { name: "Shardeum", symbol: "SHM", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.shardeum.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shardeum Explorer",
      url: "https://explorer.shardeum.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/shardeumSphinx.js
var shardeumSphinx = defineChain({
  id: 8082,
  name: "Shardeum Sphinx",
  nativeCurrency: { name: "SHARDEUM", symbol: "SHM", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sphinx.shardeum.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shardeum Explorer",
      url: "https://explorer-sphinx.shardeum.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/shibarium.js
var shibarium = defineChain({
  id: 109,
  name: "Shibarium",
  network: "shibarium",
  nativeCurrency: { name: "Bone", symbol: "BONE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.shibrpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://shibariumscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x864Bf681ADD6052395188A89101A1B37d3B4C961",
      blockCreated: 265900
    }
  }
});

// node_modules/viem/_esm/chains/definitions/shibariumTestnet.js
var shibariumTestnet = defineChain({
  id: 157,
  name: "Puppynet Shibarium",
  nativeCurrency: {
    decimals: 18,
    name: "Bone",
    symbol: "BONE"
  },
  rpcUrls: {
    default: { http: ["https://puppynet.shibrpc.com"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://puppyscan.shib.io",
      apiUrl: "https://puppyscan.shib.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xA4029b74FBA366c926eDFA7Dd10B21C621170a4c",
      blockCreated: 3035769
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/shiden.js
var shiden = defineChain({
  id: 336,
  name: "Shiden",
  nativeCurrency: {
    decimals: 18,
    name: "SDN",
    symbol: "SDN"
  },
  rpcUrls: {
    default: {
      http: ["https://shiden.public.blastapi.io"],
      webSocket: ["wss://shiden-rpc.dwellir.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shiden Scan",
      url: "https://shiden.subscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/shimmer.js
var shimmer = defineChain({
  id: 148,
  name: "Shimmer",
  network: "shimmer",
  nativeCurrency: {
    decimals: 18,
    name: "Shimmer",
    symbol: "SMR"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.shimmer.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shimmer Network Explorer",
      url: "https://explorer.evm.shimmer.network",
      apiUrl: "https://explorer.evm.shimmer.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/shimmerTestnet.js
var shimmerTestnet = defineChain({
  id: 1073,
  name: "Shimmer Testnet",
  network: "shimmer-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Shimmer",
    symbol: "SMR"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.testnet.shimmer.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shimmer Network Explorer",
      url: "https://explorer.evm.testnet.shimmer.network",
      apiUrl: "https://explorer.evm.testnet.shimmer.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sidra.js
var sidraChain = defineChain({
  id: 97453,
  name: "Sidra Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Sidra Digital Asset",
    symbol: "SDA"
  },
  rpcUrls: {
    default: {
      http: ["https://node.sidrachain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sidra Chain Explorer",
      url: "https://ledger.sidrachain.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/silicon.js
var silicon = defineChain({
  id: 2355,
  name: "Silicon zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.silicon.network",
        "https://silicon-mainnet.nodeinfra.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SiliconScope",
      url: "https://scope.silicon.network"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/siliconSepolia.js
var siliconSepolia = defineChain({
  id: 1722641160,
  name: "Silicon Sepolia zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-sepolia.silicon.network",
        "https://silicon-testnet.nodeinfra.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SiliconSepoliaScope",
      url: "https://scope-sepolia.silicon.network"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sixProtocol.js
var sixProtocol = defineChain({
  id: 98,
  name: "Six Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "SIX",
    symbol: "SIX"
  },
  rpcUrls: {
    default: {
      http: ["https://sixnet-rpc-evm.sixprotocol.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Six Protocol Scan",
      url: "https://sixscan.io/sixnet"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/skale/brawl.js
var skaleBlockBrawlers = defineChain({
  id: 391845894,
  name: "SKALE | Block Brawlers",
  nativeCurrency: { name: "BRAWL", symbol: "BRAWL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/frayed-decent-antares"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/frayed-decent-antares"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/calypso.js
var skaleCalypso = defineChain({
  id: 1564830818,
  name: "SKALE Calypso Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"],
      webSocket: [
        "wss://mainnet.skalenodes.com/v1/ws/honorable-steel-rasalhague"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3107626
    }
  }
});

// node_modules/viem/_esm/chains/definitions/skale/calypsoTestnet.js
var skaleCalypsoTestnet = defineChain({
  id: 974399131,
  name: "SKALE Calypso Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/giant-half-dual-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/giant-half-dual-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://giant-half-dual-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 103220
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/skale/cryptoBlades.js
var skaleCryptoBlades = defineChain({
  id: 1026062157,
  name: "SKALE | CryptoBlades",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"],
      webSocket: [
        "wss://mainnet.skalenodes.com/v1/ws/affectionate-immediate-pollux"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/cryptoColosseum.js
var skaleCryptoColosseum = defineChain({
  id: 1032942172,
  name: "SKALE | Crypto Colosseum",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/haunting-devoted-deneb"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/europa.js
var skaleEuropa = defineChain({
  id: 2046399126,
  name: "SKALE Europa Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/elated-tan-skat"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/elated-tan-skat"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3113495
    }
  }
});

// node_modules/viem/_esm/chains/definitions/skale/europaTestnet.js
var skaleEuropaTestnet = defineChain({
  id: 1444673419,
  name: "SKALE Europa Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/juicy-low-small-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/juicy-low-small-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://juicy-low-small-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 110858
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/skale/exorde.js
var skaleExorde = defineChain({
  id: 2139927552,
  name: "Exorde Network",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/light-vast-diphda"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/light-vast-diphda"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/humanProtocol.js
var skaleHumanProtocol = defineChain({
  id: 1273227453,
  name: "SKALE | Human Protocol",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/wan-red-ain"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/wan-red-ain"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/nebula.js
var skaleNebula = defineChain({
  id: 1482601649,
  name: "SKALE Nebula Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/green-giddy-denebola"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/green-giddy-denebola"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2372986
    }
  }
});

// node_modules/viem/_esm/chains/definitions/skale/nebulaTestnet.js
var skaleNebulaTestnet = defineChain({
  id: 37084624,
  name: "SKALE Nebula Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/lanky-ill-funny-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/lanky-ill-funny-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://lanky-ill-funny-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 105141
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/skale/razor.js
var skaleRazor = defineChain({
  id: 278611351,
  name: "SKALE | Razor Network",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/turbulent-unique-scheat"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/titan.js
var skaleTitan = defineChain({
  id: 1350216234,
  name: "SKALE Titan Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/parallel-stormy-spica"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/parallel-stormy-spica"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2076458
    }
  }
});

// node_modules/viem/_esm/chains/definitions/skale/titanTestnet.js
var skaleTitanTestnet = defineChain({
  id: 1020352220,
  name: "SKALE Titan Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/aware-fake-trim-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/aware-fake-trim-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://aware-fake-trim-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 104072
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sketchpad.js
var sketchpad = defineChain({
  id: 984123,
  name: "Forma Sketchpad",
  network: "sketchpad",
  nativeCurrency: {
    symbol: "TIA",
    name: "TIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sketchpad-1.forma.art"],
      webSocket: ["wss://ws.sketchpad-1.forma.art"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sketchpad Explorer",
      url: "https://explorer.sketchpad-1.forma.art"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/snax.js
var sourceId50 = 1;
var snax = defineChain({
  ...chainConfig2,
  id: 2192,
  network: "snaxchain-mainnet",
  name: "SnaxChain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.snaxchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Snax Explorer",
      url: "https://explorer.snaxchain.io",
      apiUrl: "https://explorer.snaxchain.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId50]: {
        address: "0x472562Fcf26D6b2793f8E0b0fB660ba0E5e08A46"
      }
    },
    l2OutputOracle: {
      [sourceId50]: {
        address: "0x2172e492Fc807F5d5645D0E3543f139ECF539294"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId50]: {
        address: "0x79f446D024d74D0Bb6E699C131c703463c5D65E9"
      }
    },
    l1StandardBridge: {
      [sourceId50]: {
        address: "0x6534Bdb6b5c060d3e6aa833433333135eFE8E0aA"
      }
    }
  },
  sourceId: sourceId50
});

// node_modules/viem/_esm/chains/definitions/snaxTestnet.js
var sourceId51 = 11155111;
var snaxTestnet = defineChain({
  ...chainConfig2,
  id: 13001,
  network: "snaxchain-testnet",
  name: "SnaxChain Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.snaxchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Snax Explorer",
      url: "https://testnet-explorer.snaxchain.io",
      apiUrl: "https://testnet-explorer.snaxchain.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId51]: {
        address: "0x206a75d89d45F146C54020F132FF93bEDD09f55E"
      }
    },
    l2OutputOracle: {
      [sourceId51]: {
        address: "0x60e3A368a4cdCEf85ffB964e372726F56A46221e"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId51]: {
        address: "0xb5afdd0E8dDF081Ef90e8A3e0c7b5798e66E954E"
      }
    },
    l1StandardBridge: {
      [sourceId51]: {
        address: "0xbd37E1a59D4C00C9A46F75018dffd84061bC5f74"
      }
    }
  },
  testnet: true,
  sourceId: sourceId51
});

// node_modules/viem/_esm/chains/definitions/somniaTestnet.js
var somniaTestnet = defineChain({
  id: 50312,
  name: "Somnia Testnet",
  nativeCurrency: { name: "STT", symbol: "STT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dream-rpc.somnia.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Somnia Testnet Explorer",
      url: "https://somnia-testnet.socialscan.io",
      apiUrl: "https://shannon-explorer.somnia.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/soneium.js
var sourceId52 = 1;
var soneium = defineChain({
  ...chainConfig2,
  id: 1868,
  name: "Soneium Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.soneium.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://soneium.blockscout.com",
      apiUrl: "https://soneium.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId52]: {
        address: "0x512a3d2c7a43bd9261d2b8e8c9c70d4bd4d503c0"
      }
    },
    l2OutputOracle: {
      [sourceId52]: {
        address: "0x0000000000000000000000000000000000000000"
      }
    },
    portal: {
      [sourceId52]: {
        address: "0x88e529a6ccd302c948689cd5156c83d4614fae92",
        blockCreated: 7061266
      }
    },
    l1StandardBridge: {
      [sourceId52]: {
        address: "0xeb9bf100225c214efc3e7c651ebbadcf85177607",
        blockCreated: 7061266
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  },
  sourceId: sourceId52
});

// node_modules/viem/_esm/chains/definitions/soneiumMinato.js
var sourceId53 = 11155111;
var soneiumMinato = defineChain({
  ...chainConfig2,
  id: 1946,
  name: "Soneium Minato Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.minato.soneium.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://soneium-minato.blockscout.com",
      apiUrl: "https://soneium-minato.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId53]: {
        address: "0xB3Ad2c38E6e0640d7ce6aA952AB3A60E81bf7a01"
      }
    },
    l2OutputOracle: {
      [sourceId53]: {
        address: "0x710e5286C746eC38beeB7538d0146f60D27be343"
      }
    },
    portal: {
      [sourceId53]: {
        address: "0x65ea1489741A5D72fFdD8e6485B216bBdcC15Af3",
        blockCreated: 6466136
      }
    },
    l1StandardBridge: {
      [sourceId53]: {
        address: "0x5f5a404A5edabcDD80DB05E8e54A78c9EBF000C2",
        blockCreated: 6466136
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  },
  testnet: true,
  sourceId: sourceId53
});

// node_modules/viem/_esm/chains/definitions/sonic.js
var sonic = defineChain({
  id: 146,
  name: "Sonic",
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Explorer",
      url: "https://sonicscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 60
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/sonicTestnet.js
var sonicTestnet = defineChain({
  id: 64165,
  name: "Sonic Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Testnet Explorer",
      url: "https://testnet.soniclabs.com/"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sonicBlazeTestnet.js
var sonicBlazeTestnet = defineChain({
  id: 57054,
  name: "Sonic Blaze Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.blaze.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Blaze Testnet Explorer",
      url: "https://testnet.sonicscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1100
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/songbird.js
var songbird = defineChain({
  id: 19,
  name: "Songbird Canary-Network",
  nativeCurrency: {
    decimals: 18,
    name: "Songbird",
    symbol: "SGB"
  },
  rpcUrls: {
    default: { http: ["https://songbird-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Songbird Explorer",
      url: "https://songbird-explorer.flare.network",
      apiUrl: "https://songbird-explorer.flare.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 13382504
    }
  }
});

// node_modules/viem/_esm/chains/definitions/songbirdTestnet.js
var songbirdTestnet = defineChain({
  id: 16,
  name: "Songbird Testnet Coston",
  nativeCurrency: {
    decimals: 18,
    name: "Coston Flare",
    symbol: "CFLR"
  },
  rpcUrls: {
    default: { http: ["https://coston-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Coston Explorer",
      url: "https://coston-explorer.flare.network",
      apiUrl: "https://coston-explorer.flare.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sophon.js
var sophon = defineChain({
  ...chainConfig,
  id: 50104,
  name: "Sophon",
  nativeCurrency: {
    decimals: 18,
    name: "Sophon",
    symbol: "SOPH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sophon.xyz"],
      webSocket: ["wss://rpc.sophon.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sophon Block Explorer",
      url: "https://explorer.sophon.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5f4867441d2416cA88B1b3fd38f21811680CD2C8",
      blockCreated: 116
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/sophonTestnet.js
var sophonTestnet = defineChain({
  ...chainConfig,
  id: 531050104,
  name: "Sophon Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sophon",
    symbol: "SOPH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.sophon.xyz"],
      webSocket: ["wss://rpc.testnet.sophon.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sophon Block Explorer",
      url: "https://explorer.testnet.sophon.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0x83c04d112adedA2C6D9037bb6ecb42E7f0b108Af",
      blockCreated: 15642
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/spicy.js
var spicy = defineChain({
  id: 88882,
  name: "Chiliz Spicy Testnet",
  network: "chiliz-spicy-Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "CHZ",
    symbol: "CHZ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://spicy-rpc.chiliz.com",
        "https://chiliz-spicy-rpc.publicnode.com"
      ],
      webSocket: [
        "wss://spicy-rpc-ws.chiliz.com",
        "wss://chiliz-spicy-rpc.publicnode.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Chiliz Explorer",
      url: "http://spicy-explorer.chiliz.com",
      apiUrl: "http://spicy-explorer.chiliz.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/statusNetworkSepolia.js
var statusSepolia = defineChain({
  ...chainConfig4,
  id: 1660990954,
  name: "Status Network Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://public.sepolia.rpc.status.network"],
      webSocket: ["wss://public.sepolia.rpc.status.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepoliascan.status.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1578364
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/step.js
var step = defineChain({
  id: 1234,
  name: "Step Network",
  nativeCurrency: { name: "FITFI", symbol: "FITFI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.step.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Step Scan",
      url: "https://stepscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/story.js
var story = defineChain({
  id: 1514,
  name: "Story",
  nativeCurrency: {
    decimals: 18,
    name: "IP Token",
    symbol: "IP"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 340998
    },
    ensRegistry: {
      address: "0x5dc881dda4e4a8d312be3544ad13118d1a04cb17",
      blockCreated: 648924
    },
    ensUniversalResolver: {
      address: "0xddfb18888a9466688235887dec2a10c4f5effee9",
      blockCreated: 649114
    }
  },
  rpcUrls: {
    default: { http: ["https://mainnet.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story explorer",
      url: "https://storyscan.xyz",
      apiUrl: "https://storyscan.xyz/api/v2"
    }
  },
  ensTlds: [".ip"],
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/storyAeneid.js
var storyAeneid = defineChain({
  id: 1315,
  name: "Story Aeneid",
  network: "story-aeneid",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1792
    },
    ensRegistry: {
      address: "0x5dC881dDA4e4a8d312be3544AD13118D1a04Cb17",
      blockCreated: 1322033
    },
    ensUniversalResolver: {
      address: "0x6D3B3F99177FB2A5de7F9E928a9BD807bF7b5BAD",
      blockCreated: 1322097
    }
  },
  rpcUrls: {
    default: { http: ["https://aeneid.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Aeneid Explorer",
      url: "https://aeneid.storyscan.xyz",
      apiUrl: "https://aeneid.storyscan.xyz/api/v2"
    }
  },
  ensTlds: [".ip"],
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/storyOdyssey.js
var storyOdyssey = defineChain({
  id: 1516,
  name: "Story Odyssey",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.odyssey.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Odyssey Explorer",
      url: "https://odyssey.storyscan.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/storyTestnet.js
var storyTestnet = defineChain({
  id: 1513,
  name: "Story Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  rpcUrls: {
    default: { http: ["https://testnet.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Testnet Explorer",
      url: "https://testnet.storyscan.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/stratis.js
var stratis = defineChain({
  id: 105105,
  name: "Stratis Mainnet",
  network: "stratis",
  nativeCurrency: {
    name: "Stratis",
    symbol: "STRAX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.stratisevm.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Stratis Explorer",
      url: "https://explorer.stratisevm.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/superlumio.js
var superlumio = defineChain({
  id: 8866,
  name: "SuperLumio",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.lumio.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumio explorer",
      url: "https://explorer.lumio.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/superposition.js
var superposition = defineChain({
  id: 55244,
  name: "Superposition",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.superposition.so"] }
  },
  blockExplorers: {
    default: {
      name: "Superposition Explorer",
      url: "https://explorer.superposition.so"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 39
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/superseed.js
var sourceId54 = 1;
var superseed = defineChain({
  ...chainConfig2,
  id: 5330,
  name: "Superseed",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.superseed.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Superseed Explorer",
      url: "https://explorer.superseed.xyz",
      apiUrl: "https://explorer.superseed.xyz/api/v2"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId54]: {
        address: "0x8b097CF1f9BbD9cbFD0DD561858a1FCbC8857Be0",
        blockCreated: 20737481
      }
    },
    l2OutputOracle: {
      [sourceId54]: {
        address: "0x693A0F8854F458D282DE3C5b69E8eE5EEE8aA949",
        blockCreated: 20737481
      }
    },
    portal: {
      [sourceId54]: {
        address: "0x2c2150aa5c75A24fB93d4fD2F2a895D618054f07",
        blockCreated: 20737481
      }
    },
    l1StandardBridge: {
      [sourceId54]: {
        address: "0x8b0576E39F1233679109F9b40cFcC2a7E0901Ede",
        blockCreated: 20737481
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  sourceId: sourceId54
});

// node_modules/viem/_esm/chains/definitions/superseedSepolia.js
var sourceId55 = 11155111;
var superseedSepolia = defineChain({
  ...chainConfig2,
  id: 53302,
  name: "Superseed Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.superseed.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Superseed Sepolia Explorer",
      url: "https://sepolia-explorer.superseed.xyz",
      apiUrl: "https://sepolia-explorer.superseed.xyz/api/v2"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    portal: {
      [sourceId55]: {
        address: "0x7A0db8C51432d2C3eb4e8f360a2EeB26FF2809fB",
        blockCreated: 5523438
      }
    },
    l1StandardBridge: {
      [sourceId55]: {
        address: "0x2B227A603fAAdB3De0ED050b63ADD232B5f2c28C",
        blockCreated: 5523442
      }
    }
  },
  testnet: true,
  sourceId: sourceId55
});

// node_modules/viem/_esm/chains/definitions/swan.js
var swan = defineChain({
  id: 254,
  name: "Swan Chain Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.swanchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://swanscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/swanProximaTestnet.js
var swanProximaTestnet = defineChain({
  id: 20241133,
  name: "Swan Proxima Testnet",
  nativeCurrency: { name: "Swan Ether", symbol: "sETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-proxima.swanchain.io	"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://proxima-explorer.swanchain.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/swanSaturnTestnet.js
var swanSaturnTestnet = defineChain({
  id: 2024,
  name: "Swan Saturn Testnet",
  nativeCurrency: { name: "Swan Ether", symbol: "sETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://saturn-rpc.swanchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://saturn-explorer.swanchain.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/swellchain.js
var swellchain = defineChain({
  ...chainConfig2,
  id: 1923,
  name: "Swellchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://swell-mainnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Swell Explorer",
      url: "https://explorer.swellnetwork.io",
      apiUrl: "https://explorer.swellnetwork.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  }
});

// node_modules/viem/_esm/chains/definitions/swellchainTestnet.js
var swellchainTestnet = defineChain({
  ...chainConfig2,
  id: 1924,
  name: "Swellchain Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://swell-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Swellchain Testnet Explorer",
      url: "https://swell-testnet-explorer.alt.technology",
      apiUrl: "https://swell-testnet-explorer.alt.technology/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  }
});

// node_modules/viem/_esm/chains/definitions/swissdlt.js
var swissdlt = defineChain({
  id: 94,
  name: "SwissDLT Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BCTS",
    symbol: "BCTS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.swissdlt.ch"]
    }
  },
  blockExplorers: {
    default: {
      name: "SwissDLT Explorer",
      url: "https://explorer.swissdlt.ch"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/syscoin.js
var syscoin = defineChain({
  id: 57,
  name: "Syscoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.syscoin.org"],
      webSocket: ["wss://rpc.syscoin.org/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "SyscoinExplorer",
      url: "https://explorer.syscoin.org",
      apiUrl: "https://explorer.syscoin.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 287139
    }
  }
});

// node_modules/viem/_esm/chains/definitions/syscoinTestnet.js
var syscoinTestnet = defineChain({
  id: 5700,
  name: "Syscoin Tanenbaum Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.tanenbaum.io"],
      webSocket: ["wss://rpc.tanenbaum.io/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "SyscoinTestnetExplorer",
      url: "https://tanenbaum.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 271288
    }
  }
});

// node_modules/viem/_esm/chains/definitions/taiko.js
var taiko = defineChain({
  id: 167e3,
  name: "Taiko Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.taiko.xyz"],
      webSocket: ["wss://ws.mainnet.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taikoscan",
      url: "https://taikoscan.io",
      apiUrl: "https://api.taikoscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcb2436774C3e191c85056d248EF4260ce5f27A9D"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/taikoHekla.js
var taikoHekla = defineChain({
  id: 167009,
  name: "Taiko Hekla L2",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.hekla.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taikoscan",
      url: "https://hekla.taikoscan.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 59757
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/taikoJolnir.js
var taikoJolnir = defineChain({
  id: 167007,
  name: "Taiko Jolnir (Alpha-5 Testnet)",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.jolnir.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.jolnir.taiko.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 732706
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/taikoKatla.js
var taikoKatla = defineChain({
  id: 167008,
  name: "Taiko Katla (Alpha-6 Testnet)",
  network: "tko-katla",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.katla.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.katla.taiko.xyz"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/taikoTestnetSepolia.js
var taikoTestnetSepolia = defineChain({
  id: 167005,
  name: "Taiko (Alpha-3 Testnet)",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.test.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.test.taiko.xyz"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/taraxa.js
var taraxa = defineChain({
  id: 841,
  name: "Taraxa Mainnet",
  nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.taraxa.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taraxa Explorer",
      url: "https://explorer.mainnet.taraxa.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/taraxaTestnet.js
var taraxaTestnet = defineChain({
  id: 842,
  name: "Taraxa Testnet",
  nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.taraxa.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taraxa Explorer",
      url: "https://explorer.testnet.taraxa.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/telcoinTestnet.js
var telcoinTestnet = defineChain({
  id: 2017,
  name: "Telcoin Adiri Testnet",
  nativeCurrency: { name: "Telcoin", symbol: "TEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.telcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "telscan",
      url: "https://telscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/telos.js
var telos = defineChain({
  id: 40,
  name: "Telos",
  nativeCurrency: {
    decimals: 18,
    name: "Telos",
    symbol: "TLOS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.telos.net"] }
  },
  blockExplorers: {
    default: {
      name: "Teloscan",
      url: "https://www.teloscan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 246530709
    }
  }
});

// node_modules/viem/_esm/chains/definitions/telosTestnet.js
var telosTestnet = defineChain({
  id: 41,
  name: "Telos",
  nativeCurrency: {
    decimals: 18,
    name: "Telos",
    symbol: "TLOS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.telos.net"] }
  },
  blockExplorers: {
    default: {
      name: "Teloscan (testnet)",
      url: "https://testnet.teloscan.io/"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/tenet.js
var tenet = defineChain({
  id: 1559,
  name: "Tenet",
  network: "tenet-mainnet",
  nativeCurrency: {
    name: "TENET",
    symbol: "TENET",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.tenet.org"] }
  },
  blockExplorers: {
    default: {
      name: "TenetScan Mainnet",
      url: "https://tenetscan.io",
      apiUrl: "https://tenetscan.io/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/ternoa.js
var ternoa = defineChain({
  id: 752025,
  name: "Ternoa",
  nativeCurrency: { name: "Capsule Coin", symbol: "CAPS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.zkevm.ternoa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ternoa Explorer",
      url: "https://explorer-mainnet.zkevm.ternoa.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/thaiChain.js
var thaiChain = defineChain({
  id: 7,
  name: "ThaiChain",
  nativeCurrency: { name: "TCH", symbol: "TCH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.thaichain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp.thaichain.org",
      apiUrl: "https://exp.thaichain.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0DaD6130e832c21719C5CE3bae93454E16A84826",
      blockCreated: 4806386
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/that.js
var that = defineChain({
  id: 8428,
  name: "THAT Mainnet",
  nativeCurrency: { name: "THAT", symbol: "THAT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.thatchain.io/mainnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://that.blockscout.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/theta.js
var theta = defineChain({
  id: 361,
  name: "Theta Mainnet",
  nativeCurrency: { name: "TFUEL", symbol: "TFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-api.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Theta Explorer",
      url: "https://explorer.thetatoken.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/thetaTestnet.js
var thetaTestnet = defineChain({
  id: 365,
  name: "Theta Testnet",
  nativeCurrency: { name: "TFUEL", symbol: "TFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-api-testnet.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Theta Explorer",
      url: "https://testnet-explorer.thetatoken.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/thunderCore.js
var thunderCore = defineChain({
  id: 108,
  name: "ThunderCore Mainnet",
  nativeCurrency: { name: "TT", symbol: "TT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.thundercore.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "ThunderCore Explorer",
      url: "https://explorer-mainnet.thundercore.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/thunderTestnet.js
var thunderTestnet = defineChain({
  id: 997,
  name: "5ireChain Thunder Testnet",
  nativeCurrency: { name: "5ire Token", symbol: "5IRE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.5ire.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "5ireChain Thunder Explorer",
      url: "https://testnet.5irescan.io/"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/tiktrixTestnet.js
var tiktrixTestnet = defineChain({
  id: 62092,
  name: "TikTrix Testnet",
  nativeCurrency: {
    name: "tTTX",
    symbol: "tTTX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://tiktrix-rpc.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "TikTrix Testnet Explorer",
      url: "https://tiktrix.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/tomb.js
var tomb = defineChain({
  id: 6969,
  name: "Tomb Mainnet",
  nativeCurrency: { name: "TOMB", symbol: "TOMB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.tombchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tomb Explorer",
      url: "https://tombscout.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/treasure.js
var treasure = defineChain({
  ...chainConfig,
  id: 61166,
  name: "Treasure",
  nativeCurrency: {
    decimals: 18,
    name: "MAGIC",
    symbol: "MAGIC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.treasure.lol"],
      webSocket: ["wss://rpc.treasure.lol/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Treasure Block Explorer",
      url: "https://treasurescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x2e29fe39496a56856D8698bD43e1dF4D0CE6266a",
      blockCreated: 101
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/treasureTopaz.js
var treasureTopaz = defineChain({
  ...chainConfig,
  id: 978658,
  name: "Treasure Topaz Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MAGIC",
    symbol: "MAGIC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.topaz.treasure.lol"],
      webSocket: ["wss://rpc.topaz.treasure.lol/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Treasure Topaz Block Explorer",
      url: "https://topaz.treasurescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963",
      blockCreated: 108112
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/tron.js
var tron = defineChain({
  id: 728126428,
  name: "Tron",
  nativeCurrency: { name: "TRON", symbol: "TRX", decimals: 6 },
  rpcUrls: {
    default: {
      http: ["https://api.trongrid.io/jsonrpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tronscan",
      url: "https://tronscan.org",
      apiUrl: "https://apilist.tronscanapi.com/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/tronShasta.js
var tronShasta = defineChain({
  id: 2494104990,
  name: "Tron Shasta",
  nativeCurrency: { name: "TRON", symbol: "TRX", decimals: 6 },
  rpcUrls: {
    default: {
      http: ["https://api.shasta.trongrid.io/jsonrpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tronscan",
      url: "https://shasta.tronscan.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ubiq.js
var ubiq = defineChain({
  id: 8,
  name: "Ubiq Mainnet",
  nativeCurrency: { name: "UBQ", symbol: "UBQ", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://pyrus2.ubiqscan.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ubiq Scan",
      url: "https://ubiqscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/ultra.js
var ultra = defineChain({
  id: 19991,
  name: "Ultra EVM",
  nativeCurrency: {
    decimals: 18,
    name: "Ultra Token",
    symbol: "UOS"
  },
  rpcUrls: {
    default: { http: ["https://evm.ultra.eosusa.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ultra EVM Explorer",
      url: "https://evmexplorer.ultra.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/ultraTestnet.js
var ultraTestnet = defineChain({
  id: 18881,
  name: "Ultra EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ultra Token",
    symbol: "UOS"
  },
  rpcUrls: {
    default: { http: ["https://evm.test.ultra.eosusa.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ultra EVM Testnet Explorer",
      url: "https://evmexplorer.testnet.ultra.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ultron.js
var ultron = defineChain({
  id: 1231,
  name: "Ultron Mainnet",
  nativeCurrency: { name: "ULX", symbol: "ULX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ultron-rpc.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ultron Scan",
      url: "https://ulxscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/ultronTestnet.js
var ultronTestnet = defineChain({
  id: 1230,
  name: "Ultron Testnet",
  nativeCurrency: { name: "ULX", symbol: "ULX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ultron-dev.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ultron Scan",
      url: "https://explorer.ultron-dev.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/unichain.js
var sourceId56 = 1;
var unichain = defineChain({
  ...chainConfig2,
  id: 130,
  name: "Unichain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.unichain.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Uniscan",
      url: "https://uniscan.xyz",
      apiUrl: "https://api.uniscan.xyz/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [sourceId56]: {
        address: "0x2F12d621a16e2d3285929C9996f478508951dFe4"
      }
    },
    portal: {
      [sourceId56]: {
        address: "0x0bd48f6B86a26D3a217d0Fa6FfE2B491B956A7a2"
      }
    },
    l1StandardBridge: {
      [sourceId56]: {
        address: "0x81014F44b0a345033bB2b3B21C7a1A308B35fEeA"
      }
    }
  },
  sourceId: sourceId56
});

// node_modules/viem/_esm/chains/definitions/unichainSepolia.js
var sourceId57 = 11155111;
var unichainSepolia = defineChain({
  ...chainConfig2,
  id: 1301,
  name: "Unichain Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.unichain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Uniscan",
      url: "https://sepolia.uniscan.xyz",
      apiUrl: "https://api-sepolia.uniscan.xyz/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    portal: {
      [sourceId57]: {
        address: "0x0d83dab629f0e0F9d36c0Cbc89B69a489f0751bD"
      }
    },
    l1StandardBridge: {
      [sourceId57]: {
        address: "0xea58fcA6849d79EAd1f26608855c2D6407d54Ce2"
      }
    },
    disputeGameFactory: {
      [sourceId57]: {
        address: "0xeff73e5aa3B9AEC32c659Aa3E00444d20a84394b"
      }
    }
  },
  testnet: true,
  sourceId: sourceId57
});

// node_modules/viem/_esm/chains/definitions/unique.js
var unique = defineChain({
  id: 8880,
  name: "Unique Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "UNQ",
    symbol: "UNQ"
  },
  rpcUrls: {
    default: { http: ["https://rpc.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Unique Subscan",
      url: "https://unique.subscan.io/"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/uniqueOpal.js
var uniqueOpal = defineChain({
  id: 8882,
  name: "Opal Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "OPL",
    symbol: "OPL"
  },
  rpcUrls: {
    default: { http: ["https://rpc-opal.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Opal Subscan",
      url: "https://opal.subscan.io/"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/uniqueQuartz.js
var uniqueQuartz = defineChain({
  id: 8881,
  name: "Quartz Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "QTZ",
    symbol: "QTZ"
  },
  rpcUrls: {
    default: { http: ["https://rpc-quartz.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Quartz Subscan",
      url: "https://quartz.subscan.io/"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/unreal.js
var unreal = defineChain({
  id: 18233,
  name: "Unreal",
  nativeCurrency: {
    name: "reETH",
    decimals: 18,
    symbol: "reETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.unreal-orbit.gelato.digital"] }
  },
  blockExplorers: {
    default: {
      name: "Unreal Explorer",
      url: "https://unreal.blockscout.com",
      apiUrl: "https://unreal.blockscout.com/api/v2"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0x8b6B0e60D8CD84898Ea8b981065A12F876eA5677",
      blockCreated: 1745
    }
  }
});

// node_modules/viem/_esm/chains/definitions/vanar.js
var vanar = defineChain({
  id: 2040,
  name: "Vanar Mainnet",
  nativeCurrency: { name: "VANRY", symbol: "VANRY", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.vanarchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vanar Mainnet Explorer",
      url: "https://explorer.vanarchain.com/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/vechain.js
var vechain = defineChain({
  id: 100009,
  name: "Vechain",
  nativeCurrency: { name: "VeChain", symbol: "VET", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.vechain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vechain Explorer",
      url: "https://explore.vechain.org"
    },
    vechainStats: {
      name: "Vechain Stats",
      url: "https://vechainstats.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/velas.js
var velas = defineChain({
  id: 106,
  name: "Velas EVM Mainnet",
  nativeCurrency: { name: "VLX", symbol: "VLX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmexplorer.velas.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Velas Explorer",
      url: "https://evmexplorer.velas.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 55883577
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/viction.js
var viction = defineChain({
  id: 88,
  name: "Viction",
  nativeCurrency: { name: "Viction", symbol: "VIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.viction.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "VIC Scan",
      url: "https://vicscan.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/victionTestnet.js
var victionTestnet = defineChain({
  id: 89,
  name: "Viction Testnet",
  nativeCurrency: { name: "Viction", symbol: "VIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.viction.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "VIC Scan",
      url: "https://testnet.vicscan.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 12170179
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/vision.js
var vision = defineChain({
  id: 888888,
  name: "Vision",
  nativeCurrency: { name: "VISION", symbol: "VS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://infragrid.v.network/ethereum/compatible"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vision Scan",
      url: "https://visionscan.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/visionTestnet.js
var visionTestnet = defineChain({
  id: 666666,
  name: "Vision Testnet",
  nativeCurrency: { name: "VISION", symbol: "VS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://vpioneer.infragrid.v.network/ethereum/compatible"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vision Scan",
      url: "https://visionscan.org/?chain=vpioneer"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/wanchain.js
var wanchain = defineChain({
  id: 888,
  name: "Wanchain",
  nativeCurrency: { name: "WANCHAIN", symbol: "WAN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://gwan-ssl.wandevs.org:56891",
        "https://gwan2-ssl.wandevs.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "WanScan",
      url: "https://wanscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcDF6A1566e78EB4594c86Fe73Fcdc82429e97fbB",
      blockCreated: 25312390
    }
  }
});

// node_modules/viem/_esm/chains/definitions/wanchainTestnet.js
var wanchainTestnet = defineChain({
  id: 999,
  name: "Wanchain Testnet",
  nativeCurrency: { name: "WANCHAIN", symbol: "WANt", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://gwan-ssl.wandevs.org:46891"]
    }
  },
  blockExplorers: {
    default: {
      name: "WanScanTest",
      url: "https://wanscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0x11c89bF4496c39FB80535Ffb4c92715839CC5324",
      blockCreated: 24743448
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/weavevmAlphanet.js
var weaveVMAlphanet = defineChain({
  id: 9496,
  name: "WeaveVM Alphanet",
  nativeCurrency: { name: "Testnet WeaveVM", symbol: "tWVM", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://testnet-rpc.wvm.dev"] }
  },
  blockExplorers: {
    default: {
      name: "WeaveVM Alphanet Explorer",
      url: "https://explorer.wvm.dev"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/wemix.js
var wemix = defineChain({
  id: 1111,
  name: "WEMIX",
  network: "wemix-mainnet",
  nativeCurrency: { name: "WEMIX", symbol: "WEMIX", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://api.wemix.com"] }
  },
  blockExplorers: {
    default: {
      name: "wemixExplorer",
      url: "https://explorer.wemix.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/wemixTestnet.js
var wemixTestnet = defineChain({
  id: 1112,
  name: "WEMIX Testnet",
  network: "wemix-testnet",
  nativeCurrency: { name: "WEMIX", symbol: "tWEMIX", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://api.test.wemix.com"] }
  },
  blockExplorers: {
    default: {
      name: "wemixExplorer",
      url: "https://testnet.wemixscan.com",
      apiUrl: "https://testnet.wemixscan.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/westendAssetHub.js
var westendAssetHub = defineChain({
  id: 420420421,
  name: "Westend Asset Hub",
  nativeCurrency: {
    decimals: 18,
    name: "Westies",
    symbol: "WND"
  },
  rpcUrls: {
    default: { http: ["https://westend-asset-hub-eth-rpc.polkadot.io"] }
  },
  blockExplorers: {
    default: {
      name: "subscan",
      url: "https://westend-asset-hub-eth-explorer.parity.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/whitechain.js
var whitechain = defineChain({
  testnet: false,
  name: "Whitechain",
  blockExplorers: {
    default: {
      name: "Whitechain Explorer",
      url: "https://explorer.whitechain.io"
    }
  },
  id: 1875,
  rpcUrls: {
    default: {
      http: ["https://rpc.whitechain.io"]
    }
  },
  nativeCurrency: {
    decimals: 18,
    name: "WhiteBIT Coin",
    symbol: "WBT"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 25212237
    }
  }
});

// node_modules/viem/_esm/chains/definitions/whitechainTestnet.js
var whitechainTestnet = defineChain({
  testnet: true,
  name: "Whitechain Testnet",
  blockExplorers: {
    default: {
      name: "Whitechain Explorer",
      url: "https://testnet.whitechain.io"
    }
  },
  id: 2625,
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.whitechain.io"]
    }
  },
  nativeCurrency: {
    decimals: 18,
    name: "WhiteBIT Coin",
    symbol: "WBT"
  }
});

// node_modules/viem/_esm/chains/definitions/wmcTestnet.js
var wmcTestnet = defineChain({
  id: 42070,
  name: "WMC Testnet",
  nativeCurrency: { name: "WMTx", symbol: "WMTx", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet-base.worldmobile.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "WMC Explorer",
      url: "https://explorer2-base-testnet.worldmobile.net"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/worldchain.js
var sourceId58 = 1;
var worldchain = defineChain({
  ...chainConfig2,
  id: 480,
  name: "World Chain",
  network: "worldchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://worldchain-mainnet.g.alchemy.com/public"] }
  },
  blockExplorers: {
    default: {
      name: "Worldscan",
      url: "https://worldscan.org",
      apiUrl: "https://api.worldscan.org/api"
    },
    blockscout: {
      name: "Blockscout",
      url: "https://worldchain-mainnet.explorer.alchemy.com",
      apiUrl: "https://worldchain-mainnet.explorer.alchemy.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [sourceId58]: {
        address: "0x069c4c579671f8c120b1327a73217D01Ea2EC5ea"
      }
    },
    l2OutputOracle: {
      [sourceId58]: {
        address: "0x19A6d1E9034596196295CF148509796978343c5D"
      }
    },
    portal: {
      [sourceId58]: {
        address: "0xd5ec14a83B7d95BE1E2Ac12523e2dEE12Cbeea6C"
      }
    },
    l1StandardBridge: {
      [sourceId58]: {
        address: "0x470458C91978D2d929704489Ad730DC3E3001113"
      }
    }
  },
  testnet: false,
  sourceId: sourceId58
});

// node_modules/viem/_esm/chains/definitions/worldchainSepolia.js
var sourceId59 = 11155111;
var worldchainSepolia = defineChain({
  ...chainConfig2,
  id: 4801,
  name: "World Chain Sepolia",
  network: "worldchain-sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://worldchain-sepolia.g.alchemy.com/public"] }
  },
  blockExplorers: {
    default: {
      name: "Worldscan Sepolia",
      url: "https://sepolia.worldscan.org",
      apiUrl: "https://api-sepolia.worldscan.org/api"
    },
    blockscout: {
      name: "Blockscout",
      url: "https://worldchain-sepolia.explorer.alchemy.com",
      apiUrl: "https://worldchain-sepolia.explorer.alchemy.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [sourceId59]: {
        address: "0x8Ec1111f67Dad6b6A93B3F42DfBC92D81c98449A"
      }
    },
    l2OutputOracle: {
      [sourceId59]: {
        address: "0xc8886f8BAb6Eaeb215aDB5f1c686BF699248300e"
      }
    },
    portal: {
      [sourceId59]: {
        address: "0xFf6EBa109271fe6d4237EeeD4bAb1dD9A77dD1A4"
      }
    },
    l1StandardBridge: {
      [sourceId59]: {
        address: "0xd7DF54b3989855eb66497301a4aAEc33Dbb3F8DE"
      }
    }
  },
  testnet: true,
  sourceId: sourceId59
});

// node_modules/viem/_esm/chains/definitions/worldLand.js
var worldLand = defineChain({
  id: 103,
  name: "WorldLand Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "WLC",
    symbol: "WLC"
  },
  rpcUrls: {
    default: {
      http: ["https://seoul.worldland.foundation"]
    }
  },
  blockExplorers: {
    default: {
      name: "WorldLand Scan",
      url: "https://scan.worldland.foundation"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/xai.js
var xai = defineChain({
  id: 660279,
  name: "Xai Mainnet",
  nativeCurrency: { name: "Xai", symbol: "XAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://xai-chain.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.xai-chain.net"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 222549
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/xaiTestnet.js
var xaiTestnet = defineChain({
  id: 37714555429,
  name: "Xai Testnet",
  nativeCurrency: { name: "sXai", symbol: "sXAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet-v2.xai-chain.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer-v2.xai-chain.net"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/xdc.js
var xdc = defineChain({
  id: 50,
  name: "XDC Network",
  nativeCurrency: {
    decimals: 18,
    name: "XDC",
    symbol: "XDC"
  },
  rpcUrls: {
    default: { http: ["https://rpc.xdcrpc.com"] }
  },
  blockExplorers: {
    default: {
      name: "XDCScan",
      url: "https://xdcscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0B1795ccA8E4eC4df02346a082df54D437F8D9aF",
      blockCreated: 75884020
    }
  }
});

// node_modules/viem/_esm/chains/definitions/xdcTestnet.js
var xdcTestnet = defineChain({
  id: 51,
  name: "Apothem Network",
  nativeCurrency: {
    decimals: 18,
    name: "TXDC",
    symbol: "TXDC"
  },
  rpcUrls: {
    default: { http: ["https://erpc.apothem.network"] }
  },
  blockExplorers: {
    default: {
      name: "XDCScan",
      url: "https://testnet.xdcscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 59765389
    }
  }
});

// node_modules/viem/_esm/chains/definitions/xLayer.js
var xLayer = defineChain({
  id: 196,
  name: "X Layer Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OKB",
    symbol: "OKB"
  },
  rpcUrls: {
    default: { http: ["https://rpc.xlayer.tech"] }
  },
  blockExplorers: {
    default: {
      name: "OKLink",
      url: "https://www.oklink.com/xlayer",
      apiUrl: "https://www.oklink.com/api/v5/explorer/xlayer/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 47416
    }
  }
});

// node_modules/viem/_esm/chains/definitions/xLayerTestnet.js
var xLayerTestnet = defineChain({
  id: 195,
  name: "X1 Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "OKB",
    symbol: "OKB"
  },
  rpcUrls: {
    default: { http: ["https://xlayertestrpc.okx.com"] }
  },
  blockExplorers: {
    default: {
      name: "OKLink",
      url: "https://www.oklink.com/xlayer-test"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 624344
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/xrOne.js
var xrOne = defineChain({
  id: 273,
  name: "XR One",
  nativeCurrency: {
    decimals: 18,
    name: "XR1",
    symbol: "XR1"
  },
  rpcUrls: {
    default: {
      http: ["https://xr1.calderachain.xyz/http"],
      webSocket: ["wss://xr1.calderachain.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://xr1.calderaexplorer.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/xrplevmDevnet.js
var xrplevmDevnet = defineChain({
  id: 1440002,
  name: "XRPL EVM Devnet",
  nativeCurrency: {
    name: "XRP",
    symbol: "XRP",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.xrplevm.org/"]
    },
    public: {
      http: ["https://rpc.xrplevm.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "XRPLEVM Devnet Explorer",
      url: "https://explorer.xrplevm.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0x82Cc144D7d0AD4B1c27cb41420e82b82Ad6e9B31",
      blockCreated: 15237286
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/xrplevmTestnet.js
var xrplevmTestnet = defineChain({
  id: 1449e3,
  name: "XRPL EVM Testnet",
  nativeCurrency: {
    name: "XRP",
    symbol: "XRP",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.xrplevm.org"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.testnet.xrplevm.org",
      apiUrl: "https://explorer.testnet.xrplevm.org/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0x82Cc144D7d0AD4B1c27cb41420e82b82Ad6e9B31",
      blockCreated: 492302
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/xrSepolia.js
var xrSepolia = defineChain({
  id: 2730,
  name: "XR Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "tXR",
    symbol: "tXR"
  },
  rpcUrls: {
    default: { http: ["https://xr-sepolia-testnet.rpc.caldera.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://xr-sepolia-testnet.explorer.caldera.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/yooldoVerse.js
var yooldoVerse = defineChain({
  id: 50005,
  name: "Yooldo Verse",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.yooldo-verse.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Yooldo Verse Explorer",
      url: "https://explorer.yooldo-verse.xyz"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/yooldoVerseTestnet.js
var yooldoVerseTestnet = defineChain({
  id: 50006,
  name: "Yooldo Verse Testnet",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.yooldo-verse.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Yooldo Verse Testnet Explorer",
      url: "https://explorer.testnet.yooldo-verse.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zenchainTestnet.js
var zenchainTestnet = defineChain({
  id: 8408,
  name: "ZenChain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ZTC",
    symbol: "ZTC"
  },
  rpcUrls: {
    default: {
      http: ["https://zenchain-testnet.api.onfinality.io/public"],
      webSocket: ["wss://zenchain-testnet.api.onfinality.io/public-ws"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 230019
    }
  },
  blockExplorers: {
    default: {
      name: "Zentrace",
      url: "https://zentrace.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zeniq.js
var zeniq = defineChain({
  id: 383414847825,
  name: "Zeniq Mainnet",
  nativeCurrency: { name: "ZENIQ", symbol: "ZENIQ", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.zeniq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zeniq Explorer",
      url: "https://zeniqscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/0g.js
var zeroG = defineChain({
  id: 16600,
  name: "0G Newton Testnet",
  nativeCurrency: { name: "A0GI", symbol: "A0GI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmrpc-testnet.0g.ai"]
    }
  },
  blockExplorers: {
    default: {
      name: "0G BlockChain Explorer",
      url: "https://chainscan-newton.0g.ai"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zeroNetwork.js
var zeroNetwork = defineChain({
  id: 543210,
  name: "Zero Network",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.zerion.io/v1/zero"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zero Network Explorer",
      url: "https://explorer.zero.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zetachain.js
var zetachain = defineChain({
  id: 7e3,
  name: "ZetaChain",
  nativeCurrency: {
    decimals: 18,
    name: "Zeta",
    symbol: "ZETA"
  },
  rpcUrls: {
    default: {
      http: ["https://zetachain-evm.blockpi.network/v1/rpc/public"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1632781
    }
  },
  blockExplorers: {
    default: {
      name: "ZetaScan",
      url: "https://explorer.zetachain.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zetachainAthensTestnet.js
var zetachainAthensTestnet = defineChain({
  id: 7001,
  name: "ZetaChain Athens Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Zeta",
    symbol: "aZETA"
  },
  rpcUrls: {
    default: {
      http: ["https://zetachain-athens-evm.blockpi.network/v1/rpc/public"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2715217
    }
  },
  blockExplorers: {
    default: {
      name: "ZetaScan",
      url: "https://athens.explorer.zetachain.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zhejiang.js
var zhejiang = defineChain({
  id: 1337803,
  name: "Zhejiang",
  nativeCurrency: { name: "Zhejiang Ether", symbol: "ZhejETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.zhejiang.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beaconchain",
      url: "https://zhejiang.beaconcha.in"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zilliqa.js
var zilliqa = defineChain({
  id: 32769,
  name: "Zilliqa",
  network: "zilliqa",
  nativeCurrency: { name: "Zilliqa", symbol: "ZIL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.zilliqa.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ethernal",
      url: "https://evmx.zilliqa.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zilliqaTestnet.js
var zilliqaTestnet = defineChain({
  id: 33101,
  name: "Zilliqa Testnet",
  network: "zilliqa-testnet",
  nativeCurrency: { name: "Zilliqa", symbol: "ZIL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dev-api.zilliqa.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ethernal",
      url: "https://evmx.testnet.zilliqa.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zircuit.js
var sourceId60 = 1;
var zircuit = defineChain({
  ...chainConfig2,
  id: 48900,
  name: "Zircuit Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: [
        "https://mainnet.zircuit.com",
        "https://zircuit1-mainnet.liquify.com",
        "https://zircuit1-mainnet.p2pify.com",
        "https://zircuit-mainnet.drpc.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Explorer",
      url: "https://explorer.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    l2OutputOracle: {
      [sourceId60]: {
        address: "0x92Ef6Af472b39F1b363da45E35530c24619245A4"
      }
    },
    portal: {
      [sourceId60]: {
        address: "0x17bfAfA932d2e23Bd9B909Fd5B4D2e2a27043fb1"
      }
    },
    l1StandardBridge: {
      [sourceId60]: {
        address: "0x386B76D9cA5F5Fb150B6BFB35CF5379B22B26dd8"
      }
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zircuitGarfieldTestnet.js
var sourceId61 = 11155111;
var zircuitGarfieldTestnet = defineChain({
  ...chainConfig2,
  id: 48898,
  name: "Zircuit Garfield Testnet",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://garfield-testnet.zircuit.com/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Garfield Testnet Explorer",
      url: "https://explorer.garfield-testnet.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    l2OutputOracle: {
      [sourceId61]: {
        address: "0xd69D3AC5CA686cCF94b258291772bc520FEAf211"
      }
    },
    portal: {
      [sourceId61]: {
        address: "0x4E21A71Ac3F7607Da5c06153A17B1DD20E702c21"
      }
    },
    l1StandardBridge: {
      [sourceId61]: {
        address: "0x87a7E2bCA9E35BA49282E832a28A6023904460D8"
      }
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zircuitTestnet.js
var sourceId62 = 11155111;
var zircuitTestnet = defineChain({
  ...chainConfig2,
  id: 48899,
  name: "Zircuit Testnet",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://testnet.zircuit.com",
        "https://zircuit1-testnet.p2pify.com",
        "https://zircuit1-testnet.liquify.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Testnet Explorer",
      url: "https://explorer.testnet.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 6040287
    },
    l2OutputOracle: {
      [sourceId62]: {
        address: "0x740C2dac453aEf7140809F80b72bf0e647af8148"
      }
    },
    portal: {
      [sourceId62]: {
        address: "0x787f1C8c5924178689E0560a43D848bF8E54b23e"
      }
    },
    l1StandardBridge: {
      [sourceId62]: {
        address: "0x0545c5fe980098C16fcD0eCB5E79753afa6d9af9"
      }
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zkFair.js
var zkFair = defineChain({
  id: 42766,
  name: "ZKFair Mainnet",
  network: "zkfair-mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "USD Coin",
    symbol: "USDC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.zkfair.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "zkFair Explorer",
      url: "https://scan.zkfair.io",
      apiUrl: "https://scan.zkfair.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6090959
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zkFairTestnet.js
var zkFairTestnet = defineChain({
  id: 43851,
  name: "ZKFair Testnet",
  network: "zkfair-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "USD Coin",
    symbol: "USDC"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.zkfair.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "zkFair Explorer",
      url: "https://testnet-scan.zkfair.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zkLinkNova.js
var zkLinkNova = defineChain({
  id: 810180,
  name: "zkLink Nova",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.zklink.io"] }
  },
  blockExplorers: {
    default: {
      name: "zkLink Nova Block Explorer",
      url: "https://explorer.zklink.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/zkLinkNovaSepoliaTestnet.js
var zkLinkNovaSepoliaTestnet = defineChain({
  id: 810181,
  name: "zkLink Nova Sepolia Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://sepolia.rpc.zklink.io"] }
  },
  blockExplorers: {
    default: {
      name: "zkLink Nova Block Explorer",
      url: "https://sepolia.explorer.zklink.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/zksync.js
var zksync = defineChain({
  ...chainConfig,
  id: 324,
  name: "ZKsync Era",
  network: "zksync-era",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.era.zksync.io"],
      webSocket: ["wss://mainnet.era.zksync.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://era.zksync.network/",
      apiUrl: "https://api-era.zksync.network/api"
    },
    native: {
      name: "ZKsync Explorer",
      url: "https://explorer.zksync.io/",
      apiUrl: "https://block-explorer-api.mainnet.zksync.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 45659388
    }
  }
});

// node_modules/viem/_esm/chains/definitions/zksyncInMemoryNode.js
var zksyncInMemoryNode = defineChain({
  ...chainConfig,
  id: 260,
  name: "ZKsync InMemory Node",
  network: "zksync-in-memory-node",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:8011"]
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zksyncLocalCustomHyperchain.js
var zksyncLocalCustomHyperchain = defineChain({
  ...chainConfig,
  id: 272,
  name: "ZKsync CLI Local Custom Hyperchain",
  nativeCurrency: { name: "BAT", symbol: "BAT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15200"],
      webSocket: ["ws://localhost:15201"]
    }
  },
  blockExplorers: {
    default: {
      name: "ZKsync explorer",
      url: "http://localhost:15005/",
      apiUrl: "http://localhost:15005/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zksyncLocalHyperchain.js
var zksyncLocalHyperchain = defineChain({
  ...chainConfig,
  id: 270,
  name: "ZKsync CLI Local Hyperchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15100"],
      webSocket: ["ws://localhost:15101"]
    }
  },
  blockExplorers: {
    default: {
      name: "ZKsync explorer",
      url: "http://localhost:15005/",
      apiUrl: "http://localhost:15005/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zksyncLocalHyperchainL1.js
var zksyncLocalHyperchainL1 = defineChain({
  id: 9,
  name: "ZKsync CLI Local Hyperchain L1",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15045"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "http://localhost:15001/",
      apiUrl: "http://localhost:15001/api/v2"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zksyncLocalNode.js
var zksyncLocalNode = defineChain({
  ...chainConfig,
  id: 270,
  name: "ZKsync CLI Local Node",
  network: "zksync-cli-local-node",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:3050"]
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zksyncSepoliaTestnet.js
var zksyncSepoliaTestnet = defineChain({
  ...chainConfig,
  id: 300,
  name: "ZKsync Sepolia Testnet",
  network: "zksync-sepolia-testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.era.zksync.dev"],
      webSocket: ["wss://sepolia.era.zksync.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia-era.zksync.network/",
      apiUrl: "https://api-sepolia-era.zksync.network/api"
    },
    native: {
      name: "ZKsync Explorer",
      url: "https://sepolia.explorer.zksync.io/",
      blockExplorerApi: "https://block-explorer-api.sepolia.zksync.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 3855712
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zora.js
var sourceId63 = 1;
var zora = defineChain({
  ...chainConfig2,
  id: 7777777,
  name: "Zora",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.zora.energy"],
      webSocket: ["wss://rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.zora.energy",
      apiUrl: "https://explorer.zora.energy/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId63]: {
        address: "0x9E6204F750cD866b299594e2aC9eA824E2e5f95c"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 5882
    },
    portal: {
      [sourceId63]: {
        address: "0x1a0ad011913A150f69f6A19DF447A0CfD9551054"
      }
    },
    l1StandardBridge: {
      [sourceId63]: {
        address: "0x3e2Ea9B92B7E48A52296fD261dc26fd995284631"
      }
    }
  },
  sourceId: sourceId63
});

// node_modules/viem/_esm/chains/definitions/zoraSepolia.js
var sourceId64 = 11155111;
var zoraSepolia = defineChain({
  ...chainConfig2,
  id: 999999999,
  name: "Zora Sepolia",
  network: "zora-sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Zora Sepolia",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.rpc.zora.energy"],
      webSocket: ["wss://sepolia.rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zora Sepolia Explorer",
      url: "https://sepolia.explorer.zora.energy/",
      apiUrl: "https://sepolia.explorer.zora.energy/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId64]: {
        address: "0x2615B481Bd3E5A1C0C7Ca3Da1bdc663E8615Ade9"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 83160
    },
    portal: {
      [sourceId64]: {
        address: "0xeffE2C6cA9Ab797D418f0D91eA60807713f3536f"
      }
    },
    l1StandardBridge: {
      [sourceId64]: {
        address: "0x5376f1D543dcbB5BD416c56C189e4cB7399fCcCB"
      }
    }
  },
  sourceId: sourceId64,
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zoraTestnet.js
var sourceId65 = 5;
var zoraTestnet = defineChain({
  ...chainConfig2,
  id: 999,
  name: "Zora Goerli Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Zora Goerli",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.zora.energy"],
      webSocket: ["wss://testnet.rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://testnet.explorer.zora.energy",
      apiUrl: "https://testnet.explorer.zora.energy/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 189123
    },
    portal: {
      [sourceId65]: {
        address: "0xDb9F51790365e7dc196e7D072728df39Be958ACe"
      }
    }
  },
  sourceId: sourceId65,
  testnet: true
});

// node_modules/@reown/appkit/dist/esm/src/networks/utils.js
function defineChain4(chain) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...chain
  };
}

// node_modules/@reown/appkit/dist/esm/src/networks/solana/solana.js
var solana = defineChain4({
  id: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  name: "Solana",
  network: "solana-mainnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: false,
  chainNamespace: "solana",
  caipNetworkId: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  deprecatedCaipNetworkId: "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ"
});

// node_modules/@reown/appkit/dist/esm/src/networks/solana/solanaDevnet.js
var solanaDevnet = defineChain4({
  id: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  name: "Solana Devnet",
  network: "solana-devnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: true,
  chainNamespace: "solana",
  caipNetworkId: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  deprecatedCaipNetworkId: "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"
});

// node_modules/@reown/appkit/dist/esm/src/networks/solana/solanaTestnet.js
var solanaTestnet = defineChain4({
  id: "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
  name: "Solana Testnet",
  network: "solana-testnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: true,
  chainNamespace: "solana",
  caipNetworkId: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z"
});

// node_modules/@reown/appkit/dist/esm/src/networks/bitcoin.js
var bitcoin = defineChain4({
  id: "000000000019d6689c085ae165831e93",
  caipNetworkId: "bip122:000000000019d6689c085ae165831e93",
  chainNamespace: "bip122",
  name: "Bitcoin",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 8
  },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  }
});
var bitcoinTestnet = defineChain4({
  id: "000000000933ea01ad0ee984209779ba",
  caipNetworkId: "bip122:000000000933ea01ad0ee984209779ba",
  chainNamespace: "bip122",
  name: "Bitcoin Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 8
  },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  testnet: true
});

// node_modules/@reown/appkit/dist/esm/src/utils/HelpersUtil.js
var DEFAULT_METHODS = {
  solana: [
    "solana_signMessage",
    "solana_signTransaction",
    "solana_requestAccounts",
    "solana_getAccounts",
    "solana_signAllTransactions",
    "solana_signAndSendTransaction"
  ],
  eip155: [
    "eth_accounts",
    "eth_requestAccounts",
    "eth_sendRawTransaction",
    "eth_sign",
    "eth_signTransaction",
    "eth_signTypedData",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "personal_sign",
    "wallet_switchEthereumChain",
    "wallet_addEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
    // EIP-5792
    "wallet_getCallsStatus",
    "wallet_showCallsStatus",
    "wallet_sendCalls",
    "wallet_getCapabilities",
    // EIP-7715
    "wallet_grantPermissions",
    "wallet_revokePermissions",
    //EIP-7811
    "wallet_getAssets"
  ],
  bip122: ["sendTransfer", "signMessage", "signPsbt", "getAccountAddresses"]
};
var WcHelpersUtil = {
  getMethodsByChainNamespace(chainNamespace) {
    return DEFAULT_METHODS[chainNamespace] || [];
  },
  createDefaultNamespace(chainNamespace) {
    return {
      methods: this.getMethodsByChainNamespace(chainNamespace),
      events: ["accountsChanged", "chainChanged"],
      chains: [],
      rpcMap: {}
    };
  },
  applyNamespaceOverrides(baseNamespaces, overrides) {
    if (!overrides) {
      return { ...baseNamespaces };
    }
    const result = { ...baseNamespaces };
    const namespacesToOverride = /* @__PURE__ */ new Set();
    if (overrides.methods) {
      Object.keys(overrides.methods).forEach((ns3) => namespacesToOverride.add(ns3));
    }
    if (overrides.chains) {
      Object.keys(overrides.chains).forEach((ns3) => namespacesToOverride.add(ns3));
    }
    if (overrides.events) {
      Object.keys(overrides.events).forEach((ns3) => namespacesToOverride.add(ns3));
    }
    if (overrides.rpcMap) {
      Object.keys(overrides.rpcMap).forEach((chainId) => {
        const [ns3] = chainId.split(":");
        if (ns3) {
          namespacesToOverride.add(ns3);
        }
      });
    }
    namespacesToOverride.forEach((ns3) => {
      if (!result[ns3]) {
        result[ns3] = this.createDefaultNamespace(ns3);
      }
    });
    if (overrides.methods) {
      Object.entries(overrides.methods).forEach(([ns3, methods]) => {
        if (result[ns3]) {
          result[ns3].methods = methods;
        }
      });
    }
    if (overrides.chains) {
      Object.entries(overrides.chains).forEach(([ns3, chains]) => {
        if (result[ns3]) {
          result[ns3].chains = chains;
        }
      });
    }
    if (overrides.events) {
      Object.entries(overrides.events).forEach(([ns3, events]) => {
        if (result[ns3]) {
          result[ns3].events = events;
        }
      });
    }
    if (overrides.rpcMap) {
      const processedNamespaces = /* @__PURE__ */ new Set();
      Object.entries(overrides.rpcMap).forEach(([chainId, rpcUrl]) => {
        const [ns3, id] = chainId.split(":");
        if (!ns3 || !id || !result[ns3]) {
          return;
        }
        if (!result[ns3].rpcMap) {
          result[ns3].rpcMap = {};
        }
        if (!processedNamespaces.has(ns3)) {
          result[ns3].rpcMap = {};
          processedNamespaces.add(ns3);
        }
        result[ns3].rpcMap[id] = rpcUrl;
      });
    }
    return result;
  },
  createNamespaces(caipNetworks, configOverride) {
    const defaultNamespaces = caipNetworks.reduce((acc, chain) => {
      const { id, chainNamespace, rpcUrls } = chain;
      const rpcUrl = rpcUrls.default.http[0];
      if (!acc[chainNamespace]) {
        acc[chainNamespace] = this.createDefaultNamespace(chainNamespace);
      }
      const caipNetworkId = `${chainNamespace}:${id}`;
      const namespace = acc[chainNamespace];
      namespace.chains.push(caipNetworkId);
      switch (caipNetworkId) {
        case solana.caipNetworkId:
          namespace.chains.push(solana.deprecatedCaipNetworkId);
          break;
        case solanaDevnet.caipNetworkId:
          namespace.chains.push(solanaDevnet.deprecatedCaipNetworkId);
          break;
        default:
      }
      if ((namespace == null ? void 0 : namespace.rpcMap) && rpcUrl) {
        namespace.rpcMap[id] = rpcUrl;
      }
      return acc;
    }, {});
    return this.applyNamespaceOverrides(defaultNamespaces, configOverride);
  },
  resolveReownName: async (name) => {
    var _a2;
    const wcNameAddress = await EnsController.resolveName(name);
    const networkNameAddresses = Object.values(wcNameAddress == null ? void 0 : wcNameAddress.addresses) || [];
    return ((_a2 = networkNameAddresses[0]) == null ? void 0 : _a2.address) || false;
  },
  getChainsFromNamespaces(namespaces = {}) {
    return Object.values(namespaces).flatMap((namespace) => {
      const chains = namespace.chains || [];
      const accountsChains = namespace.accounts.map((account) => {
        const [chainNamespace, chainId] = account.split(":");
        return `${chainNamespace}:${chainId}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...chains, ...accountsChains]));
    });
  },
  isSessionEventData(data) {
    return typeof data === "object" && data !== null && "id" in data && "topic" in data && "params" in data && typeof data.params === "object" && data.params !== null && "chainId" in data.params && "event" in data.params && typeof data.params.event === "object" && data.params.event !== null;
  }
};

// node_modules/@reown/appkit/dist/esm/src/connectors/WalletConnectConnector.js
var WalletConnectConnector = class {
  constructor({ provider, caipNetworks, namespace }) {
    this.id = ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
    this.name = PresetsUtil.ConnectorNamesMap[ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT];
    this.type = "WALLET_CONNECT";
    this.imageId = PresetsUtil.ConnectorImageIds[ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT];
    this.caipNetworks = caipNetworks;
    this.provider = provider;
    this.chain = namespace;
  }
  get chains() {
    return this.caipNetworks;
  }
  async connectWalletConnect() {
    const isAuthenticated = await this.authenticate();
    if (!isAuthenticated) {
      const universalProviderConfigOverride = OptionsController.state.universalProviderConfigOverride;
      const namespaces = WcHelpersUtil.createNamespaces(this.caipNetworks, universalProviderConfigOverride);
      await this.provider.connect({
        optionalNamespaces: namespaces
      });
    }
    return {
      clientId: await this.provider.client.core.crypto.getClientId(),
      session: this.provider.session
    };
  }
  async disconnect() {
    await this.provider.disconnect();
  }
  async authenticate() {
    const chains = this.chains.map((network) => network.caipNetworkId);
    return SIWXUtil.universalProviderAuthenticate({
      universalProvider: this.provider,
      chains,
      methods: OPTIONAL_METHODS
    });
  }
};
var OPTIONAL_METHODS = [
  "eth_accounts",
  "eth_requestAccounts",
  "eth_sendRawTransaction",
  "eth_sign",
  "eth_signTransaction",
  "eth_signTypedData",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "eth_sendTransaction",
  "personal_sign",
  "wallet_switchEthereumChain",
  "wallet_addEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode",
  // EIP-5792
  "wallet_getCallsStatus",
  "wallet_sendCalls",
  "wallet_getCapabilities",
  // EIP-7715
  "wallet_grantPermissions",
  "wallet_revokePermissions",
  //EIP-7811
  "wallet_getAssets"
];

// node_modules/@reown/appkit/dist/esm/src/adapters/ChainAdapterBlueprint.js
var AdapterBlueprint = class {
  /**
   * Creates an instance of AdapterBlueprint.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  constructor(params) {
    this.availableConnectors = [];
    this.eventListeners = /* @__PURE__ */ new Map();
    if (params) {
      this.construct(params);
    }
  }
  /**
   * Initializes the adapter with the given parameters.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  construct(params) {
    this.caipNetworks = params.networks;
    this.projectId = params.projectId;
    this.namespace = params.namespace;
    this.adapterType = params.adapterType;
  }
  /**
   * Gets the available connectors.
   * @returns {Connector[]} An array of available connectors
   */
  get connectors() {
    return this.availableConnectors;
  }
  /**
   * Gets the supported networks.
   * @returns {CaipNetwork[]} An array of supported networks
   */
  get networks() {
    return this.caipNetworks || [];
  }
  /**
   * Sets the auth provider.
   * @param {W3mFrameProvider} authProvider - The auth provider instance
   */
  setAuthProvider(authProvider) {
    this.addConnector({
      id: ConstantsUtil.CONNECTOR_ID.AUTH,
      type: "AUTH",
      name: ConstantsUtil.CONNECTOR_NAMES.AUTH,
      provider: authProvider,
      imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil.CONNECTOR_ID.AUTH],
      chain: this.namespace,
      chains: []
    });
  }
  /**
   * Adds one or more connectors to the available connectors list.
   * @param {...Connector} connectors - The connectors to add
   */
  addConnector(...connectors) {
    const connectorsAdded = /* @__PURE__ */ new Set();
    this.availableConnectors = [...connectors, ...this.availableConnectors].filter((connector) => {
      if (connectorsAdded.has(connector.id)) {
        return false;
      }
      connectorsAdded.add(connector.id);
      return true;
    });
    this.emit("connectors", this.availableConnectors);
  }
  setStatus(status, chainNamespace) {
    AccountController.setStatus(status, chainNamespace);
  }
  /**
   * Adds an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be called when the event is emitted
   */
  on(eventName, callback) {
    var _a2;
    if (!this.eventListeners.has(eventName)) {
      this.eventListeners.set(eventName, /* @__PURE__ */ new Set());
    }
    (_a2 = this.eventListeners.get(eventName)) == null ? void 0 : _a2.add(callback);
  }
  /**
   * Removes an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be removed
   */
  off(eventName, callback) {
    const listeners = this.eventListeners.get(eventName);
    if (listeners) {
      listeners.delete(callback);
    }
  }
  /**
   * Removes all event listeners.
   */
  removeAllEventListeners() {
    this.eventListeners.forEach((listeners) => {
      listeners.clear();
    });
  }
  /**
   * Emits an event with the given name and optional data.
   * @template T
   * @param {T} eventName - The name of the event to emit
   * @param {EventData[T]} [data] - The optional data to be passed to the event listeners
   */
  emit(eventName, data) {
    const listeners = this.eventListeners.get(eventName);
    if (listeners) {
      listeners.forEach((callback) => callback(data));
    }
  }
  /**
   * Connects to WalletConnect.
   * @param {number | string} [_chainId] - Optional chain ID to connect to
   */
  async connectWalletConnect(_chainId) {
    const connector = this.getWalletConnectConnector();
    const result = await connector.connectWalletConnect();
    return { clientId: result.clientId };
  }
  /**
   * Switches the network.
   * @param {AdapterBlueprint.SwitchNetworkParams} params - Network switching parameters
   */
  async switchNetwork(params) {
    const { caipNetwork, providerType } = params;
    if (!params.provider) {
      return;
    }
    const provider = "provider" in params.provider ? params.provider.provider : params.provider;
    if (providerType === "WALLET_CONNECT") {
      ;
      provider.setDefaultChain(caipNetwork.caipNetworkId);
      return;
    }
    if (provider && providerType === "AUTH") {
      const authProvider = provider;
      await authProvider.switchNetwork(caipNetwork.caipNetworkId);
      const user = await authProvider.getUser({
        chainId: caipNetwork.caipNetworkId,
        preferredAccountType: OptionsController.state.defaultAccountTypes[caipNetwork.chainNamespace]
      });
      this.emit("switchNetwork", user);
    }
  }
  getWalletConnectConnector() {
    const connector = this.connectors.find((c6) => c6 instanceof WalletConnectConnector);
    if (!connector) {
      throw new Error("WalletConnectConnector not found");
    }
    return connector;
  }
};

// node_modules/@reown/appkit/dist/esm/src/universal-adapter/client.js
var UniversalAdapter = class extends AdapterBlueprint {
  setUniversalProvider(universalProvider) {
    this.addConnector(new WalletConnectConnector({
      provider: universalProvider,
      caipNetworks: this.caipNetworks || [],
      namespace: this.namespace
    }));
  }
  async connect(params) {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: Number(params.chainId),
      provider: this.provider,
      address: ""
    });
  }
  async disconnect() {
    try {
      const connector = this.getWalletConnectConnector();
      await connector.disconnect();
    } catch (error) {
      console.warn("UniversalAdapter:disconnect - error", error);
    }
  }
  async getAccounts({ namespace }) {
    var _a2, _b, _c2, _d;
    const provider = this.provider;
    const addresses = ((_d = (_c2 = (_b = (_a2 = provider == null ? void 0 : provider.session) == null ? void 0 : _a2.namespaces) == null ? void 0 : _b[namespace]) == null ? void 0 : _c2.accounts) == null ? void 0 : _d.map((account) => {
      const [, , address] = account.split(":");
      return address;
    }).filter((address, index, self2) => self2.indexOf(address) === index)) || [];
    return Promise.resolve({
      accounts: addresses.map((address) => CoreHelperUtil.createAccount(namespace, address, namespace === "bip122" ? "payment" : "eoa"))
    });
  }
  async syncConnectors() {
    return Promise.resolve();
  }
  async getBalance(params) {
    var _a2, _b, _c2, _d, _e9;
    const isBalanceSupported = params.caipNetwork && ConstantsUtil2.BALANCE_SUPPORTED_CHAINS.includes((_a2 = params.caipNetwork) == null ? void 0 : _a2.chainNamespace);
    if (!isBalanceSupported || ((_b = params.caipNetwork) == null ? void 0 : _b.testnet)) {
      return {
        balance: "0.00",
        symbol: ((_c2 = params.caipNetwork) == null ? void 0 : _c2.nativeCurrency.symbol) || ""
      };
    }
    if (AccountController.state.balanceLoading && params.chainId === ((_d = ChainController.state.activeCaipNetwork) == null ? void 0 : _d.id)) {
      return {
        balance: AccountController.state.balance || "0.00",
        symbol: AccountController.state.balanceSymbol || ""
      };
    }
    const balances = await AccountController.fetchTokenBalance();
    const balance = balances.find((b4) => {
      var _a3, _b2;
      return b4.chainId === `${(_a3 = params.caipNetwork) == null ? void 0 : _a3.chainNamespace}:${params.chainId}` && b4.symbol === ((_b2 = params.caipNetwork) == null ? void 0 : _b2.nativeCurrency.symbol);
    });
    return {
      balance: (balance == null ? void 0 : balance.quantity.numeric) || "0.00",
      symbol: (balance == null ? void 0 : balance.symbol) || ((_e9 = params.caipNetwork) == null ? void 0 : _e9.nativeCurrency.symbol) || ""
    };
  }
  async signMessage(params) {
    var _a2, _b, _c2;
    const { provider, message, address } = params;
    if (!provider) {
      throw new Error("UniversalAdapter:signMessage - provider is undefined");
    }
    let signature = "";
    if (((_a2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a2.chainNamespace) === ConstantsUtil.CHAIN.SOLANA) {
      const response = await provider.request({
        method: "solana_signMessage",
        params: {
          message: esm_default4.encode(new TextEncoder().encode(message)),
          pubkey: address
        }
      }, (_b = ChainController.state.activeCaipNetwork) == null ? void 0 : _b.caipNetworkId);
      signature = response.signature;
    } else {
      signature = await provider.request({
        method: "personal_sign",
        params: [message, address]
      }, (_c2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _c2.caipNetworkId);
    }
    return { signature };
  }
  // -- Transaction methods ---------------------------------------------------
  /**
   *
   * These methods are supported only on `wagmi` and `ethers` since the Solana SDK does not support them in the same way.
   * These function definition is to have a type parity between the clients. Currently not in use.
   */
  async estimateGas() {
    return Promise.resolve({
      gas: BigInt(0)
    });
  }
  async getProfile() {
    return Promise.resolve({
      profileImage: "",
      profileName: ""
    });
  }
  async sendTransaction() {
    return Promise.resolve({
      hash: ""
    });
  }
  walletGetAssets(_params) {
    return Promise.resolve({});
  }
  async writeContract() {
    return Promise.resolve({
      hash: ""
    });
  }
  async getEnsAddress() {
    return Promise.resolve({
      address: false
    });
  }
  parseUnits() {
    return 0n;
  }
  formatUnits() {
    return "0";
  }
  async getCapabilities() {
    return Promise.resolve({});
  }
  async grantPermissions() {
    return Promise.resolve({});
  }
  async revokePermissions() {
    return Promise.resolve("0x");
  }
  async syncConnection() {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: 1,
      provider: this.provider,
      address: ""
    });
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async switchNetwork(params) {
    var _a2, _b, _c2, _d, _e9, _f;
    const { caipNetwork } = params;
    const connector = this.getWalletConnectConnector();
    if (caipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM) {
      try {
        await ((_a2 = connector.provider) == null ? void 0 : _a2.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: toHex2(caipNetwork.id) }]
        }));
      } catch (switchError) {
        if (switchError.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_INVALID_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_CODE_DEFAULT || ((_c2 = (_b = switchError == null ? void 0 : switchError.data) == null ? void 0 : _b.originalError) == null ? void 0 : _c2.code) === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
          try {
            await ((_f = connector.provider) == null ? void 0 : _f.request({
              method: "wallet_addEthereumChain",
              params: [
                {
                  chainId: toHex2(caipNetwork.id),
                  rpcUrls: [(_d = caipNetwork == null ? void 0 : caipNetwork.rpcUrls["chainDefault"]) == null ? void 0 : _d.http],
                  chainName: caipNetwork.name,
                  nativeCurrency: caipNetwork.nativeCurrency,
                  blockExplorerUrls: [(_e9 = caipNetwork.blockExplorers) == null ? void 0 : _e9.default.url]
                }
              ]
            }));
          } catch (error) {
            throw new Error("Chain is not supported");
          }
        }
      }
    }
    connector.provider.setDefaultChain(caipNetwork.caipNetworkId);
  }
  getWalletConnectProvider() {
    const connector = this.connectors.find((c6) => c6.type === "WALLET_CONNECT");
    const provider = connector == null ? void 0 : connector.provider;
    return provider;
  }
};

// node_modules/@reown/appkit/dist/esm/src/client/appkit-base-client.js
var AppKitBaseClient = class {
  constructor(options) {
    var _a2;
    this.hasSwitchedToPreferredAccountTypeOnConnect = false;
    this.chainNamespaces = [];
    this.reportedAlertErrors = {};
    this.getCaipNetwork = (chainNamespace) => {
      var _a3, _b;
      if (chainNamespace) {
        const namespaceCaipNetwork = (_a3 = ChainController.getNetworkData(chainNamespace)) == null ? void 0 : _a3.caipNetwork;
        if (namespaceCaipNetwork) {
          return namespaceCaipNetwork;
        }
        return (_b = ChainController.getRequestedCaipNetworks(chainNamespace).filter((c6) => c6.chainNamespace === chainNamespace)) == null ? void 0 : _b[0];
      }
      return ChainController.state.activeCaipNetwork || this.defaultCaipNetwork;
    };
    this.getCaipNetworkId = () => {
      const network = this.getCaipNetwork();
      if (network) {
        return network.id;
      }
      return void 0;
    };
    this.getCaipNetworks = (namespace) => ChainController.getRequestedCaipNetworks(namespace);
    this.getActiveChainNamespace = () => ChainController.state.activeChain;
    this.setRequestedCaipNetworks = (requestedCaipNetworks, chain) => {
      ChainController.setRequestedCaipNetworks(requestedCaipNetworks, chain);
    };
    this.getApprovedCaipNetworkIds = () => ChainController.getAllApprovedCaipNetworkIds();
    this.getCaipAddress = (chainNamespace) => {
      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {
        return ChainController.state.activeCaipAddress;
      }
      return ChainController.getAccountProp("caipAddress", chainNamespace);
    };
    this.setClientId = (clientId) => {
      BlockchainApiController.setClientId(clientId);
    };
    this.getProvider = (namespace) => ProviderUtil.getProvider(namespace);
    this.getProviderType = (namespace) => ProviderUtil.getProviderId(namespace);
    this.getPreferredAccountType = () => AccountController.state.preferredAccountType;
    this.setCaipAddress = (caipAddress, chain) => {
      AccountController.setCaipAddress(caipAddress, chain);
    };
    this.setBalance = (balance, balanceSymbol, chain) => {
      AccountController.setBalance(balance, balanceSymbol, chain);
    };
    this.setProfileName = (profileName, chain) => {
      AccountController.setProfileName(profileName, chain);
    };
    this.setProfileImage = (profileImage, chain) => {
      AccountController.setProfileImage(profileImage, chain);
    };
    this.setUser = (user, chain) => {
      AccountController.setUser(user, chain);
      if (OptionsController.state.enableEmbedded) {
        ModalController.close();
      }
    };
    this.resetAccount = (chain) => {
      AccountController.resetAccount(chain);
    };
    this.setCaipNetwork = (caipNetwork) => {
      ChainController.setActiveCaipNetwork(caipNetwork);
    };
    this.setCaipNetworkOfNamespace = (caipNetwork, chainNamespace) => {
      ChainController.setChainNetworkData(chainNamespace, { caipNetwork });
    };
    this.setAllAccounts = (addresses, chain) => {
      AccountController.setAllAccounts(addresses, chain);
      OptionsController.setHasMultipleAddresses((addresses == null ? void 0 : addresses.length) > 1);
    };
    this.setStatus = (status, chain) => {
      AccountController.setStatus(status, chain);
      if (ConnectorController.isConnected()) {
        StorageUtil.setConnectionStatus("connected");
      } else {
        StorageUtil.setConnectionStatus("disconnected");
      }
    };
    this.getAddressByChainNamespace = (chainNamespace) => ChainController.getAccountProp("address", chainNamespace);
    this.setConnectors = (connectors) => {
      const allConnectors = [...ConnectorController.getConnectors(), ...connectors];
      ConnectorController.setConnectors(allConnectors);
    };
    this.fetchIdentity = (request) => BlockchainApiController.fetchIdentity(request);
    this.getReownName = (address) => EnsController.getNamesForAddress(address);
    this.getConnectors = () => ConnectorController.getConnectors();
    this.getConnectorImage = (connector) => AssetUtil.getConnectorImage(connector);
    this.setConnectedWalletInfo = (connectedWalletInfo, chain) => {
      const type = ProviderUtil.getProviderId(chain);
      const walletInfo = connectedWalletInfo ? { ...connectedWalletInfo, type } : void 0;
      AccountController.setConnectedWalletInfo(walletInfo, chain);
    };
    this.getIsConnectedState = () => Boolean(ChainController.state.activeCaipAddress);
    this.addAddressLabel = (address, label, chain) => {
      AccountController.addAddressLabel(address, label, chain);
    };
    this.removeAddressLabel = (address, chain) => {
      AccountController.removeAddressLabel(address, chain);
    };
    this.getAddress = (chainNamespace) => {
      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {
        return AccountController.state.address;
      }
      return ChainController.getAccountProp("address", chainNamespace);
    };
    this.setApprovedCaipNetworksData = (namespace) => ChainController.setApprovedCaipNetworksData(namespace);
    this.resetNetwork = (namespace) => {
      ChainController.resetNetwork(namespace);
    };
    this.addConnector = (connector) => {
      ConnectorController.addConnector(connector);
    };
    this.resetWcConnection = () => {
      ConnectionController.resetWcConnection();
    };
    this.setAddressExplorerUrl = (addressExplorerUrl, chain) => {
      AccountController.setAddressExplorerUrl(addressExplorerUrl, chain);
    };
    this.setSmartAccountDeployed = (isDeployed, chain) => {
      AccountController.setSmartAccountDeployed(isDeployed, chain);
    };
    this.setSmartAccountEnabledNetworks = (smartAccountEnabledNetworks, chain) => {
      ChainController.setSmartAccountEnabledNetworks(smartAccountEnabledNetworks, chain);
    };
    this.setPreferredAccountType = (preferredAccountType, chain) => {
      AccountController.setPreferredAccountType(preferredAccountType, chain);
    };
    this.setEIP6963Enabled = (enabled) => {
      OptionsController.setEIP6963Enabled(enabled);
    };
    this.handleUnsafeRPCRequest = () => {
      if (this.isOpen()) {
        if (this.isTransactionStackEmpty()) {
          return;
        }
        this.redirect("ApproveTransaction");
      } else {
        this.open({ view: "ApproveTransaction" });
      }
    };
    this.options = options;
    this.version = options.sdkVersion;
    this.caipNetworks = this.extendCaipNetworks(options);
    this.chainNamespaces = [
      ...new Set((_a2 = this.caipNetworks) == null ? void 0 : _a2.map((caipNetwork) => caipNetwork.chainNamespace))
    ];
    this.defaultCaipNetwork = this.extendDefaultCaipNetwork(options);
    this.chainAdapters = this.createAdapters(options.adapters);
    this.initialize(options);
    this.sendInitializeEvent(options);
  }
  async initialize(options) {
    this.initControllers(options);
    await this.initChainAdapters();
    await this.injectModalUi();
    await this.syncExistingConnection();
    PublicStateController.set({ initialized: true });
  }
  sendInitializeEvent(options) {
    var _a2;
    const { ...optionsCopy } = options;
    delete optionsCopy.adapters;
    EventsController.sendEvent({
      type: "track",
      event: "INITIALIZE",
      properties: {
        ...optionsCopy,
        networks: options.networks.map((n3) => n3.id),
        siweConfig: {
          options: ((_a2 = options.siweConfig) == null ? void 0 : _a2.options) || {}
        }
      }
    });
  }
  // -- Controllers initialization ---------------------------------------------------
  initControllers(options) {
    this.initializeOptionsController(options);
    this.initializeChainController(options);
    this.initializeThemeController(options);
    this.initializeConnectionController(options);
    this.initializeConnectorController();
  }
  initializeThemeController(options) {
    if (options.themeMode) {
      ThemeController.setThemeMode(options.themeMode);
    }
    if (options.themeVariables) {
      ThemeController.setThemeVariables(options.themeVariables);
    }
  }
  initializeChainController(options) {
    if (!this.connectionControllerClient || !this.networkControllerClient) {
      throw new Error("ConnectionControllerClient and NetworkControllerClient must be set");
    }
    ChainController.initialize(options.adapters ?? [], this.caipNetworks, {
      connectionControllerClient: this.connectionControllerClient,
      networkControllerClient: this.networkControllerClient
    });
    const network = this.getDefaultNetwork();
    if (network) {
      ChainController.setActiveCaipNetwork(network);
    }
  }
  initializeConnectionController(options) {
    ConnectionController.setWcBasic(options.basic ?? false);
  }
  initializeConnectorController() {
    ConnectorController.initialize(this.chainNamespaces);
  }
  initializeOptionsController(options) {
    var _a2;
    OptionsController.setDebug(options.debug !== false);
    OptionsController.setEnableWalletConnect(options.enableWalletConnect !== false);
    OptionsController.setEnableWalletGuide(options.enableWalletGuide !== false);
    OptionsController.setEnableWallets(options.enableWallets !== false);
    OptionsController.setEIP6963Enabled(options.enableEIP6963 !== false);
    OptionsController.setEnableNetworkSwitch(options.enableNetworkSwitch !== false);
    OptionsController.setEnableAuthLogger(options.enableAuthLogger !== false);
    OptionsController.setCustomRpcUrls(options.customRpcUrls);
    OptionsController.setSdkVersion(options.sdkVersion);
    OptionsController.setProjectId(options.projectId);
    OptionsController.setEnableEmbedded(options.enableEmbedded);
    OptionsController.setAllWallets(options.allWallets);
    OptionsController.setIncludeWalletIds(options.includeWalletIds);
    OptionsController.setExcludeWalletIds(options.excludeWalletIds);
    OptionsController.setFeaturedWalletIds(options.featuredWalletIds);
    OptionsController.setTokens(options.tokens);
    OptionsController.setTermsConditionsUrl(options.termsConditionsUrl);
    OptionsController.setPrivacyPolicyUrl(options.privacyPolicyUrl);
    OptionsController.setCustomWallets(options.customWallets);
    OptionsController.setFeatures(options.features);
    OptionsController.setAllowUnsupportedChain(options.allowUnsupportedChain);
    OptionsController.setDefaultAccountTypes(options.defaultAccountTypes);
    OptionsController.setUniversalProviderConfigOverride(options.universalProviderConfigOverride);
    const defaultMetaData = this.getDefaultMetaData();
    if (!options.metadata && defaultMetaData) {
      options.metadata = defaultMetaData;
    }
    OptionsController.setMetadata(options.metadata);
    OptionsController.setDisableAppend(options.disableAppend);
    OptionsController.setEnableEmbedded(options.enableEmbedded);
    OptionsController.setSIWX(options.siwx);
    if (!options.projectId) {
      AlertController.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
      return;
    }
    const evmAdapter = (_a2 = options.adapters) == null ? void 0 : _a2.find((adapter) => adapter.namespace === ConstantsUtil.CHAIN.EVM);
    if (evmAdapter) {
      if (options.siweConfig) {
        if (options.siwx) {
          throw new Error("Cannot set both `siweConfig` and `siwx` options");
        }
        OptionsController.setSIWX(options.siweConfig.mapToSIWX());
      }
    }
  }
  getDefaultMetaData() {
    var _a2, _b, _c2, _d;
    if (typeof window !== "undefined" && typeof document !== "undefined") {
      return {
        name: ((_b = (_a2 = document.getElementsByTagName("title")) == null ? void 0 : _a2[0]) == null ? void 0 : _b.textContent) || "",
        description: ((_c2 = document.querySelector('meta[property="og:description"]')) == null ? void 0 : _c2.content) || "",
        url: window.location.origin,
        icons: [((_d = document.querySelector('link[rel~="icon"]')) == null ? void 0 : _d.href) || ""]
      };
    }
    return null;
  }
  // -- Network Initialization ---------------------------------------------------
  setUnsupportedNetwork(chainId) {
    const namespace = this.getActiveChainNamespace();
    if (namespace) {
      const unsupportedNetwork = CaipNetworksUtil.getUnsupportedNetwork(`${namespace}:${chainId}`);
      ChainController.setActiveCaipNetwork(unsupportedNetwork);
    }
  }
  getDefaultNetwork() {
    return CaipNetworksUtil.getCaipNetworkFromStorage(this.defaultCaipNetwork);
  }
  extendCaipNetwork(network, options) {
    const extendedNetwork = CaipNetworksUtil.extendCaipNetwork(network, {
      customNetworkImageUrls: options.chainImages,
      projectId: options.projectId
    });
    return extendedNetwork;
  }
  extendCaipNetworks(options) {
    const extendedNetworks = CaipNetworksUtil.extendCaipNetworks(options.networks, {
      customNetworkImageUrls: options.chainImages,
      customRpcUrls: options.customRpcUrls,
      projectId: options.projectId
    });
    return extendedNetworks;
  }
  extendDefaultCaipNetwork(options) {
    const defaultNetwork = options.networks.find((n3) => {
      var _a2;
      return n3.id === ((_a2 = options.defaultNetwork) == null ? void 0 : _a2.id);
    });
    const extendedNetwork = defaultNetwork ? CaipNetworksUtil.extendCaipNetwork(defaultNetwork, {
      customNetworkImageUrls: options.chainImages,
      customRpcUrls: options.customRpcUrls,
      projectId: options.projectId
    }) : void 0;
    return extendedNetwork;
  }
  // -- Client Initialization ---------------------------------------------------
  createClients() {
    this.connectionControllerClient = {
      connectWalletConnect: async () => {
        var _a2;
        const activeChain = ChainController.state.activeChain;
        const adapter = this.getAdapter(activeChain);
        const chainId = (_a2 = this.getCaipNetwork(activeChain)) == null ? void 0 : _a2.id;
        if (!adapter) {
          throw new Error("Adapter not found");
        }
        const result = await adapter.connectWalletConnect(chainId);
        this.close();
        this.setClientId((result == null ? void 0 : result.clientId) || null);
        StorageUtil.setConnectedNamespaces([...ChainController.state.chains.keys()]);
        this.chainNamespaces.forEach((namespace) => {
          ConnectorController.setConnectorId(ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT, namespace);
        });
        await this.syncWalletConnectAccount();
      },
      connectExternal: async ({ id, info, type, provider, chain, caipNetwork }) => {
        var _a2, _b, _c2, _d, _e9, _f, _g;
        const activeChain = ChainController.state.activeChain;
        const chainToUse = chain || activeChain;
        const adapter = this.getAdapter(chainToUse);
        if (chain && chain !== activeChain && !caipNetwork) {
          const toConnectNetwork = (_a2 = this.caipNetworks) == null ? void 0 : _a2.find((network) => network.chainNamespace === chain);
          if (toConnectNetwork) {
            this.setCaipNetwork(toConnectNetwork);
          }
        }
        if (!adapter) {
          throw new Error("Adapter not found");
        }
        const fallbackCaipNetwork = this.getCaipNetwork(chainToUse);
        const res = await adapter.connect({
          id,
          info,
          type,
          provider,
          chainId: (caipNetwork == null ? void 0 : caipNetwork.id) || (fallbackCaipNetwork == null ? void 0 : fallbackCaipNetwork.id),
          rpcUrl: ((_d = (_c2 = (_b = caipNetwork == null ? void 0 : caipNetwork.rpcUrls) == null ? void 0 : _b.default) == null ? void 0 : _c2.http) == null ? void 0 : _d[0]) || ((_g = (_f = (_e9 = fallbackCaipNetwork == null ? void 0 : fallbackCaipNetwork.rpcUrls) == null ? void 0 : _e9.default) == null ? void 0 : _f.http) == null ? void 0 : _g[0])
        });
        if (!res) {
          return;
        }
        StorageUtil.addConnectedNamespace(chainToUse);
        this.syncProvider({ ...res, chainNamespace: chainToUse });
        await this.syncAccount({ ...res, chainNamespace: chainToUse });
        const { accounts } = await adapter.getAccounts({ namespace: chainToUse, id });
        this.setAllAccounts(accounts, chainToUse);
      },
      reconnectExternal: async ({ id, info, type, provider }) => {
        var _a2;
        const namespace = ChainController.state.activeChain;
        const adapter = this.getAdapter(namespace);
        if (adapter == null ? void 0 : adapter.reconnect) {
          await (adapter == null ? void 0 : adapter.reconnect({ id, info, type, provider, chainId: (_a2 = this.getCaipNetwork()) == null ? void 0 : _a2.id }));
          StorageUtil.addConnectedNamespace(namespace);
        }
      },
      disconnect: async (chainNamespace) => {
        const namespace = chainNamespace || ChainController.state.activeChain;
        const adapter = this.getAdapter(namespace);
        const provider = ProviderUtil.getProvider(namespace);
        const providerType = ProviderUtil.getProviderId(namespace);
        await (adapter == null ? void 0 : adapter.disconnect({ provider, providerType }));
        StorageUtil.removeConnectedNamespace(namespace);
        ProviderUtil.resetChain(namespace);
        this.setUser(void 0, namespace);
        this.setStatus("disconnected", namespace);
        this.hasSwitchedToPreferredAccountTypeOnConnect = false;
      },
      checkInstalled: (ids) => {
        if (!ids) {
          return Boolean(window.ethereum);
        }
        return ids.some((id) => {
          var _a2;
          return Boolean((_a2 = window.ethereum) == null ? void 0 : _a2[String(id)]);
        });
      },
      signMessage: async (message) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const result = await (adapter == null ? void 0 : adapter.signMessage({
          message,
          address: AccountController.state.address,
          provider: ProviderUtil.getProvider(ChainController.state.activeChain)
        }));
        return (result == null ? void 0 : result.signature) || "";
      },
      sendTransaction: async (args) => {
        if (args.chainNamespace === ConstantsUtil.CHAIN.EVM) {
          const adapter = this.getAdapter(ChainController.state.activeChain);
          const provider = ProviderUtil.getProvider(ChainController.state.activeChain);
          const result = await (adapter == null ? void 0 : adapter.sendTransaction({
            ...args,
            caipNetwork: this.getCaipNetwork(),
            provider
          }));
          return (result == null ? void 0 : result.hash) || "";
        }
        return "";
      },
      estimateGas: async (args) => {
        if (args.chainNamespace === ConstantsUtil.CHAIN.EVM) {
          const adapter = this.getAdapter(ChainController.state.activeChain);
          const provider = ProviderUtil.getProvider(ChainController.state.activeChain);
          const caipNetwork = this.getCaipNetwork();
          if (!caipNetwork) {
            throw new Error("CaipNetwork is undefined");
          }
          const result = await (adapter == null ? void 0 : adapter.estimateGas({
            ...args,
            provider,
            caipNetwork
          }));
          return (result == null ? void 0 : result.gas) || 0n;
        }
        return 0n;
      },
      getEnsAvatar: async () => {
        var _a2;
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const result = await (adapter == null ? void 0 : adapter.getProfile({
          address: AccountController.state.address,
          chainId: Number((_a2 = this.getCaipNetwork()) == null ? void 0 : _a2.id)
        }));
        return (result == null ? void 0 : result.profileImage) || false;
      },
      getEnsAddress: async (name) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const caipNetwork = this.getCaipNetwork();
        if (!caipNetwork) {
          return false;
        }
        const result = await (adapter == null ? void 0 : adapter.getEnsAddress({
          name,
          caipNetwork
        }));
        return (result == null ? void 0 : result.address) || false;
      },
      writeContract: async (args) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const caipNetwork = this.getCaipNetwork();
        const caipAddress = this.getCaipAddress();
        const provider = ProviderUtil.getProvider(ChainController.state.activeChain);
        if (!caipNetwork || !caipAddress) {
          throw new Error("CaipNetwork or CaipAddress is undefined");
        }
        const result = await (adapter == null ? void 0 : adapter.writeContract({ ...args, caipNetwork, provider, caipAddress }));
        return result == null ? void 0 : result.hash;
      },
      parseUnits: (value, decimals) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return (adapter == null ? void 0 : adapter.parseUnits({ value, decimals })) ?? 0n;
      },
      formatUnits: (value, decimals) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return (adapter == null ? void 0 : adapter.formatUnits({ value, decimals })) ?? "0";
      },
      getCapabilities: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return await (adapter == null ? void 0 : adapter.getCapabilities(params));
      },
      grantPermissions: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return await (adapter == null ? void 0 : adapter.grantPermissions(params));
      },
      revokePermissions: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (adapter == null ? void 0 : adapter.revokePermissions) {
          return await adapter.revokePermissions(params);
        }
        return "0x";
      },
      walletGetAssets: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return await (adapter == null ? void 0 : adapter.walletGetAssets(params)) ?? {};
      }
    };
    this.networkControllerClient = {
      switchCaipNetwork: async (caipNetwork) => await this.switchCaipNetwork(caipNetwork),
      // eslint-disable-next-line @typescript-eslint/require-await
      getApprovedCaipNetworksData: async () => this.getApprovedCaipNetworksData()
    };
    ConnectionController.setClient(this.connectionControllerClient);
  }
  getApprovedCaipNetworksData() {
    var _a2, _b, _c2, _d, _e9;
    const providerType = ProviderUtil.getProviderId(ChainController.state.activeChain);
    if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
      const namespaces = (_b = (_a2 = this.universalProvider) == null ? void 0 : _a2.session) == null ? void 0 : _b.namespaces;
      return {
        /*
         * MetaMask Wallet only returns 1 namespace in the session object. This makes it imposible
         * to switch to other networks. Setting supportsAllNetworks to true for MetaMask Wallet
         * will make it possible to switch to other networks.
         */
        supportsAllNetworks: ((_e9 = (_d = (_c2 = this.universalProvider) == null ? void 0 : _c2.session) == null ? void 0 : _d.peer) == null ? void 0 : _e9.metadata.name) === "MetaMask Wallet",
        approvedCaipNetworkIds: this.getChainsFromNamespaces(namespaces)
      };
    }
    return { supportsAllNetworks: true, approvedCaipNetworkIds: [] };
  }
  async switchCaipNetwork(caipNetwork) {
    if (!caipNetwork) {
      return;
    }
    const networkNamespace = caipNetwork.chainNamespace;
    const namespaceAddress = this.getAddressByChainNamespace(caipNetwork.chainNamespace);
    if (namespaceAddress) {
      const provider = ProviderUtil.getProvider(networkNamespace);
      const providerType = ProviderUtil.getProviderId(networkNamespace);
      if (caipNetwork.chainNamespace === ChainController.state.activeChain) {
        const adapter = this.getAdapter(networkNamespace);
        await (adapter == null ? void 0 : adapter.switchNetwork({ caipNetwork, provider, providerType }));
      } else {
        this.setCaipNetwork(caipNetwork);
        if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
          this.syncWalletConnectAccount();
        } else {
          const address = this.getAddressByChainNamespace(networkNamespace);
          if (address) {
            this.syncAccount({
              address,
              chainId: caipNetwork.id,
              chainNamespace: networkNamespace
            });
          }
        }
      }
    } else {
      this.setCaipNetwork(caipNetwork);
    }
  }
  getChainsFromNamespaces(namespaces = {}) {
    return Object.values(namespaces).flatMap((namespace) => {
      const chains = namespace.chains || [];
      const accountsChains = namespace.accounts.map((account) => {
        const { chainId, chainNamespace } = ParseUtil.parseCaipAddress(account);
        return `${chainNamespace}:${chainId}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...chains, ...accountsChains]));
    });
  }
  // -- Adapter Initialization ---------------------------------------------------
  createAdapters(blueprints) {
    this.createClients();
    return this.chainNamespaces.reduce((adapters, namespace) => {
      var _a2;
      const blueprint = blueprints == null ? void 0 : blueprints.find((b4) => b4.namespace === namespace);
      if (blueprint) {
        adapters[namespace] = blueprint;
        adapters[namespace].namespace = namespace;
        adapters[namespace].construct({
          namespace,
          projectId: (_a2 = this.options) == null ? void 0 : _a2.projectId,
          networks: this.caipNetworks
        });
      } else {
        adapters[namespace] = new UniversalAdapter({
          namespace,
          networks: this.caipNetworks
        });
      }
      return adapters;
    }, {});
  }
  async initChainAdapter(namespace) {
    var _a2;
    this.onConnectors(namespace);
    this.listenAdapter(namespace);
    (_a2 = this.chainAdapters) == null ? void 0 : _a2[namespace].syncConnectors(this.options, this);
    await this.createUniversalProviderForAdapter(namespace);
  }
  async initChainAdapters() {
    await Promise.all(this.chainNamespaces.map(async (namespace) => {
      await this.initChainAdapter(namespace);
    }));
  }
  onConnectors(chainNamespace) {
    const adapter = this.getAdapter(chainNamespace);
    adapter == null ? void 0 : adapter.on("connectors", this.setConnectors.bind(this));
  }
  listenAdapter(chainNamespace) {
    const adapter = this.getAdapter(chainNamespace);
    if (!adapter) {
      return;
    }
    const connectionStatus = StorageUtil.getConnectionStatus();
    if (connectionStatus === "connected") {
      this.setStatus("connecting", chainNamespace);
    } else if (connectionStatus === "disconnected") {
      StorageUtil.clearAddressCache();
      this.setStatus(connectionStatus, chainNamespace);
    } else {
      this.setStatus(connectionStatus, chainNamespace);
    }
    adapter.on("switchNetwork", ({ address, chainId }) => {
      var _a2;
      const caipNetwork = (_a2 = this.caipNetworks) == null ? void 0 : _a2.find((n3) => n3.id === chainId || n3.caipNetworkId === chainId);
      const isSameNamespace = ChainController.state.activeChain === chainNamespace;
      const accountAddress = ChainController.getAccountProp("address", chainNamespace);
      if (caipNetwork) {
        const account = isSameNamespace && address ? address : accountAddress;
        if (account) {
          this.syncAccount({ address: account, chainId, chainNamespace });
        }
      } else {
        this.setUnsupportedNetwork(chainId);
      }
    });
    adapter.on("disconnect", this.disconnect.bind(this, chainNamespace));
    adapter.on("pendingTransactions", () => {
      const address = AccountController.state.address;
      const activeCaipNetwork = ChainController.state.activeCaipNetwork;
      if (!address || !(activeCaipNetwork == null ? void 0 : activeCaipNetwork.id)) {
        return;
      }
      this.updateNativeBalance(address, activeCaipNetwork.id, activeCaipNetwork.chainNamespace);
    });
    adapter.on("accountChanged", ({ address, chainId }) => {
      var _a2, _b;
      const isActiveChain = ChainController.state.activeChain === chainNamespace;
      if (isActiveChain && chainId) {
        this.syncAccount({
          address,
          chainId,
          chainNamespace
        });
      } else if (isActiveChain && ((_a2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a2.id)) {
        this.syncAccount({
          address,
          chainId: (_b = ChainController.state.activeCaipNetwork) == null ? void 0 : _b.id,
          chainNamespace
        });
      } else {
        this.syncAccountInfo(address, chainId, chainNamespace);
      }
    });
  }
  async createUniversalProviderForAdapter(chainNamespace) {
    var _a2, _b, _c2;
    await this.getUniversalProvider();
    if (this.universalProvider) {
      (_c2 = (_b = (_a2 = this.chainAdapters) == null ? void 0 : _a2[chainNamespace]) == null ? void 0 : _b.setUniversalProvider) == null ? void 0 : _c2.call(_b, this.universalProvider);
    }
  }
  // -- Connection Sync ---------------------------------------------------
  async syncExistingConnection() {
    await Promise.allSettled(this.chainNamespaces.map((namespace) => this.syncNamespaceConnection(namespace)));
  }
  async syncNamespaceConnection(namespace) {
    try {
      const connectorId = ConnectorController.getConnectorId(namespace);
      this.setStatus("connecting", namespace);
      switch (connectorId) {
        case ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT:
          await this.syncWalletConnectAccount();
          break;
        case ConstantsUtil.CONNECTOR_ID.AUTH:
          break;
        default:
          await this.syncAdapterConnection(namespace);
      }
    } catch (err) {
      console.warn("AppKit couldn't sync existing connection", err);
      this.setStatus("disconnected", namespace);
    }
  }
  async syncAdapterConnection(namespace) {
    var _a2, _b, _c2;
    const adapter = this.getAdapter(namespace);
    const connectorId = ConnectorController.getConnectorId(namespace);
    const caipNetwork = this.getCaipNetwork(namespace);
    const connector = ConnectorController.getConnectors(namespace).find((c6) => c6.id === connectorId);
    try {
      if (!adapter || !connector) {
        throw new Error(`Adapter or connector not found for namespace ${namespace}`);
      }
      if (!(caipNetwork == null ? void 0 : caipNetwork.id)) {
        throw new Error("CaipNetwork not found");
      }
      const connection = await (adapter == null ? void 0 : adapter.syncConnection({
        namespace,
        id: connector.id,
        chainId: caipNetwork.id,
        rpcUrl: (_c2 = (_b = (_a2 = caipNetwork == null ? void 0 : caipNetwork.rpcUrls) == null ? void 0 : _a2.default) == null ? void 0 : _b.http) == null ? void 0 : _c2[0]
      }));
      if (connection) {
        const accounts = await (adapter == null ? void 0 : adapter.getAccounts({
          namespace,
          id: connector.id
        }));
        if (accounts && accounts.accounts.length > 0) {
          this.setAllAccounts(accounts.accounts, namespace);
        } else {
          this.setAllAccounts([CoreHelperUtil.createAccount(namespace, connection.address, "eoa")], namespace);
        }
        this.syncProvider({ ...connection, chainNamespace: namespace });
        await this.syncAccount({ ...connection, chainNamespace: namespace });
        this.setStatus("connected", namespace);
      } else {
        this.setStatus("disconnected", namespace);
      }
    } catch (e) {
      this.setStatus("disconnected", namespace);
    }
  }
  async syncWalletConnectAccount() {
    const syncTasks = this.chainNamespaces.map(async (chainNamespace) => {
      var _a2, _b, _c2, _d, _e9;
      const adapter = this.getAdapter(chainNamespace);
      const namespaceAccounts = ((_d = (_c2 = (_b = (_a2 = this.universalProvider) == null ? void 0 : _a2.session) == null ? void 0 : _b.namespaces) == null ? void 0 : _c2[chainNamespace]) == null ? void 0 : _d.accounts) || [];
      const activeChainId = (_e9 = ChainController.state.activeCaipNetwork) == null ? void 0 : _e9.id;
      const sessionAddress = namespaceAccounts.find((account) => {
        const { chainId } = ParseUtil.parseCaipAddress(account);
        return chainId === (activeChainId == null ? void 0 : activeChainId.toString());
      }) || namespaceAccounts[0];
      if (sessionAddress) {
        const caipAddress = ParseUtil.validateCaipAddress(sessionAddress);
        const { chainId, address } = ParseUtil.parseCaipAddress(caipAddress);
        ProviderUtil.setProviderId(chainNamespace, ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT);
        if (this.caipNetworks && ChainController.state.activeCaipNetwork && (adapter == null ? void 0 : adapter.namespace) !== ConstantsUtil.CHAIN.EVM) {
          const provider = adapter == null ? void 0 : adapter.getWalletConnectProvider({
            caipNetworks: this.caipNetworks,
            provider: this.universalProvider,
            activeCaipNetwork: ChainController.state.activeCaipNetwork
          });
          ProviderUtil.setProvider(chainNamespace, provider);
        } else {
          ProviderUtil.setProvider(chainNamespace, this.universalProvider);
        }
        ConnectorController.setConnectorId(ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT, chainNamespace);
        StorageUtil.addConnectedNamespace(chainNamespace);
        this.syncWalletConnectAccounts(chainNamespace);
        await this.syncAccount({
          address,
          chainId,
          chainNamespace
        });
      } else {
        this.setStatus("disconnected", chainNamespace);
      }
      await ChainController.setApprovedCaipNetworksData(chainNamespace);
    });
    await Promise.all(syncTasks);
  }
  syncWalletConnectAccounts(chainNamespace) {
    var _a2, _b, _c2, _d, _e9;
    const addresses = (_e9 = (_d = (_c2 = (_b = (_a2 = this.universalProvider) == null ? void 0 : _a2.session) == null ? void 0 : _b.namespaces) == null ? void 0 : _c2[chainNamespace]) == null ? void 0 : _d.accounts) == null ? void 0 : _e9.map((account) => {
      const { address } = ParseUtil.parseCaipAddress(account);
      return address;
    }).filter((address, index, self2) => self2.indexOf(address) === index);
    if (addresses) {
      this.setAllAccounts(addresses.map((address) => CoreHelperUtil.createAccount(chainNamespace, address, chainNamespace === "bip122" ? "payment" : "eoa")), chainNamespace);
    }
  }
  syncProvider({ type, provider, id, chainNamespace }) {
    ProviderUtil.setProviderId(chainNamespace, type);
    ProviderUtil.setProvider(chainNamespace, provider);
    ConnectorController.setConnectorId(id, chainNamespace);
  }
  async syncAccount(params) {
    var _a2, _b, _c2, _d, _e9, _f;
    const isActiveNamespace = params.chainNamespace === ChainController.state.activeChain;
    const networkOfChain = ChainController.getCaipNetworkByNamespace(params.chainNamespace, params.chainId);
    const { address, chainId, chainNamespace } = params;
    const { chainId: activeChainId } = StorageUtil.getActiveNetworkProps();
    const chainIdToUse = chainId || activeChainId;
    const isUnsupportedNetwork = ((_a2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a2.name) === ConstantsUtil.UNSUPPORTED_NETWORK_NAME;
    const shouldSupportAllNetworks = ChainController.getNetworkProp("supportsAllNetworks", chainNamespace);
    this.setStatus("connected", chainNamespace);
    if (isUnsupportedNetwork && !shouldSupportAllNetworks) {
      return;
    }
    if (chainIdToUse) {
      let caipNetwork = (_b = this.caipNetworks) == null ? void 0 : _b.find((n3) => n3.id.toString() === chainIdToUse.toString());
      let fallbackCaipNetwork = (_c2 = this.caipNetworks) == null ? void 0 : _c2.find((n3) => n3.chainNamespace === chainNamespace);
      if (!shouldSupportAllNetworks && !caipNetwork && !fallbackCaipNetwork) {
        const caipNetworkIds = this.getApprovedCaipNetworkIds() || [];
        const caipNetworkId = caipNetworkIds.find((id) => {
          var _a3;
          return ((_a3 = ParseUtil.parseCaipNetworkId(id)) == null ? void 0 : _a3.chainId) === chainIdToUse.toString();
        });
        const fallBackCaipNetworkId = caipNetworkIds.find((id) => {
          var _a3;
          return ((_a3 = ParseUtil.parseCaipNetworkId(id)) == null ? void 0 : _a3.chainNamespace) === chainNamespace;
        });
        caipNetwork = (_d = this.caipNetworks) == null ? void 0 : _d.find((n3) => n3.caipNetworkId === caipNetworkId);
        fallbackCaipNetwork = (_e9 = this.caipNetworks) == null ? void 0 : _e9.find((n3) => n3.caipNetworkId === fallBackCaipNetworkId || // This is a workaround used in Solana network to support deprecated caipNetworkId
        "deprecatedCaipNetworkId" in n3 && n3.deprecatedCaipNetworkId === fallBackCaipNetworkId);
      }
      const network = caipNetwork || fallbackCaipNetwork;
      if ((network == null ? void 0 : network.chainNamespace) === ChainController.state.activeChain) {
        if (OptionsController.state.enableNetworkSwitch && !OptionsController.state.allowUnsupportedChain && ((_f = ChainController.state.activeCaipNetwork) == null ? void 0 : _f.name) === ConstantsUtil.UNSUPPORTED_NETWORK_NAME) {
          ChainController.showUnsupportedChainUI();
        } else {
          this.setCaipNetwork(network);
        }
      } else if (!isActiveNamespace) {
        if (networkOfChain) {
          this.setCaipNetworkOfNamespace(networkOfChain, chainNamespace);
        }
      }
      this.syncConnectedWalletInfo(chainNamespace);
      if (!HelpersUtil.isLowerCaseMatch(address, AccountController.state.address)) {
        this.syncAccountInfo(address, network == null ? void 0 : network.id, chainNamespace);
      }
      if (isActiveNamespace) {
        await this.syncBalance({ address, chainId: network == null ? void 0 : network.id, chainNamespace });
      } else {
        await this.syncBalance({ address, chainId: networkOfChain == null ? void 0 : networkOfChain.id, chainNamespace });
      }
    }
  }
  async syncAccountInfo(address, chainId, chainNamespace) {
    const caipAddress = this.getCaipAddress(chainNamespace);
    const newChainId = chainId || (caipAddress == null ? void 0 : caipAddress.split(":")[1]);
    if (!newChainId) {
      return;
    }
    const newCaipAddress = `${chainNamespace}:${newChainId}:${address}`;
    this.setCaipAddress(newCaipAddress, chainNamespace);
    await this.syncIdentity({
      address,
      chainId: newChainId,
      chainNamespace
    });
  }
  async syncReownName(address, chainNamespace) {
    try {
      const registeredWcNames = await this.getReownName(address);
      if (registeredWcNames[0]) {
        const wcName = registeredWcNames[0];
        this.setProfileName(wcName.name, chainNamespace);
      } else {
        this.setProfileName(null, chainNamespace);
      }
    } catch {
      this.setProfileName(null, chainNamespace);
    }
  }
  syncConnectedWalletInfo(chainNamespace) {
    var _a2;
    const connectorId = ConnectorController.getConnectorId(chainNamespace);
    const providerType = ProviderUtil.getProviderId(chainNamespace);
    if (providerType === ConstantsUtil3.CONNECTOR_TYPE_ANNOUNCED || providerType === ConstantsUtil3.CONNECTOR_TYPE_INJECTED) {
      if (connectorId) {
        const connector = this.getConnectors().find((c6) => c6.id === connectorId);
        if (connector) {
          const { info, name, imageUrl } = connector;
          const icon2 = imageUrl || this.getConnectorImage(connector);
          this.setConnectedWalletInfo({ name, icon: icon2, ...info }, chainNamespace);
        }
      }
    } else if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
      const provider = ProviderUtil.getProvider(chainNamespace);
      if (provider == null ? void 0 : provider.session) {
        this.setConnectedWalletInfo({
          ...provider.session.peer.metadata,
          name: provider.session.peer.metadata.name,
          icon: (_a2 = provider.session.peer.metadata.icons) == null ? void 0 : _a2[0]
        }, chainNamespace);
      }
    } else if (connectorId) {
      if (connectorId === ConstantsUtil.CONNECTOR_ID.COINBASE) {
        const connector = this.getConnectors().find((c6) => c6.id === ConstantsUtil.CONNECTOR_ID.COINBASE);
        this.setConnectedWalletInfo({ name: "Coinbase Wallet", icon: this.getConnectorImage(connector) }, chainNamespace);
      } else {
        this.setConnectedWalletInfo({ name: connectorId }, chainNamespace);
      }
    }
  }
  async syncBalance(params) {
    const caipNetwork = NetworkUtil.getNetworksByNamespace(this.caipNetworks, params.chainNamespace).find((n3) => {
      var _a2;
      return n3.id.toString() === ((_a2 = params.chainId) == null ? void 0 : _a2.toString());
    });
    if (!caipNetwork || !params.chainId) {
      return;
    }
    await this.updateNativeBalance(params.address, params.chainId, params.chainNamespace);
  }
  async updateNativeBalance(address, chainId, namespace) {
    const adapter = this.getAdapter(namespace);
    if (adapter) {
      const balance = await adapter.getBalance({
        address,
        chainId,
        caipNetwork: this.getCaipNetwork(namespace),
        tokens: this.options.tokens
      });
      this.setBalance(balance.balance, balance.symbol, namespace);
    }
  }
  // -- Universal Provider ---------------------------------------------------
  async initializeUniversalAdapter() {
    var _a2, _b, _c2, _d, _e9, _f, _g, _h, _i4, _j;
    const logger = LoggerUtil.createLogger((error, ...args) => {
      if (error) {
        this.handleAlertError(error);
      }
      console.error(...args);
    });
    const universalProviderOptions = {
      projectId: (_a2 = this.options) == null ? void 0 : _a2.projectId,
      metadata: {
        name: ((_b = this.options) == null ? void 0 : _b.metadata) ? (_c2 = this.options) == null ? void 0 : _c2.metadata.name : "",
        description: ((_d = this.options) == null ? void 0 : _d.metadata) ? (_e9 = this.options) == null ? void 0 : _e9.metadata.description : "",
        url: ((_f = this.options) == null ? void 0 : _f.metadata) ? (_g = this.options) == null ? void 0 : _g.metadata.url : "",
        icons: ((_h = this.options) == null ? void 0 : _h.metadata) ? (_i4 = this.options) == null ? void 0 : _i4.metadata.icons : [""]
      },
      logger
    };
    OptionsController.setManualWCControl(Boolean((_j = this.options) == null ? void 0 : _j.manualWCControl));
    this.universalProvider = this.options.universalProvider ?? await x8.init(universalProviderOptions);
    this.listenWalletConnect();
  }
  listenWalletConnect() {
    if (this.universalProvider) {
      this.universalProvider.on("display_uri", (uri) => {
        ConnectionController.setUri(uri);
      });
      this.universalProvider.on("connect", ConnectionController.finalizeWcConnection);
      this.universalProvider.on("disconnect", () => {
        this.chainNamespaces.forEach((namespace) => {
          this.resetAccount(namespace);
        });
        ConnectionController.resetWcConnection();
      });
      this.universalProvider.on("chainChanged", (chainId) => {
        var _a2;
        const caipNetwork = (_a2 = this.caipNetworks) == null ? void 0 : _a2.find((c6) => c6.id == chainId);
        const currentCaipNetwork = this.getCaipNetwork();
        if (!caipNetwork) {
          this.setUnsupportedNetwork(chainId);
          return;
        }
        if ((currentCaipNetwork == null ? void 0 : currentCaipNetwork.id) !== (caipNetwork == null ? void 0 : caipNetwork.id)) {
          this.setCaipNetwork(caipNetwork);
        }
      });
      this.universalProvider.on("session_event", (callbackData) => {
        if (WcHelpersUtil.isSessionEventData(callbackData)) {
          const { name, data } = callbackData.params.event;
          if (name === "accountsChanged" && Array.isArray(data) && CoreHelperUtil.isCaipAddress(data[0])) {
            this.syncAccount(ParseUtil.parseCaipAddress(data[0]));
          }
        }
      });
    }
  }
  createUniversalProvider() {
    var _a2;
    if (!this.universalProviderInitPromise && CoreHelperUtil.isClient() && ((_a2 = this.options) == null ? void 0 : _a2.projectId)) {
      this.universalProviderInitPromise = this.initializeUniversalAdapter();
    }
    return this.universalProviderInitPromise;
  }
  async getUniversalProvider() {
    if (!this.universalProvider) {
      try {
        await this.createUniversalProvider();
      } catch (err) {
        EventsController.sendEvent({
          type: "error",
          event: "INTERNAL_SDK_ERROR",
          properties: {
            errorType: "UniversalProviderInitError",
            errorMessage: err instanceof Error ? err.message : "Unknown",
            uncaught: false
          }
        });
        console.error("AppKit:getUniversalProvider - Cannot create provider", err);
      }
    }
    return this.universalProvider;
  }
  // - Utils -------------------------------------------------------------------
  handleAlertError(error) {
    const matchedUniversalProviderError = Object.entries(ErrorUtil.UniversalProviderErrors).find(([, { message: message2 }]) => error.message.includes(message2));
    const [errorKey, errorValue] = matchedUniversalProviderError ?? [];
    const { message, alertErrorKey } = errorValue ?? {};
    if (errorKey && message && !this.reportedAlertErrors[errorKey]) {
      const alertError = ErrorUtil.ALERT_ERRORS[alertErrorKey];
      if (alertError) {
        AlertController.open(alertError, "error");
        this.reportedAlertErrors[errorKey] = true;
      }
    }
  }
  getAdapter(namespace) {
    var _a2;
    if (!namespace) {
      return void 0;
    }
    return (_a2 = this.chainAdapters) == null ? void 0 : _a2[namespace];
  }
  createAdapter(blueprint) {
    var _a2;
    if (!blueprint) {
      return;
    }
    const namespace = blueprint.namespace;
    if (!namespace) {
      return;
    }
    this.createClients();
    const adapterBlueprint = blueprint;
    adapterBlueprint.namespace = namespace;
    adapterBlueprint.construct({
      namespace,
      projectId: (_a2 = this.options) == null ? void 0 : _a2.projectId,
      networks: this.caipNetworks
    });
    if (!this.chainNamespaces.includes(namespace)) {
      this.chainNamespaces.push(namespace);
    }
    if (this.chainAdapters) {
      this.chainAdapters[namespace] = adapterBlueprint;
    }
  }
  // -- Public -------------------------------------------------------------------
  async open(options) {
    await this.injectModalUi();
    if (options == null ? void 0 : options.uri) {
      ConnectionController.setUri(options.uri);
    }
    await ModalController.open(options);
  }
  async close() {
    await this.injectModalUi();
    ModalController.close();
  }
  setLoading(loading, namespace) {
    ModalController.setLoading(loading, namespace);
  }
  async disconnect(chainNamespace) {
    await ConnectionController.disconnect(chainNamespace);
  }
  // -- review these -------------------------------------------------------------------
  getError() {
    return "";
  }
  getChainId() {
    var _a2;
    return (_a2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a2.id;
  }
  async switchNetwork(appKitNetwork) {
    var _a2;
    const network = (_a2 = this.caipNetworks) == null ? void 0 : _a2.find((n3) => n3.id === appKitNetwork.id);
    if (!network) {
      AlertController.open(ErrorUtil.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND, "error");
      return;
    }
    await ChainController.switchActiveNetwork(network);
  }
  getWalletProvider() {
    return ChainController.state.activeChain ? ProviderUtil.state.providers[ChainController.state.activeChain] : null;
  }
  getWalletProviderType() {
    return ProviderUtil.getProviderId(ChainController.state.activeChain);
  }
  subscribeProviders(callback) {
    return ProviderUtil.subscribeProviders(callback);
  }
  getThemeMode() {
    return ThemeController.state.themeMode;
  }
  getThemeVariables() {
    return ThemeController.state.themeVariables;
  }
  setThemeMode(themeMode) {
    ThemeController.setThemeMode(themeMode);
    setColorTheme(ThemeController.state.themeMode);
  }
  setTermsConditionsUrl(termsConditionsUrl) {
    OptionsController.setTermsConditionsUrl(termsConditionsUrl);
  }
  setPrivacyPolicyUrl(privacyPolicyUrl) {
    OptionsController.setPrivacyPolicyUrl(privacyPolicyUrl);
  }
  setThemeVariables(themeVariables) {
    ThemeController.setThemeVariables(themeVariables);
    setThemeVariables(ThemeController.state.themeVariables);
  }
  subscribeTheme(callback) {
    return ThemeController.subscribe(callback);
  }
  getWalletInfo() {
    return AccountController.state.connectedWalletInfo;
  }
  getAccount(namespace) {
    const authConnector = ConnectorController.getAuthConnector(namespace);
    const accountState = ChainController.getAccountData(namespace);
    if (!accountState) {
      return void 0;
    }
    return {
      allAccounts: accountState.allAccounts,
      caipAddress: accountState.caipAddress,
      address: CoreHelperUtil.getPlainAddress(accountState.caipAddress),
      isConnected: Boolean(accountState.caipAddress),
      status: accountState.status,
      embeddedWalletInfo: authConnector ? {
        user: accountState.user,
        authProvider: accountState.socialProvider || "email",
        accountType: accountState.preferredAccountType,
        isSmartAccountDeployed: Boolean(accountState.smartAccountDeployed)
      } : void 0
    };
  }
  subscribeAccount(callback, namespace) {
    const updateVal = () => {
      const account = this.getAccount(namespace);
      if (!account) {
        return;
      }
      callback(account);
    };
    if (namespace) {
      ChainController.subscribeChainProp("accountState", updateVal, namespace);
    } else {
      ChainController.subscribe(updateVal);
    }
    ConnectorController.subscribe(updateVal);
  }
  subscribeNetwork(callback) {
    return ChainController.subscribe(({ activeCaipNetwork }) => {
      callback({
        caipNetwork: activeCaipNetwork,
        chainId: activeCaipNetwork == null ? void 0 : activeCaipNetwork.id,
        caipNetworkId: activeCaipNetwork == null ? void 0 : activeCaipNetwork.caipNetworkId
      });
    });
  }
  subscribeWalletInfo(callback) {
    return AccountController.subscribeKey("connectedWalletInfo", callback);
  }
  subscribeShouldUpdateToAddress(callback) {
    AccountController.subscribeKey("shouldUpdateToAddress", callback);
  }
  subscribeCaipNetworkChange(callback) {
    ChainController.subscribeKey("activeCaipNetwork", callback);
  }
  getState() {
    return PublicStateController.state;
  }
  subscribeState(callback) {
    return PublicStateController.subscribe(callback);
  }
  showErrorMessage(message) {
    SnackController.showError(message);
  }
  showSuccessMessage(message) {
    SnackController.showSuccess(message);
  }
  getEvent() {
    return { ...EventsController.state };
  }
  subscribeEvents(callback) {
    return EventsController.subscribe(callback);
  }
  replace(route) {
    RouterController.replace(route);
  }
  redirect(route) {
    RouterController.push(route);
  }
  popTransactionStack(cancel) {
    RouterController.popTransactionStack(cancel);
  }
  isOpen() {
    return ModalController.state.open;
  }
  isTransactionStackEmpty() {
    return RouterController.state.transactionStack.length === 0;
  }
  isTransactionShouldReplaceView() {
    var _a2;
    return (_a2 = RouterController.state.transactionStack[RouterController.state.transactionStack.length - 1]) == null ? void 0 : _a2.replace;
  }
  static getInstance() {
    return this.instance;
  }
  updateFeatures(newFeatures) {
    OptionsController.setFeatures(newFeatures);
  }
  updateOptions(newOptions) {
    const currentOptions = OptionsController.state || {};
    const updatedOptions = { ...currentOptions, ...newOptions };
    OptionsController.setOptions(updatedOptions);
  }
  setConnectMethodsOrder(connectMethodsOrder) {
    OptionsController.setConnectMethodsOrder(connectMethodsOrder);
  }
  setWalletFeaturesOrder(walletFeaturesOrder) {
    OptionsController.setWalletFeaturesOrder(walletFeaturesOrder);
  }
  setCollapseWallets(collapseWallets) {
    OptionsController.setCollapseWallets(collapseWallets);
  }
  setSocialsOrder(socialsOrder) {
    OptionsController.setSocialsOrder(socialsOrder);
  }
  getConnectMethodsOrder() {
    return WalletUtil.getConnectOrderMethod(OptionsController.state.features, ConnectorController.getConnectors());
  }
  /**
   * Removes an adapter from the AppKit.
   * @param namespace - The namespace of the adapter to remove.
   */
  removeAdapter(namespace) {
    var _a2;
    const isConnected = this.getIsConnectedState();
    const adapter = this.getAdapter(namespace);
    if (!adapter || !this.chainAdapters || isConnected) {
      return;
    }
    const newCaipNetworks = (_a2 = this.caipNetworks) == null ? void 0 : _a2.filter((network) => network.chainNamespace !== namespace);
    ChainController.removeAdapter(namespace);
    ConnectorController.removeAdapter(namespace);
    this.chainNamespaces = this.chainNamespaces.filter((n3) => n3 !== namespace);
    this.caipNetworks = newCaipNetworks;
    adapter.removeAllEventListeners();
    Reflect.deleteProperty(this.chainAdapters, namespace);
  }
  /**
   * Adds an adapter to the AppKit.
   * @param adapter - The adapter instance.
   * @param networks - The list of networks that this adapter supports / uses.
   */
  addAdapter(adapter, networks) {
    const namespace = adapter.namespace;
    if (!this.connectionControllerClient || !this.networkControllerClient) {
      return;
    }
    if (!this.chainAdapters || !namespace) {
      return;
    }
    const extendedAdapterNetworks = this.extendCaipNetworks({ ...this.options, networks });
    this.caipNetworks = [...this.caipNetworks || [], ...extendedAdapterNetworks];
    this.createAdapter(adapter);
    this.initChainAdapter(namespace);
    ChainController.addAdapter(adapter, {
      connectionControllerClient: this.connectionControllerClient,
      networkControllerClient: this.networkControllerClient
    }, extendedAdapterNetworks);
  }
  /**
   * Adds a network to an existing adapter in AppKit.
   * @param namespace - The chain namespace to add the network to (e.g. 'eip155', 'solana')
   * @param network - The network configuration to add
   * @throws Error if adapter for namespace doesn't exist
   */
  addNetwork(namespace, network) {
    var _a2;
    if (this.chainAdapters && !this.chainAdapters[namespace]) {
      throw new Error(`Adapter for namespace ${namespace} doesn't exist`);
    }
    const extendedNetwork = this.extendCaipNetwork(network, this.options);
    ChainController.addNetwork(extendedNetwork);
    if (this.caipNetworks && !((_a2 = this.caipNetworks) == null ? void 0 : _a2.find((n3) => n3.id === extendedNetwork.id))) {
      this.caipNetworks.push(extendedNetwork);
    }
  }
  /**
   * Removes a network from an existing adapter in AppKit.
   * @param namespace - The chain namespace the network belongs to
   * @param networkId - The network ID to remove
   * @throws Error if adapter for namespace doesn't exist or if removing last network
   */
  removeNetwork(namespace, networkId) {
    var _a2;
    if (this.chainAdapters && !this.chainAdapters[namespace]) {
      throw new Error(`Adapter for namespace ${namespace} doesn't exist`);
    }
    const networkToRemove = (_a2 = this.caipNetworks) == null ? void 0 : _a2.find((n3) => n3.id === networkId);
    if (!networkToRemove) {
      throw new Error(`Network with ID ${networkId} not found`);
    }
    if (!this.caipNetworks) {
      return;
    }
    const remainingNetworks = this.caipNetworks.filter((n3) => n3.chainNamespace === namespace && n3.id !== networkId);
    if (!(remainingNetworks == null ? void 0 : remainingNetworks.length)) {
      throw new Error("Cannot remove last network for a namespace");
    }
    ChainController.removeNetwork(namespace, networkId);
    this.caipNetworks = [...remainingNetworks];
  }
};

// node_modules/@reown/appkit/dist/esm/src/client/appkit-core.js
var isInitialized = false;
var AppKit = class extends AppKitBaseClient {
  // -- Overrides --------------------------------------------------------------
  async open(options) {
    const isConnected = ConnectorController.isConnected();
    if (!isConnected) {
      await super.open(options);
    }
  }
  async close() {
    await super.close();
    if (this.options.manualWCControl) {
      ConnectionController.finalizeWcConnection();
    }
  }
  async syncIdentity(_request) {
    return Promise.resolve();
  }
  async syncBalance(_params) {
    return Promise.resolve();
  }
  async injectModalUi() {
    if (!isInitialized && CoreHelperUtil.isClient()) {
      await import("./basic-4MZ7IBTM.js");
      await import("./w3m-modal-FLBZ2JDV.js");
      const isElementCreated = document.querySelector("w3m-modal");
      if (!isElementCreated) {
        const modal = document.createElement("w3m-modal");
        if (!OptionsController.state.disableAppend && !OptionsController.state.enableEmbedded) {
          document.body.insertAdjacentElement("beforeend", modal);
        }
      }
      isInitialized = true;
    }
  }
};

// node_modules/@reown/appkit/dist/esm/exports/constants.js
var PACKAGE_VERSION = "1.7.2";

// node_modules/@reown/appkit/dist/esm/exports/core.js
function createAppKit(options) {
  return new AppKit({
    ...options,
    basic: true,
    sdkVersion: `html-core-${PACKAGE_VERSION}`
  });
}

// node_modules/@walletconnect/solana-adapter/node_modules/base-x/src/esm/index.js
function base4(ALPHABET4) {
  if (ALPHABET4.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j5 = 0; j5 < BASE_MAP.length; j5++) {
    BASE_MAP[j5] = 255;
  }
  for (let i3 = 0; i3 < ALPHABET4.length; i3++) {
    const x9 = ALPHABET4.charAt(i3);
    const xc2 = x9.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x9 + " is ambiguous");
    }
    BASE_MAP[xc2] = i3;
  }
  const BASE = ALPHABET4.length;
  const LEADER = ALPHABET4.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE);
  function encode7(source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size7 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size7);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i3 = 0;
      for (let it1 = size7 - 1; (carry !== 0 || i3 < length) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i3;
      pbegin++;
    }
    let it22 = size7 - length;
    while (it22 !== size7 && b58[it22] === 0) {
      it22++;
    }
    let str = LEADER.repeat(zeroes);
    for (; it22 < size7; ++it22) {
      str += ALPHABET4.charAt(b58[it22]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size7 = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size7);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i3 = 0;
      for (let it32 = size7 - 1; (carry !== 0 || i3 < length) && it32 !== -1; it32--, i3++) {
        carry += BASE * b256[it32] >>> 0;
        b256[it32] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i3;
      psz++;
    }
    let it42 = size7 - length;
    while (it42 !== size7 && b256[it42] === 0) {
      it42++;
    }
    const vch = new Uint8Array(zeroes + (size7 - it42));
    let j5 = zeroes;
    while (it42 !== size7) {
      vch[j5++] = b256[it42++];
    }
    return vch;
  }
  function decode3(string) {
    const buffer = decodeUnsafe(string);
    if (buffer) {
      return buffer;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode7,
    decodeUnsafe,
    decode: decode3
  };
}
var esm_default5 = base4;

// node_modules/@walletconnect/solana-adapter/node_modules/bs58/src/esm/index.js
var ALPHABET3 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default6 = esm_default5(ALPHABET3);

// node_modules/@walletconnect/solana-adapter/dist/errors/ClientNotInitializedError.js
var ClientNotInitializedError = class _ClientNotInitializedError extends Error {
  constructor() {
    super();
    Object.setPrototypeOf(this, _ClientNotInitializedError.prototype);
  }
};

// node_modules/@walletconnect/solana-adapter/dist/errors/WalletConnectNotSupportedError.js
var WalletConnectFeatureNotSupportedError = class extends Error {
  constructor(method) {
    super(`WalletConnect Adapter - Method ${method} is not supported by the wallet`);
    this.name = "WalletConnectFeatureNotSupportedError";
  }
};

// node_modules/@walletconnect/solana-adapter/dist/utils.js
function getChainsFromChainId(chainId) {
  let chains = [chainId];
  if (chainId === SolanaChainIDs.Mainnet || chainId === SolanaChainIDs.Deprecated_Mainnet) {
    chains = [SolanaChainIDs.Mainnet, SolanaChainIDs.Deprecated_Mainnet];
    if (chainId === SolanaChainIDs.Deprecated_Mainnet) {
      console.warn(chainWarns.mainnet);
    }
  } else if (chainId === SolanaChainIDs.Deprecated_Devnet || chainId === SolanaChainIDs.Devnet) {
    chains = [SolanaChainIDs.Devnet, SolanaChainIDs.Deprecated_Devnet];
    if (SolanaChainIDs.Deprecated_Devnet) {
      console.warn(chainWarns.devnet);
    }
  }
  return chains;
}
var chainWarns = {
  mainnet: `You are using a deprecated chain ID for Solana Mainnet, please use ${SolanaChainIDs.Mainnet} instead.`,
  devnet: `You are using a deprecated chain ID for Solana Devnet, please use ${SolanaChainIDs.Devnet} instead.`,
  wallet: "The connected wallet is using a deprecated chain ID for Solana. Please, contact them to upgrade. You can learn more at https://github.com/ChainAgnostic/namespaces/blob/main/solana/caip10.md#chain-ids"
};
function getDefaultChainFromSession(session, selectedChain) {
  var _a2;
  const chains = (_a2 = session.namespaces["solana"]) == null ? void 0 : _a2.accounts.map((account) => `solana:${account.split(":")[1]}`);
  if (selectedChain === SolanaChainIDs.Mainnet) {
    if (chains == null ? void 0 : chains.find((chain) => chain === SolanaChainIDs.Mainnet)) {
      return SolanaChainIDs.Mainnet;
    }
    console.warn(chainWarns.wallet);
    return SolanaChainIDs.Deprecated_Mainnet;
  } else if (selectedChain === SolanaChainIDs.Devnet) {
    if (chains == null ? void 0 : chains.find((chain) => chain === SolanaChainIDs.Devnet)) {
      return SolanaChainIDs.Devnet;
    }
    console.warn(chainWarns.wallet);
    return SolanaChainIDs.Deprecated_Devnet;
  }
  throw Error("WalletConnect Solana Adapter: Unable to get a default chain from the session.");
}
function getConnectParams(chainId) {
  const chains = getChainsFromChainId(chainId);
  return {
    optionalNamespaces: {
      solana: {
        chains,
        methods: [WalletConnectRPCMethods.signTransaction, WalletConnectRPCMethods.signMessage],
        events: []
      }
    }
  };
}

// node_modules/@walletconnect/solana-adapter/dist/errors/QRCodeModalError.js
var QRCodeModalError = class _QRCodeModalError extends Error {
  constructor() {
    super("QR Code Modal was closed by user");
    Object.setPrototypeOf(this, _QRCodeModalError.prototype);
    this.name = "QRCodeModalError";
  }
};

// node_modules/@walletconnect/solana-adapter/dist/core.js
var WalletConnectWallet = class {
  constructor(config) {
    __publicField(this, "_UniversalProvider");
    __publicField(this, "_session");
    __publicField(this, "_modal");
    __publicField(this, "_projectId");
    __publicField(this, "_network");
    __publicField(this, "_ConnectQueueResolver");
    this.initClient(config.options);
    this._network = config.network;
    if (!config.options.projectId) {
      throw Error("WalletConnect Adapter: Project ID is undefined");
    }
    this._projectId = config.options.projectId;
  }
  async connect() {
    var _a2, _b, _c2, _d, _e9, _f;
    if (!this._UniversalProvider) {
      await new Promise((res) => {
        this._ConnectQueueResolver = res;
      });
    }
    if (!this._UniversalProvider) {
      throw new Error("WalletConnect Adapter - Universal Provider was undefined while calling 'connect()'");
    }
    if (this._UniversalProvider.session) {
      this._session = this._UniversalProvider.session;
      const defaultNetwork = getDefaultChainFromSession(this._session, this._network);
      this._network = defaultNetwork;
      this._UniversalProvider.setDefaultChain(defaultNetwork);
      return {
        publicKey: this.publicKey
      };
    }
    await this.initModal();
    const params = getConnectParams(this._network);
    (_a2 = this._modal) == null ? void 0 : _a2.open();
    const controller = new AbortController();
    const signal = controller.signal;
    (_b = this._modal) == null ? void 0 : _b.subscribeState((state) => {
      if (!state.open) {
        controller.abort(new QRCodeModalError());
      }
    });
    try {
      const session = await Promise.race([
        (_c2 = this._UniversalProvider) == null ? void 0 : _c2.connect(params),
        new Promise((_7, reject) => {
          signal.addEventListener("abort", () => {
            reject(signal.reason);
          });
        })
      ]);
      (_d = this._modal) == null ? void 0 : _d.close();
      this._session = session;
      if (!session) {
        throw new WalletConnectionError();
      }
      const defaultNetwork = getDefaultChainFromSession(session, this._network);
      this._network = defaultNetwork;
      (_e9 = this._UniversalProvider) == null ? void 0 : _e9.setDefaultChain(defaultNetwork);
      return { publicKey: this.publicKey };
    } catch (error) {
      (_f = this._modal) == null ? void 0 : _f.close();
      throw error;
    }
  }
  async disconnect() {
    var _a2;
    if ((_a2 = this._UniversalProvider) == null ? void 0 : _a2.session) {
      await this.initModal();
      if (!this._modal) {
        throw Error("WalletConnect Adapter -Modal is undefined: unable to disconnect");
      }
      await this.client.disconnect();
      this._session = void 0;
    } else {
      throw new ClientNotInitializedError();
    }
  }
  get client() {
    if (this._UniversalProvider) {
      return this._UniversalProvider;
    }
    throw new ClientNotInitializedError();
  }
  get session() {
    if (!this._session) {
      throw new ClientNotInitializedError();
    }
    return this._session;
  }
  get publicKey() {
    var _a2, _b, _c2;
    if (((_a2 = this._UniversalProvider) == null ? void 0 : _a2.session) && this._session) {
      const { address } = Xe(((_c2 = (_b = this._session) == null ? void 0 : _b.namespaces["solana"]) == null ? void 0 : _c2.accounts[0]) ?? "");
      return new PublicKey(address);
    }
    throw new ClientNotInitializedError();
  }
  async signTransaction(transaction) {
    this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signTransaction);
    const isVersioned = isVersionedTransaction(transaction);
    const legacyTransaction = isVersioned ? {} : transaction;
    const { signature, transaction: signedSerializedTransaction } = await this.client.client.request({
      chainId: this._network,
      topic: this.session.topic,
      request: {
        method: WalletConnectRPCMethods.signTransaction,
        params: {
          /*
           * Passing ...legacyTransaction is deprecated.
           * All new clients should rely on the `transaction` parameter.
           * The future versions will stop passing ...legacyTransaction.
           */
          ...legacyTransaction,
          // New base64-encoded serialized transaction request parameter
          transaction: this.serialize(transaction)
        }
      }
    });
    if (signedSerializedTransaction) {
      return this.deserialize(signedSerializedTransaction, isVersioned);
    }
    transaction.addSignature(this.publicKey, Buffer.from(esm_default6.decode(signature)));
    return transaction;
  }
  async signMessage(message) {
    this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signMessage);
    const { signature } = await this.client.client.request({
      // The network does not change the output of message signing, but this is a required parameter for SignClient
      chainId: this._network,
      topic: this.session.topic,
      request: {
        method: WalletConnectRPCMethods.signMessage,
        params: {
          pubkey: this.publicKey.toString(),
          message: esm_default6.encode(message)
        }
      }
    });
    return esm_default6.decode(signature);
  }
  async signAndSendTransaction(transaction) {
    this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signAndSendTransaction);
    const { signature } = await this.client.client.request({
      chainId: this._network,
      topic: this.session.topic,
      request: {
        method: WalletConnectRPCMethods.signAndSendTransaction,
        params: { transaction: this.serialize(transaction) }
      }
    });
    return signature;
  }
  async signAllTransactions(transactions) {
    try {
      this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signAllTransactions);
      const serializedTransactions = transactions.map((transaction) => this.serialize(transaction));
      const { transactions: serializedSignedTransactions } = await this.client.client.request({
        chainId: this._network,
        topic: this.session.topic,
        request: {
          method: WalletConnectRPCMethods.signAllTransactions,
          params: { transactions: serializedTransactions }
        }
      });
      return transactions.map((transaction, index) => {
        if (isVersionedTransaction(transaction)) {
          return this.deserialize(serializedSignedTransactions[index] ?? "", true);
        }
        return this.deserialize(serializedSignedTransactions[index] ?? "");
      });
    } catch (error) {
      if (error instanceof WalletConnectFeatureNotSupportedError) {
        const promises = transactions.map((transaction) => this.signTransaction(transaction));
        const signedTransactions = await Promise.all(promises);
        return signedTransactions;
      }
      throw error;
    }
  }
  async initClient(options) {
    const provider = await oh.init(options);
    this._UniversalProvider = provider;
    if (this._ConnectQueueResolver) {
      this._ConnectQueueResolver(true);
    }
  }
  async initModal() {
    if (this._modal) {
      return;
    }
    if (!this._UniversalProvider) {
      throw new Error("WalletConnect Adapter - cannot init modal when Universal Provider is undefined");
    }
    this._modal = createAppKit({
      projectId: this._projectId,
      universalProvider: this._UniversalProvider,
      networks: [solana, solanaDevnet, solanaTestnet],
      manualWCControl: true
    });
  }
  serialize(transaction) {
    return Buffer.from(transaction.serialize({ verifySignatures: false })).toString("base64");
  }
  deserialize(serializedTransaction, versioned = false) {
    if (versioned) {
      return VersionedTransaction.deserialize(Buffer.from(serializedTransaction, "base64"));
    }
    return Transaction.from(Buffer.from(serializedTransaction, "base64"));
  }
  checkIfWalletSupportsMethod(method) {
    var _a2;
    if (!((_a2 = this.session.namespaces["solana"]) == null ? void 0 : _a2.methods.includes(method))) {
      throw new WalletConnectFeatureNotSupportedError(method);
    }
  }
};

// node_modules/@walletconnect/solana-adapter/dist/adapter.js
var WalletConnectWalletName = "WalletConnect";
var WalletConnectWalletAdapter = class extends BaseSignerWalletAdapter {
  constructor(config) {
    super();
    __publicField(this, "name", WalletConnectWalletName);
    __publicField(this, "url", "https://walletconnect.org");
    __publicField(this, "icon", "data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjE4NSIgdmlld0JveD0iMCAwIDMwMCAxODUiIHdpZHRoPSIzMDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTYxLjQzODU0MjkgMzYuMjU2MjYxMmM0OC45MTEyMjQxLTQ3Ljg4ODE2NjMgMTI4LjIxMTk4NzEtNDcuODg4MTY2MyAxNzcuMTIzMjA5MSAwbDUuODg2NTQ1IDUuNzYzNDE3NGMyLjQ0NTU2MSAyLjM5NDQwODEgMi40NDU1NjEgNi4yNzY1MTEyIDAgOC42NzA5MjA0bC0yMC4xMzY2OTUgMTkuNzE1NTAzYy0xLjIyMjc4MSAxLjE5NzIwNTEtMy4yMDUzIDEuMTk3MjA1MS00LjQyODA4MSAwbC04LjEwMDU4NC03LjkzMTE0NzljLTM0LjEyMTY5Mi0zMy40MDc5ODE3LTg5LjQ0Mzg4Ni0zMy40MDc5ODE3LTEyMy41NjU1Nzg4IDBsLTguNjc1MDU2MiA4LjQ5MzYwNTFjLTEuMjIyNzgxNiAxLjE5NzIwNDEtMy4yMDUzMDEgMS4xOTcyMDQxLTQuNDI4MDgwNiAwbC0yMC4xMzY2OTQ5LTE5LjcxNTUwMzFjLTIuNDQ1NTYxMi0yLjM5NDQwOTItMi40NDU1NjEyLTYuMjc2NTEyMiAwLTguNjcwOTIwNHptMjE4Ljc2Nzc5NjEgNDAuNzczNzQ0OSAxNy45MjE2OTcgMTcuNTQ2ODk3YzIuNDQ1NTQ5IDIuMzk0Mzk2OSAyLjQ0NTU2MyA2LjI3NjQ3NjkuMDAwMDMxIDguNjcwODg5OWwtODAuODEwMTcxIDc5LjEyMTEzNGMtMi40NDU1NDQgMi4zOTQ0MjYtNi40MTA1ODIgMi4zOTQ0NTMtOC44NTYxNi4wMDAwNjItLjAwMDAxLS4wMDAwMS0uMDAwMDIyLS4wMDAwMjItLjAwMDAzMi0uMDAwMDMybC01Ny4zNTQxNDMtNTYuMTU0NTcyYy0uNjExMzktLjU5ODYwMi0xLjYwMjY1LS41OTg2MDItMi4yMTQwNCAwLS4wMDAwMDQuMDAwMDA0LS4wMDAwMDcuMDAwMDA4LS4wMDAwMTEuMDAwMDExbC01Ny4zNTI5MjEyIDU2LjE1NDUzMWMtMi40NDU1MzY4IDIuMzk0NDMyLTYuNDEwNTc1NSAyLjM5NDQ3Mi04Ljg1NjE2MTIuMDAwMDg3LS4wMDAwMTQzLS4wMDAwMTQtLjAwMDAyOTYtLjAwMDAyOC0uMDAwMDQ0OS0uMDAwMDQ0bC04MC44MTI0MTk0My03OS4xMjIxODVjLTIuNDQ1NTYwMjEtMi4zOTQ0MDgtMi40NDU1NjAyMS02LjI3NjUxMTUgMC04LjY3MDkxOTdsMTcuOTIxNzI5NjMtMTcuNTQ2ODY3M2MyLjQ0NTU2MDItMi4zOTQ0MDgyIDYuNDEwNTk4OS0yLjM5NDQwODIgOC44NTYxNjAyIDBsNTcuMzU0OTc3NSA1Ni4xNTUzNTdjLjYxMTM5MDguNTk4NjAyIDEuNjAyNjQ5LjU5ODYwMiAyLjIxNDAzOTggMCAuMDAwMDA5Mi0uMDAwMDA5LjAwMDAxNzQtLjAwMDAxNy4wMDAwMjY1LS4wMDAwMjRsNTcuMzUyMTAzMS01Ni4xNTUzMzNjMi40NDU1MDUtMi4zOTQ0NjMzIDYuNDEwNTQ0LTIuMzk0NTUzMSA4Ljg1NjE2MS0uMDAwMi4wMDAwMzQuMDAwMDMzNi4wMDAwNjguMDAwMDY3My4wMDAxMDEuMDAwMTAxbDU3LjM1NDkwMiA1Ni4xNTU0MzJjLjYxMTM5LjU5ODYwMSAxLjYwMjY1LjU5ODYwMSAyLjIxNDA0IDBsNTcuMzUzOTc1LTU2LjE1NDMyNDljMi40NDU1NjEtMi4zOTQ0MDkyIDYuNDEwNTk5LTIuMzk0NDA5MiA4Ljg1NjE2IDB6IiBmaWxsPSIjM2I5OWZjIi8+PC9zdmc+");
    /*
     * V0 transactions are supported via the `transaction` parameter, and is off-spec.
     * Legacy transactions have these [parameters](https://docs.walletconnect.com/2.0/advanced/rpc-reference/solana-rpc#solana_signtransaction)
     */
    __publicField(this, "supportedTransactionVersions", /* @__PURE__ */ new Set(["legacy", 0]));
    __publicField(this, "_publicKey");
    __publicField(this, "_connecting");
    __publicField(this, "_wallet");
    __publicField(this, "_config");
    __publicField(this, "_readyState");
    __publicField(this, "_onDisconnect");
    this._publicKey = null;
    this._connecting = false;
    this._config = config;
    this._wallet = null;
    this._readyState = typeof window === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
    this._onDisconnect = this.disconnect.bind(this);
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting) {
        return;
      }
      if (this._readyState !== WalletReadyState.Loadable) {
        throw new WalletNotReadyError();
      }
      this._connecting = true;
      this._wallet = new WalletConnectWallet({
        network: this._config.network === WalletAdapterNetwork.Mainnet ? WalletConnectChainID.Mainnet : WalletConnectChainID.Devnet,
        options: this._config.options
      });
      const { publicKey } = await this._wallet.connect();
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
      this._wallet.client.on("session_delete", this._onDisconnect);
    } catch (error) {
      if (error.constructor.name === "QRCodeModalError" || error instanceof Error && error.name === "QRCodeModalError") {
        throw new WalletWindowClosedError();
      }
      this._connecting = false;
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.client.off("session_delete", this._onDisconnect);
      this._publicKey = null;
      try {
        if (wallet.client.session) {
          await wallet.disconnect();
        }
      } catch (error) {
        console.error("WalletConnectWalletAdapter: disconnect error", error);
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet) {
        throw new WalletNotConnectedError();
      }
      try {
        return await wallet.signTransaction(transaction);
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet) {
        throw new WalletNotConnectedError();
      }
      try {
        return await wallet.signMessage(message);
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAndSendTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet) {
        throw new WalletNotConnectedError();
      }
      try {
        return await wallet.signAndSendTransaction(transaction);
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet) {
        throw new WalletNotConnectedError();
      }
      try {
        return await wallet.signAllTransactions(transactions);
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};

// node_modules/@solana/wallet-adapter-xdefi/lib/esm/adapter.js
init_index_browser_esm();
var XDEFIWalletName = "XDEFI";
var XDEFIWalletAdapter = class extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = XDEFIWalletName;
    this.url = "https://xdefi.io";
    this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTE0LjI2MjggMTMuNDAxM0MxMi40MjI4IDE0LjUzMDcgOS45NTk5NyAxNS4xMTI0IDcuNDY1NjkgMTQuOTg4MUM1LjM2ODU1IDE0Ljg4NjUgMy42NDg1NSAxNC4xNDExIDIuNjA4NTUgMTIuOTE1N0MxLjY5NDI2IDExLjgyMDEgMS4zMzk5OCAxMC4zNzQ1IDEuNTc5OTggOC43MTE0M0MxLjY2MTMyIDguMTU4NzQgMS44MjgwMiA3LjYyMTY2IDIuMDc0MjYgNy4xMTg5NkwyLjEwODU1IDcuMDQ4MzdDMi45NzE4IDUuNDA1OTUgNC4yNTI5MyA0LjAxMzk3IDUuODI1ODQgMy4wMDk0MkM3LjM5ODc1IDIuMDA0ODYgOS4yMDkyNCAxLjQyMjM2IDExLjA3OTEgMS4zMTkyNEMxMi45NDkgMS4yMTYxMSAxNC44MTM4IDEuNTk1OTIgMTYuNDkwMSAyLjQyMTI4QzE4LjE2NjMgMy4yNDY2NSAxOS41OTYyIDQuNDg5MTIgMjAuNjM5IDYuMDI2NDFDMjEuNjgxOSA3LjU2MzcxIDIyLjMwMTcgOS4zNDI4NSAyMi40Mzc0IDExLjE4ODdDMjIuNTczMiAxMy4wMzQ2IDIyLjIyMDMgMTQuODgzNiAyMS40MTM0IDE2LjU1MzhDMjAuNjA2NSAxOC4yMjQgMTkuMzczNSAxOS42NTc3IDE3LjgzNTYgMjAuNzE0QzE2LjI5NzggMjEuNzcwMiAxNC41MDgxIDIyLjQxMjYgMTIuNjQyOCAyMi41Nzc4TDEyLjc1NzEgMjMuODczOEMxNC44NTE0IDIzLjY4OTQgMTYuODYxIDIyLjk2OTEgMTguNTg3OCAyMS43ODM3QzIwLjMxNDcgMjAuNTk4NCAyMS42OTkzIDE4Ljk4ODkgMjIuNjA1MiAxNy4xMTM4QzIzLjUxMTEgMTUuMjM4NyAyMy45MDcxIDEzLjE2MjcgMjMuNzU0MiAxMS4wOTA0QzIzLjYwMTIgOS4wMTgwOCAyMi45MDQ2IDcuMDIwODggMjEuNzMyOSA1LjI5NTU1QzIwLjU2MTMgMy41NzAyMiAxOC45NTUgMi4xNzYzIDE3LjA3MjQgMS4yNTExMUMxNS4xODk4IDAuMzI1OTA5IDEzLjA5NTcgLTAuMDk4NjQxMSAxMC45OTY1IDAuMDE5Mjc4N0M4Ljg5NzMzIDAuMTM3MTk4IDYuODY1NDQgMC43OTM1MiA1LjEwMTAyIDEuOTIzNTlDMy4zMzY2IDMuMDUzNjUgMS45MDA1MyA0LjYxODQ4IDAuOTM0MjY0IDYuNDYzOUwwLjg4ODU0OCA2LjU1NzA3QzAuNTgzMDgzIDcuMTgwOSAwLjM3Njg0NyA3Ljg0NzU2IDAuMjc3MTIgOC41MzM1NEMtMC4wMDg1OTQ1IDEwLjU2MDggMC40MzQyNiAxMi4zNjUxIDEuNTkxNCAxMy43NTQyQzIuODU3MTIgMTUuMjczMyA0LjkxNzEyIDE2LjE3NjggNy4zODg1NSAxNi4yOTU0QzEwLjM5NzEgMTYuNDQ1MSAxMy4zODg1IDE1LjYzNDcgMTUuNTExNCAxNC4xNDM5TDE0LjI2MjggMTMuNDAxM1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0xNi43OCAxNC44NzUxQzE1LjU4MjkgMTUuOTAyOSAxMi44IDE3Ljc2NjQgOC4xODI4NiAxOC4wMjA1QzMuMDE0MjkgMTguMzAyOSAwLjg2MDAwMSAxNi42NDI3IDAuODQwMDAxIDE2LjYyNTdMMC40MjI4NTYgMTcuMTMzOUwwLjg0Mjg1NiAxNi42MzQyTDAgMTcuNjMzN0MwLjA5MTQyODYgMTcuNzA5OSAyLjE1NzE0IDE5LjM1ODkgNy4wMDg1NyAxOS4zNTg5QzcuNDA1NzEgMTkuMzU4OSA3LjgyMjg2IDE5LjM1ODkgOC4yNTcxNCAxOS4zMjVDMTMuODM3MSAxOS4wMTcyIDE2LjkwMjkgMTYuNjExNiAxNy45NzE0IDE1LjU4MzhMMTYuNzggMTQuODc1MVoiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0xOS4wMiAxNi4yMTkyQzE4LjMxMjEgMTcuMTM4NyAxNy40NDA4IDE3LjkyMzMgMTYuNDQ4NiAxOC41MzQ1QzEyLjk1MTUgMjAuNzY1IDguNTAyODkgMjEuMDUzIDUuMzg4NiAyMC44OTc4TDUuMzIyODkgMjIuMTk5NEM1Ljg0NTc1IDIyLjIyNDggNi4zNDg2MSAyMi4yMzYxIDYuODM3MTggMjIuMjM2MUMxNS42MiAyMi4yMzYxIDE5LjE2ODYgMTguMjgzMiAyMC4xNiAxNi44NzE0TDE5LjAxNzIgMTYuMjA3OSIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTE4LjY4NTcgMTEuMjkyMkMxOS4yNjggMTEuMjkyMiAxOS43NCAxMC44MjU3IDE5Ljc0IDEwLjI1MDNDMTkuNzQgOS42NzQ4OSAxOS4yNjggOS4yMDg0MiAxOC42ODU3IDkuMjA4NDJDMTguMTAzNCA5LjIwODQyIDE3LjYzMTQgOS42NzQ4OSAxNy42MzE0IDEwLjI1MDNDMTcuNjMxNCAxMC44MjU3IDE4LjEwMzQgMTEuMjkyMiAxOC42ODU3IDExLjI5MjJaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        var _a2, _b;
        if ((_b = (_a2 = window.xfi) == null ? void 0 : _a2.solana) == null ? void 0 : _b.isXDEFI) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    var _a2;
    return !!((_a2 = this._wallet) == null ? void 0 : _a2.isConnected);
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.xfi.solana;
      if (!wallet.isConnected) {
        try {
          await wallet.connect();
        } catch (error) {
          throw new WalletConnectionError(error == null ? void 0 : error.message, error);
        }
      }
      if (!wallet.publicKey)
        throw new WalletAccountError();
      let publicKey;
      try {
        publicKey = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
      }
      wallet.on("disconnect", this._disconnected);
      this._wallet = wallet;
      this._publicKey = publicKey;
      this.emit("connect", publicKey);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.off("disconnect", this._disconnected);
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      }
    }
    this.emit("disconnect");
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signature } = await wallet.signMessage(message);
        return signature;
      } catch (error) {
        throw new WalletSignMessageError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
};
export {
  AlphaWalletAdapter,
  AlphaWalletName,
  AvanaWalletAdapter,
  AvanaWalletName,
  BitKeepWalletAdapter,
  BitKeepWalletName,
  BitgetWalletAdapter,
  BitgetWalletName,
  BitpieWalletAdapter,
  BitpieWalletName,
  CloverWalletAdapter,
  CloverWalletName,
  Coin98WalletAdapter,
  Coin98WalletName,
  CoinbaseWalletAdapter,
  CoinbaseWalletName,
  CoinhubWalletAdapter,
  CoinhubWalletName,
  FractalWalletAdapter,
  FractalWalletName,
  HuobiWalletAdapter,
  HuobiWalletName,
  HyperPayWalletAdapter,
  HyperPayWalletName,
  KeystoneWalletAdapter,
  KeystoneWalletName,
  KrystalWalletAdapter,
  KrystalWalletName,
  LedgerWalletAdapter,
  LedgerWalletName,
  MathWalletAdapter,
  MathWalletName,
  NekoWalletAdapter,
  NekoWalletName,
  NightlyWalletAdapter,
  NightlyWalletName,
  NufiWalletAdapter,
  NufiWalletName,
  OntoWalletAdapter,
  OntoWalletName,
  ParticleAdapter,
  ParticleName,
  PhantomWalletAdapter,
  PhantomWalletName,
  SafePalWalletAdapter,
  SafePalWalletName,
  SaifuWalletAdapter,
  SaifuWalletName,
  SalmonWalletAdapter,
  SalmonWalletName,
  SkyWalletAdapter,
  SkyWalletName,
  SolflareWalletAdapter,
  SolflareWalletName,
  SolongWalletAdapter,
  SolongWalletName,
  SpotWalletAdapter,
  SpotWalletName,
  TokenPocketWalletAdapter,
  TokenPocketWalletName,
  TokenaryWalletAdapter,
  TokenaryWalletName,
  TorusWalletAdapter,
  TorusWalletName,
  TrezorWalletAdapter,
  TrezorWalletName,
  TrustWalletAdapter,
  TrustWalletName,
  UnsafeBurnerWalletAdapter,
  UnsafeBurnerWalletName,
  WalletConnectWalletAdapter,
  WalletConnectWalletName,
  XDEFIWalletAdapter,
  XDEFIWalletName,
  getDerivationPath
};
/*! Bundled license information:

@walletconnect/utils/dist/index.es.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@walletconnect/utils/dist/index.es.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@solana_wallet-adapter-wallets.js.map
